# https://docs.solanamobile.com/ llms-full.txt

## Solana Mobile Development
[Skip to main content](https://docs.solanamobile.com/#__docusaurus_skipToContent_fallback)

_![Solana Mobile Stack](https://docs.solanamobile.com/img/Solana_Mobile_With_Logo_White.png)_

Developer Hub

[**Documentation** \\
\\
Build mobile dApps with our SDK and developer tools](https://docs.solanamobile.com/developers/overview) [**dApp Store** \\
\\
Publish your dApp on the Solana dApp Store](https://docs.solanamobile.com/dapp-publishing/intro) [**Hackathon** \\
\\
Compete in the very first Solana Mobile Hackathon](https://solanamobile.radiant.nexus/) [**Grants** \\
\\
Help push the Solana Mobile Developer ecosystem forward](https://docs.solanamobile.com/grants)

## Developer Agreement Overview
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/agreement#__docusaurus_skipToContent_fallback)

**Version 2.1: Effective DECEMBER 3, 2025**

**PLEASE READ THIS DEVELOPER AGREEMENT (“Agreement”) CAREFULLY BEFORE SUBMITTING YOUR DEVELOPER ASSETS (AS DEFINED BELOW) TO SOLANA MOBILE. THIS AGREEMENT CONSTITUTES A BINDING LEGAL AGREEMENT BETWEEN YOU AND SOLANA MOBILE.**

Before submitting your Developer Assets to Solana Mobile to be made available through the dApp Store (as defined below), you must accept the terms of this Agreement, including without limitation the Solana Mobile dApp Store Terms of Use (the “ **dApp Store Terms**”), which are hereby incorporated herein. Any capitalized terms used but not defined herein have the meaning given in the dApp Store Terms. In the event of a conflict between the dApp Store Terms and this Developer Agreement, the provisions of this Developer Agreement will control to the extent of such conflict.

By selecting the “I accept” button or other mechanism designed to acknowledge agreement, submitting your Developer Assets to Solana Mobile, or otherwise interacting with the dApp Publishing Platform (as defined below), you acknowledge and agree that you have read and agree to the terms of this Agreement on your behalf and/or on behalf of your company, organization, agency or other entity (collectively, “ **Entity**”) as its authorized legal representative. You may not accept this Agreement on behalf of an Entity unless you are an employee or other authorized agent of such Entity with the right, power and authority to act on behalf of such Entity, in which case (i) “ **you**” and “ **your**” as used herein shall also include such Entity, and (ii) you represent and warrant that you have the authority to bind such Entity to this Agreement. IF YOU ARE UNWILLING TO ACCEPT THESE AGREEMENT TERMS, AND/OR YOU DO NOT HAVE THE RIGHT, POWER AND AUTHORITY TO ACT ON BEHALF OF AND BIND SUCH ENTITY, DO NOT SELECT THE “I ACCEPT” BUTTON OR OTHERWISE CLICK ON ANY BUTTON (OR OTHER) MECHANISM DESIGNED TO ACKNOWLEDGE AGREEMENT, AND DO NOT SUBMIT, UPLOAD OR DISTRIBUTE (DIRECTLY OR INDIRECTLY) ANY DEVELOPER ASSETS OR ANY OTHER PRODUCT OR MATERIAL ON OR THROUGH THE DAPP PUBLISHING PLATFORM.

Solana Mobile reserves the right to change the terms of this Agreement (including without limitation, any Commission rate) from time to time, and provide you with reasonable notice of such change, including by posting a revised version of such terms on the dApp Store and/or dApp Publishing Platform or by emailing you at the most recent email address provided by you in connection with your use of the dApp Publishing Platform. If you do not agree with any such updated Agreement, you must stop using the dApp Publishing Platform. Continued use of the dApp Publishing Platform following notice of any such change will constitute acceptance of such updated Agreement.

PLEASE BE AWARE THAT SECTION 16 (DISPUTES) OF THIS AGREEMENT, BELOW, CONTAINS PROVISIONS GOVERNING HOW DISPUTES THAT YOU AND SOLANA MOBILE, ITS PARENTS, SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, SUPPLIERS, OR LICENSORS (EACH, A “ **SOLANA MOBILE PARTY**” AND COLLECTIVELY, THE “ **SOLANA MOBILE PARTIES**”) HAVE AGAINST EACH OTHER UNDER THESE TERMS ARE RESOLVED INCLUDING, WITHOUT LIMITATION, ANY DISPUTES THAT AROSE OR WERE ASSERTED PRIOR TO THE EFFECTIVE DATE OF THESE TERMS. IN PARTICULAR, SECTION 16 (DISPUTES) CONTAINS AN ARBITRATION AGREEMENT WHICH WILL, WITH LIMITED EXCEPTIONS, REQUIRE DISPUTES BETWEEN YOU AND ANY OF THE SOLANA MOBILE PARTIES TO BE SUBMITTED TO BINDING AND FINAL ARBITRATION. UNLESS YOU OPT OUT OF THE ARBITRATION AGREEMENT: (1) YOU WILL ONLY BE PERMITTED TO PURSUE DISPUTES OR CLAIMS AND SEEK RELIEF AGAINST THE SOLANA MOBILE PARTIES ON AN INDIVIDUAL BASIS, NOT AS A PLAINTIFF OR CLASS MEMBER IN ANY CLASS OR REPRESENTATIVE ACTION OR PROCEEDING; AND (2) YOU ARE WAIVING YOUR RIGHT TO PURSUE DISPUTES OR CLAIMS AND SEEK RELIEF IN A COURT OF LAW AND TO HAVE A JURY TRIAL.

NOTHING IN THIS AGREEMENT AFFECTS YOUR STATUTORY LEGAL RIGHTS UNDER APPLICABLE LAW.

1\. Definitions

1.1. “ **Applicable Data Protection Legislation**” means, as applicable to the processing of Controller Personal Data, any Applicable Law, including national, federal, EU, state, provincial or other privacy, data protection law or regulation which are currently in effect and as they become effective, as amended from time to time, including European Data Protection Legislation.

1.2. “ **Applicable Law(s)**” means, individually and collectively, applicable laws, rules, regulations, and judicial and governmental orders including without limitation Applicable Data Protection Legislation.

1.3. “ **Commission**” means an amount payable to Solana Mobile which equals a percentage of the amount equal to the fee Developer received for the distribution of its Developer Applications less the transaction cost for such sale charged by the Payment Processor. The parties acknowledge that Solana Mobile currently charges a commission rate of 0.0% to Developer, which rate may be revised by Solana Mobile from time to time in accordance with the terms of this Agreement.

1.4. **“Controller Personal Data”** means personal data that is processed by a party under the Agreement in connection with its provisioning or use of the dApp Store.

1.5. “ **dApp Data**” means data generated by or through any End User’s use of a Developer Application.

1.6. “ **dApp Publishing Platform**” means the interface made available by Solana Mobile, and any tools (including any Publishing Tools) made available thereby or therethrough, that enables Developers to make Developer Applications available on or through the dApp Store.

1.7. “ **Controller SCCs**” means Module One of the standard contractual clauses approved by the European Commission pursuant to implementing Decision (EU) 2021/914.

1.8. “ **dApp Store**” means that certain Solana Mobile platform (and all related content, materials and services), currently referred to as the “dApp Store,” and any and all successors, replacements, new versions, and updates and upgrades thereto, which platform allows: (a) Developers to submit Developer Applications for inclusion in the dApp Store, (b) Developers to make available Developer Applications to End Users, and (c) End Users to purchase and/or download (via in-product access and/or through one or more Solana Mobile Sites) Developer Applications.

1.9. “ **Developer**” means the person or Entity that accepts this Agreement and submits a Developer Application to the dApp Publishing Platform subject to the terms of this Agreement.

1.10. “ **Developer Application**” means a software application or other item or material developed and branded by or for Developer which is compatible with and relevant to the designated Solana Mobile Product and is submitted by Developer to the dApp Publishing Platform for distribution through the dApp Store. Developer Application includes all extensions, revisions, bug fixes, updates, upgrades, modifications, enhancements and new versions submitted to the dApp Publishing Platform, and any services or subscriptions provided through or in connection with Developer Application.

1.11. “ **Developer Assets**” means, collectively, Developer Applications and Developer Marks.

1.12. “ **Developer Marks**” means Developer’s trademarks, service marks, logos, and other indicia of brand identity.

1.13. “ **End User**” means the end user of a Developer Application.

1.14. “ **End User License Agreement**” or “ **EULA**” means the end user license agreement or terms of service between Developer and each of its End Users.

1.15. “ **European Data Protection Legislation**” means, where applicable, the GDPR (Regulation (EU) 2016/679 of the European Parliament) (“ **EU GDPR**”), the UK GDPR (the EU GDPR as amended and incorporated into UK law under the UK European Union (Withdrawal) Act 2018) (“ **UK GDP** R”), or the Swiss FDPA (Federal Data Protection Act of 19 June 1992).

1.16. “ **Feedback**” means all suggestions, comments, input, ideas, reports, information or know-how (whether in oral, electronic or written form) provided by Developer to Solana Mobile in connection with Developer’s evaluation and use of any Solana Mobile Properties.

1.17. “ **Intellectual Property Rights**” means all rights in and to trade secrets, patents, copyrights, trademarks, knowhow, as well as moral rights, and similar rights of any type under the laws of any governmental authority, domestic or foreign or any international treaties.

1.18. “ **Open Source Software**” means software that is subject to any license (including, without limitation, the GNU General Public License or GNU Lesser/Library General Public License) which requires that such software be, as a condition of use, copying, modification or redistribution: (a) disclosed or distributed in source code form, (b) licensed for the purpose of making derivative works, or (c) redistributed free of charge.

1.19. “ **Payment Processor**” means a third party payment processing service provider designated by Developer to process all payments and charges for Developer Applications.

1.20. “ **Product Guidelines**” means any instructions or guidelines provided by Solana Mobile and detailing the specifications, requirements and guidelines to which Developer Application must conform in order to be distributed through the dApp Store.

1.21. “ **Publishing Tool**” means any applications programming interface information that specifies the requirements for interfacing to (e.g., invoking or directing the functions of) the Solana Mobile Product, and other toolkits, libraries, scripts, reference or sample code, and similar Publishing Tools made available through the dApp Publishing Platform or otherwise provided or made available by Solana Mobile.

1.22. “ **Restricted European Transfers**” means the transfer of Controller Personal Data to the other party in a country that is not recognized as ensuring an adequate level of data protection under European Data Protection Legislation.

1.23. “ **Review**” has the meaning set forth in the dApp Store Terms.

1.24. “ **Solana Mobile**” means Solana Mobile, Inc., a Delaware corporation located at 605 N Michigan Ave, Floor 4 #1478783, Chicago, IL 60611.

1.25. “ **Solana Mobile Properties**” means, collectively, the dApp Store, Solana Mobile Site, dApp Publishing Platform, Solana Mobile Confidential Information, Solana Mobile Products (including, without limitation, any Publishing Tools provided therewith) and Solana Mobile Materials.

1.26. “ **Solana Mobile Confidential Information**” means any information that Solana Mobile designates as being confidential or which, given the nature of the information or the circumstances surrounding its disclosure, reasonably should be considered as confidential. Solana Mobile Confidential Information may be in tangible or intangible form and disclosed orally, visually or in writing. Solana Mobile Confidential Information includes, without limitation, any non-public information related to the Solana Mobile Phone or any of Solana Mobile’s pre-release products, product names, code names, specifications, development plans and results, research activities and results, improvements, functionality, defects, errors, techniques, inventions, whether patentable or not, code, documentation, algorithms, formulas, data structures, scripts, protocols, application programming interfaces and other technical information, marketing or promotional plans or materials, product pricing, product costs, business opportunities and financial information, strategies, timetables, forecasts, business policies or practices, processes, ideas, know-how and expertise of employees or consultants, and information received from third parties which Solana Mobile is obligated to keep confidential. Solana Mobile Confidential Information does not include any information, as evidenced by contemporaneous written records, that: (a) is or subsequently becomes publicly available without a breach of any of Developer’s obligations hereunder; (b) was known by Developer prior to disclosure by Solana Mobile, without an obligation of confidentiality; (c) became known by Developer from a third party, other than by the breach of any obligation of confidentiality; or (d) is independently developed by Developer without use of or access to Solana Mobile Confidential Information.

1.27. “ **Solana Mobile Materials**” means any Solana Mobile Product or Solana Mobile Site and any and all trademarks, service marks, logos, brand features, content, hardware, software, data, or other materials, and all Intellectual Property Rights therein.

1.28. “ **Solana Mobile Products**” means Solana Mobile’s generally available commercial devices, software programs, operating systems, products, or other services, (including, without limitation, any extensions, revisions, corrections, patches, service packs, updates, upgrades, modifications, enhancements and versions thereto) provided or made available by Solana Mobile. Solana Mobile Products may also include Solana Mobile software programs, devices, products, applications or components provided or made available by Solana Mobile, which are not in final form and have not been commercially released to the general public, including without limitation any related specifications and all versions thereof, whether labeled alpha, beta, pre-release, preview or otherwise.

1.29. “ **Solana Mobile Site**” means any website, web app, or mobile application owned or operated by Solana Mobile, and all its subpages, subdomains, online platforms, or any alternatives or replacements for the same, designated by Solana Mobile in its sole discretion.

1.30. The terms “ **controller**”, “ **processing**”, “ **processor**”, “ **data subject**”, and “ **personal data**”, shall have the meaning given to those terms by Applicable Data Protection Legislation.

2\. Use of the dApp Publishing Platform.

2.1. **Delivery**. Delivery of each Developer Application will be made by electronic transmission to the dApp Publishing Platform. Developer will make available in an easily accessible location within each Developer Application a link to the applicable privacy policy and EULA and the text of such privacy policy and EULA. By submitting a Developer Application to Solana Mobile, Developer represents and warrants that such Developer Application satisfies and complies with the terms of this Agreement, the Product Guidelines and all Applicable Laws.

2.2. **Support**. In the event that any issues arise related to your use of the dApp Publishing Platform, you may direct any Feedback to Solana Mobile, by sending an email to [concerns@dappstore.solanamobile.com](mailto:concerns@dappstore.solanamobile.com). Solana Mobile reserves the right, but has no obligation, to respond to any such Feedback or issues.

2.3. **dApp Store Reviews**. Developer acknowledges and agrees that the dApp Store may enable the publication of Reviews from End Users. Developer shall not, directly or indirectly, submit or cause, request, or incent any third party to submit any review of any Developer Application or other Application that violates the [dApp Store Review Policy](https://solanamobile.com/review-policy). In particular, and without limiting the foregoing, Developer will not, directly or indirectly, attempt (or cause or permit any third party to attempt) to manipulate any Reviews, including by (i) submitting any false, misleading, or untruthful content; or (ii) purchasing or soliciting Reviews from any person that is not an authentic End User of the applicable Developer Application. In the event of Developer’s breach of this Section 2.3, without limiting any of Solana Mobile’s other rights and remedies hereunder, Solana Mobile may in its sole and absolute discretion to remove such Reviews, remove the applicable Developer Application from the dApp Store, prohibit Developer from using the dApp Store, take legal action against Developer, and report Developer to applicable legal authorities.

2.4. **Updates.** From time to time, Solana Mobile may release Updates to Solana Mobile Products. You are solely responsible for ensuring that your Developer Application is compatible with such Updates and any new Product Guidelines released in connection therewith. You agree to promptly release and publish any changes or updates to a Developer Application reasonably necessary to ensure compatibility with the applicable Updates.

3\. Monitoring and Enforcement. Solana Mobile reserves the right, but has no obligation, to review any Developer Application prior to or at any time subsequent to the publication of such Developer Application to the dApp Store and may remove any Developer Application from the dApp Store at any time and for any or for no reason, with or without cause, and without any liability whatsoever (including without limitation, for any development costs). Any failure to review or remove a Developer Application by Solana Mobile shall not relieve Developer of any of the obligations under Section 5 (Responsibility for Developer Assets; Release of the Solana Mobile Parties). Developer will be solely responsible for (i) developing Developer Applications that are safe, free of defects in design, operation and performance, and comply with the terms of this Agreement, the Product Guidelines and all Applicable Laws; (ii) any associated documentation and End User customer support and warranty of Developer Applications; and (iii) ensuring that the Developer Assets as submitted to the dApp Publishing Platform include a EULA and privacy policy that accurately reflect the functionality of the Developer Application and the rights and obligations of Developer and each end user of such Developer Application with respect thereto, and otherwise comply with Section 10.6 (End User Licensing). For purposes of clarity, the fact that Solana Mobile may have reviewed any of Developer Applications will not relieve Developer of any of the responsibilities described in this Agreement. Once distributed by Developer through the dApp Store, Solana Mobile reserves the right, in its sole discretion, to make all decisions regarding placement or promotion of Developer Applications on the dApp Store.

4\. Price, Commission, Taxes & Refunds

4.1. **Price**. Developer is responsible for setting the price or fee (including, without limitation, subscription fees or any periodic or one-time payments) that End Users must pay for Developer Applications. For purposes of clarity, Developer may choose to distribute or make available any Developer Application at no charge to End Users.

4.2. **Payment**. Any and all payments for Developer Applications shall be made through the Payment Processor. Accordingly, Developer agrees that, as between Developer and Solana Mobile, Developer is solely responsible for entering into a payment agreement with the Payment Processor, abiding by all the rules and policies required by the Payment Processor as the “Seller of Record,” and maintaining a valid account in good standing with such Payment Processor. Developer is solely responsible for verifying that it has received payment for each distribution of the Developer Applications through the dApp Store.

4.3. **Commission**. The parties acknowledge that Solana Mobile charges a commission rate of 0.0% to Developer for any Developer Application.

4.4. **Taxes**. Developer shall be solely responsible for any and all taxes attributable to the Developer Applications and the Commission, including without limitation, sales, use, excise, import, export, value-added tax and other taxes. Developer shall be solely responsible for verifying if a Developer Application is taxable and notifying Payment Processor of the applicable tax rate for the Payment Processor to collect for each taxing jurisdiction, and for remitting taxes to the appropriate taxing authority.

4.5. **Refunds**. Developer shall be solely responsible for issuing any refunds to End Users or otherwise resolving End Users’ complaints.

5\. Responsibility for Developer Assets; Release of the Solana Mobile Parties

5.1. **Responsibility for Developer Assets**. Developer is solely responsible for (i) the development, installation, distribution, use, support, maintenance and warranties of Developer Assets, and (ii) any and all liabilities or claims with respect to Developer Assets (including, without limitation, for product liability, property damage, personal injury or death, losses, damages, infringement of third party rights, violation of Section 11 (Data Privacy), or violation of any Applicable Laws). Developer shall ensure that the Developer Applications are delivered or provided in accordance with its EULA. Developer shall ensure that all Developer Applications utilize best-in-class security and encryption features.

5.2. **Release of the Solana Mobile Parties**. Developer is solely responsible for its use of the Solana Mobile Properties in compliance with the terms of this Agreement, the Product Guidelines and all Applicable Laws. Developer agrees that the Solana Mobile Parties shall have no responsibility or liability whatsoever in connection with the responsibilities and obligations set forth in the foregoing sentence and in Section 5.1 and, to the maximum extent permitted by Applicable Laws, Developer hereby releases and waives all claims against the Solana Mobile Parties from any and all liability for claims, damages (including direct, indirect and consequential), costs and expenses (including litigation costs and attorneys’ fees) of every kind and nature, arising out of or in any way connected with Developer Assets and Developer’s use of any Solana Mobile Properties. IF DEVELOPER IS A CALIFORNIA RESIDENT, IT WAIVES ITS RIGHTS UNDER CALIFORNIA CIVIL CODE § 1542, WHICH STATES “A GENERAL RELEASE DOES NOT EXTEND TO CLAIMS WHICH THE CREDITOR OR RELEASING PARTY DOES NOT KNOW OR SUSPECT TO EXIST IN HIS FAVOR AT THE TIME OF EXECUTING THE RELEASE, WHICH IF KNOWN TO HIM MUST HAVE MATERIALLY AFFECTED HIS SETTLEMENT WITH THE DEBTOR OR RELEASED PARTY.” Residents of other states and nations similarly waive their rights under applicable and/or analogous laws, statutes, or regulations.

6\. Representations and Warranties. Developer represents and warrants to and for the benefit of Solana Mobile that (i) it has full right and authority to grant the rights granted in this Agreement and in the EULA, including all Intellectual Property Rights, and no other party’s permission is required, (ii) Solana Mobile’s and End Users’ exercise of their respective rights does not and will not violate or infringe upon the rights of any third party or violate any Applicable Laws (including, by way of example, but not limited to, those relating to privacy, data collection, consumer protection and import/export), (iii) all information Developer provides in connection with Developer Assets is and will be accurate, complete and up-to-date, (iv) Developer Assets do not and will not contain software viruses, malicious code, harmful materials, or any other computer code, files, or programs designed to interrupt, destroy or limit the functionality of any computer software or hardware or telecommunications equipment, (v) Developer did not use, and Developer materials do not and will not contain, any Open Source Software in the development of any Developer Application which would cause any Solana Mobile Product to be subject to any licensing terms for such Open Source Software; (vi) Developer understands, acknowledges and agrees that the legal requirements pertaining to blockchain technologies generally are uncertain, and Developer has conducted an independent investigation of such potentially applicable legal requirements and the resulting risks and uncertainties, including the risk that one or more governmental entities or other persons may assert that any digital or crypto assets used as part of any Developer Application may constitute securities under applicable legal requirements, and hereby irrevocably disclaims and disavows reliance upon any statements or representations made by or on behalf of, or information made available by, Solana Mobile, in determining to enter into this Agreement; (vii) There are no legal proceedings pending that relate to Developer’s activities relating to any digital or crypto assets or other token-trading or blockchain technology related activities; (viii) Developer has not failed to comply with, and has not violated, any applicable legal requirement relating to any blockchain technologies, digital asset or token trading or staking activities or minting of any digital or crypto asset; (ix) no investigations or reviews by any governmental entity are pending or, to Developer’s knowledge, have been threatened against or with respect to Developer, nor does any government order or action prohibit Developer or any of its representatives from engaging in or continuing any conduct, activity or practice relating to the matters contemplated by this Agreement; (x) Developer is not, and Developer will not authorize, enable, or permit any use of the dApp Publishing Platform by any person or Entity that is: (1) in, under the control of, or a national or resident of any jurisdiction subject to a U.S. trade embargo (currently, Cuba, Iran, North Korea, Syria, and the Crimea, Donetsk People’s Republic, and Luhansk People’s Republic regions of Ukraine); (2) identified on any export- or sanctions-related restricted party list, including but not limited to the U.S. Department of the Treasury’s Specially Designated Nationals and Blocked Persons List or the U.S. Department of Commerce’s Denied Persons List, Unveriﬁed List, or Entity List; and (xi) Developer maintains general liability and other appropriate insurance in an amount appropriate to the nature and scope of Developer’s services, products and business, which is reasonable and customary in its industry for companies of comparable size and activities.

7\. Removal of Developer materials. Developer may remove any of Developer Assets from the dApp Store at any time and for any reason, provided that it does not affect the license rights of users who have already downloaded, accessed or purchased the Developer Applications or otherwise used Developer Assets. In addition, Solana Mobile may, in its discretion, remove any of Developer Assets from the dApp Store at any time, with or without cause and without any liability whatsoever, including, without limitation, for any losses, damages, costs or expenses. Solana Mobile may elect to provide Developer with notice of such removal in accordance with Section 17.1.

8\. Solana Mobile Confidential Information. Developer agrees to (i) use Solana Mobile Confidential Information solely for the purposes of developing, testing, evaluating, publishing, supporting and maintaining the Developer Application(s) and providing Feedback; (ii) not disclose any Solana Mobile Confidential Information to third parties; and (iii) take reasonable security precautions that are at least as protective as the precautions Developer takes to protect its own confidential information of a similar nature, but using no less than reasonable care, to keep confidential the Solana Mobile Confidential Information. Developer may disclose Solana Mobile Confidential Information only to Developer’s employees and consultants on a need-to-know basis, provided such employees and consultants have appropriate written agreements with Developer sufficient to enable Developer to comply with all the provisions of this Agreement. Developer guarantees the performance of this provision by each employee or consultant obtaining Solana Mobile Confidential Information from Developer. Developer agrees to notify Solana Mobile immediately upon discovery of any unauthorized use or disclosure of Solana Mobile Confidential Information or any other breach of this Agreement by Developer or its employees or consultants, and will cooperate with Solana Mobile in every reasonable way to help Solana Mobile regain possession of the Solana Mobile Confidential Information and prevent its further unauthorized use or disclosure. Developer may disclose Solana Mobile Confidential Information in accordance with a judicial or other governmental order, provided Developer gives Solana Mobile immediate written notice (in any event no less than five (5) days prior to such disclosure) and reasonable assistance to allow Solana Mobile a reasonable opportunity to seek a protective order or equivalent protection.

9\. No Reliance. Solana Mobile Properties may include or reference planned or future development efforts. Such references are not intended to be a promise or guarantee of future delivery of products, services or features but merely reflect current plans, which may change. Accordingly, Developer will not rely on Solana Mobile Properties for development, sales, marketing, distribution or any other purposes.

10\. Proprietary Rights and Licensing

10.1. **Ownership by Developer**. Solana Mobile acknowledges and agrees that as between the parties, Developer owns all right, title and interest (including all Intellectual Property Rights) in and to Developer Assets.

10.2. **Ownership by Solana Mobile**. Developer acknowledges and agrees that as between the parties, Solana Mobile owns all right, title and interest (including all Intellectual Property Rights) in and to the Solana Mobile Properties.

10.3. ​ **License by Developer**. Subject to this Agreement, Developer grants to Solana Mobile and any resellers, channel partners and authorized subcontractors, under all of Developer’s Intellectual Property Rights, a non-exclusive, worldwide, royalty-free license, with right to sublicense, to:

10.3.1. Make available, publicly display, perform, demonstrate, transmit, store, import and broadcast Developer Applications and enable distribution of Developer Applications (subject to the EULA between End User and Developer) through the dApp Store;

10.3.2. ​Use, reproduce, make available, publicly display and perform Developer Marks (including, without limitation, Developer’s trademarks, service marks, logos, brand features, screen shots, images, artwork, icons) for purposes of marketing, promoting and publicizing Developer Applications and the dApp Store; and

10.3.3. ​ Make, have made, use, copy, modify, and create derivative works of the Feedback as part of any Solana Mobile product, program, service, technology, specification or documentation and publicly perform and display, import, broadcast, transmit, distribute, license, offer to sell and sell, rent, lease or lend copies of the Feedback (and derivative works thereof and improvements thereon), without compensation or reporting to Developer. This license in Section 10.3.3 will be perpetual and irrevocable.

10.4. ​ **License by Solana Mobile**. To the extent that it is necessary for Developer to use the dApp Publishing Platform in order to develop and maintain the Developer Application, Solana Mobile hereby grants to Developer a limited, non-exclusive, personal, revocable, non-sublicensable and non-transferable license to use such dApp Publishing Platform internally and only for Developer’s development and support of its Developer Application. Subject to Developer’s compliance with the terms of this Agreement, Developer may also reproduce, modify or distribute certain Publishing Tools that are either (a) identified as redistributable or (b) by nature would be clearly required to be distributed, as embedded in and constituting an integrated part of the Developer Application in order to be compatible with the relevant Solana Mobile Product. Unless otherwise specifically designated, Developer acknowledges that the dApp Publishing Platform (including such Publishing Tools) will be deemed Solana Mobile Confidential Information.

10.5. ​ **Reservation of Rights**. Except as expressly granted in this Agreement, neither party shall have any rights of any kind in the other party’s intellectual property, proprietary technology, websites, products, programs or services. Under no circumstances will anything in this Agreement be construed as granting, by implication, estoppel, or otherwise, a license to Solana Mobile’s or to Developer’s Intellectual Property Rights other than in accordance with the terms of this Agreement.

10.6. ​ **End User Licensing**. Each copy of Developer Applications made available on the dApp Store will be accompanied by a EULA. Each EULA will be solely between Developer and the End User, and will conform to all Applicable Laws. The Solana Mobile Parties shall not be responsible for, and shall not have any liability whatsoever to Developer or any third party in connection with, any EULA (including, without limitation, the then-current standard dApp Store EULA) or any breach thereof by Developer or any End User. Each EULA shall be at least as restrictive as the sample EULA set forth in Exhibit A. In the event that Developer does not furnish its own EULA for any Developer Application, Developer agrees that each End User’s use of that Developer Application shall be subject to the then-current standard dApp Store EULA.

10.7. **dApp Data.** From time to time, Solana Mobile may request Developer to provide Solana Mobile with certain dApp Data, including without limitation data related to End User transactions on or through the applicable Developer Applications. Developer (a) agrees to promptly provide such dApp Data and (b) hereby grants Solana Mobile a non-exclusive, worldwide, royalty-free license, with right to sublicense, to use, store, copy, and create derivative works of such dApp Data to provide and improve the dApp Store, Solana Mobile Phone, the Operating System, and Solana Mobile’s other products and services, including without limitation to display dApp Data with respect to a particular End User’s activity through the Earn Widget on such End User’s Solana Mobile Phone. Developer represents and warrants that Developer has and will continue to have all rights and consents necessary to effect the foregoing license grant.

11\. Data Privacy

11.1. **Independent Controllers.** Each party is an independent controller of Controller Personal Data and will determine the purpose and means of the processing of Controller Personal Data. Each party will comply with its obligations under Applicable Data Protection Legislation regarding the processing of Controller Personal Data. Without prejudice to the foregoing, Developer shall:

11.1.1. reasonably cooperate with Solana Mobile to enable Solana Mobile to fulfil its obligations, as applicable, under Applicable Data Protection Legislation; and

11.1.2. provide all notices and obtain all consents as required by Applicable Data Protection Legislation to enable to lawful processing of Controller Personal Data.

11.2. **No Effect on Processor Terms.** The terms in this Section 11 will not affect any separate terms between parties reflecting a controller-processor, processor-processor or processor-controller relationship other than the dApp store use of Controller Personal Data.

11.3. **Restricted European Transfers.** The following terms shall only apply to the extent that the European Data Protection Legislation applies to the processing of Controller Personal Data and where the transfer of Controller Personal Data is a Restricted European Transfer:

11.3.1. Either party may make Restricted European Transfers if it complies with the provisions on Restricted European Transfers in the European Data Protection Legislation.

11.3.2. Parties will be deemed to have entered into the Controller SCCs and the SCCs shall be deemed incorporated into, and form part of, this Agreement.

11.3.3. Developer is the ‘data exporter’ and Solana Mobile is the ‘data importer’.

11.3.4. The appendix of the Controller SCCs shall be populated with the corresponding information set out in Annex 1 of this Agreement.

11.3.5. To the extent that either party terminates the Agreement in accordance with Clause 16(c) of the Controller SCCs, then for the purposes of Clause 16(d) of the Controller SCCs, The data exporter directs the data importer to delete Controller Personal Data, and, unless Applicable Data Protection Legislation requires storage, data importer will facilitate such deletion as soon as is reasonably practicable, to the extent such deletion is reasonably possible (taking into account that each party is an independent Controller of such data, as well as the nature and functionality of the dApp Store).

11.3.6. If Controller SCCs have been entered into, Clause 12 of the Controller SCCs will not affect Section 14 (Limitation of Liability) of the Agreement.

11.3.7. Nothing in the Agreement is intended to modify or contradict the Controller SCCs or affect the fundamental rights or freedoms of data subjects under Applicable Data Protection Legislation.

12\. Independent Development. Developer understands that Solana Mobile is in the business of developing and commercializing devices, software, products, materials and services and that Solana Mobile may be developing, and may develop in the future, software programs or other products, programs, materials or services which are similar to, and may otherwise compete with, Developer materials. In addition, Solana Mobile may work with other software developers (whether through the dApp Store or otherwise) whose products, programs, materials or services compete, or will compete with, Developer materials. Nothing in the terms of this Agreement or otherwise with respect to the dApp Store, shall limit or restrict Solana Mobile’s right to develop, license, commercialize, distribute, market or otherwise exploit products, programs, services or materials that are the same as, similar to, or compete with Developer Applications. Developer further understands and agrees that Solana Mobile will have no confidentiality obligations or restrictions whatsoever regarding any information that Developer provides to Solana Mobile, either directly or indirectly, in connection with Developer materials, Developer’s business or otherwise. Accordingly, Developer should not disclose anything to any Solana Mobile Parties that Developer desires to keep confidential.

13\. Disclaimer. THE SOLANA MOBILE PARTIES MAKE NO (AND HEREBY DISCLAIM ALL) REPRESENTATIONS, WARRANTIES, OR CONDITIONS WITH RESPECT TO ANY OF THE MATTERS CONTEMPLATED BY THIS AGREEMENT, WHETHER WRITTEN, ORAL, EXPRESS, IMPLIED, OR STATUTORY THE SOLANA MOBILE PROPERTIES ARE PROVIDED FOR USE AT DEVELOPER’S OWN RISK AND “AS IS,” “WITH ALL FAULTS,” AND WITHOUT WARRANTY OF ANY KIND. TO THE MAXIMUM EXTENT PERMITTED BY APPLICABLE LAWS, THE SOLANA MOBILE PARTIES HEREBY DISCLAIM ALL WARRANTIES OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, WARRANTIES OF NON-INFRINGEMENT, OR OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, AND ANY WARRANTIES ARISING BY STATUTE OR OTHERWISE IN LAW, EQUITY, OR FROM A COURSE OF DEALING OR USAGE OF TRADE. THE SOLANA MOBILE PARTIES SPECIFICALLY DO NOT WARRANT THAT SOLANA MOBILE PROPERTIES WILL MEET DEVELOPER’S REQUIREMENTS; WILL OPERATE IN ALL THE COMBINATIONS WHICH MAY BE SELECTED FOR USE BY YOU; THAT THE OPERATION OR OUTPUT OF THE SOLANA MOBILE PROPERTIES WILL BE ERROR-FREE, ACCURATE, RELIABLE, COMPLETE OR UNINTERRUPTED; THAT ANY OR ALL ERRORS OR DEFECTS IN THE SOLANA MOBILE PROPERTIES WILL BE CORRECTED; OR THAT ANY SOLANA MOBILE PROPERTY (INCLUDING, WITHOUT LIMITATION, THE DAPP STORE) IS APPROPRIATE OR AVAILABLE FOR USE IN ANY PARTICULAR JURISDICTION. DEVELOPER USES THE SOLANA MOBILE PROPERTIES AT ITS OWN RISK. SOLANA MOBILE HAS THE RIGHT, IN ITS SOLE DISCRETION, TO MAKE CHANGES TO, SUSPEND, OR DISCONTINUE ANY SOLANA MOBILE PROPERTIES (OR ANY PORTION THEREOF) AT ANY TIME. DEVELOPER FURTHER ACKNOWLEDGES THAT THE SOLANA MOBILE PARTIES SHALL HAVE NO OBLIGATION WHATSOEVER TO RELEASE OR OTHERWISE MAKE GENERALLY AVAILABLE, ANY SOLANA MOBILE PROPERTIES. The Solana Mobile Parties are not responsible for any losses or harms sustained by you due to vulnerability or any kind of failure, abnormal behavior of software (e.g., smart contract), blockchains, or any other features of or inherent to the Solana Network. The Solana Mobile Parties are not responsible for any delay or failure to report any issues with the Solana Network, including without limitation forks, technical node issues, or any other issues that result in losses of any sort.

14\. Limitation of Liability. UNDER NO CIRCUMSTANCES WILL THE SOLANA MOBILE PARTIES BE LIABLE FOR ANY CLAIM FOR ANY DIRECT, INDIRECT, SPECIAL, CONSEQUENTIAL, INCIDENTAL, PUNITIVE, EXEMPLARY DAMAGES, OR ANY OTHER DAMAGES WHATSOEVER (INCLUDING BUT NOT LIMITED TO, LOSS OF PROFITS, LOSS OF REVENUE, LOSS OF USE, LOSS OF DATA, BUSINESS INTERRUPTION OR ANY OTHER COMMERCIAL OR ECONOMIC LOSS OF ANY KIND), NOR SHALL THE SOLANA MOBILE PARTIES BE LIABLE FOR ANY DAMAGES WHATSOEVER ARISING FROM OR RELATING TO DEVELOPER’S USE OR INABILITY TO USE ANY SOLANA MOBILE PROPERTIES OR RESULTING FROM A FORCE MAJEURE EVENT, AN ACT OF A THIRD PARTY OR OF NO FAULT ON ITS BEHALF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF AND REGARDLESS OF WHETHER THE LIMITED REMEDIES IN THIS AGREEMENT FAIL OF THEIR ESSENTIAL PURPOSE. DEVELOPER’S SOLE AND EXCLUSIVE REMEDY FOR ANY CLAIM UNDER THIS AGREEMENT, WHETHER BASED ON CONTRACT, WARRANTY, NEGLIGENCE, TORT, OR OTHERWISE, IS TO CEASE USE OF THE SOLANA MOBILE PROPERTIES

15\. ​Indemnification. To the fullest extent permitted by Applicable Law, Developer agrees to indemnify, defend, and hold harmless Solana Mobile and the Solana Mobile Parties from and against all actual or alleged third party claims, damages, awards, judgments, losses, liabilities, obligations, penalties, interest, fees, expenses (including, without limitation, attorneys’ fees and expenses) and costs (including, without limitation, court costs, costs of settlement, and costs of or associated with pursuing indemnification and insurance), of every kind and nature whatsoever arising out of or related to this Agreement or your use of the dApp Publishing Platform, whether known or unknown, foreseen or unforeseen, matured or unmatured, or suspected or unsuspected, in law or equity, whether in tort, contract or otherwise (collectively, “ **Claims**”), including, but not limited to, damages to property or personal injury, that are caused by, arise out of or are related to (a) any Developer Assets, (b) Developer’s use of any Solana Mobile Properties, (c) Developer’s obligations under Section 5, (d) any breach of any EULA between Developer and any End User; and (e) any breach of this Agreement. Developer agrees to promptly notify Solana Mobile of any third-party Claims and cooperate with the Solana Mobile Parties in defending such Claims. Developer further agrees that the Solana Mobile Parties shall have control of the defense or settlement of any third-party Claims.

16\. Disputes. Please read this Arbitration Agreement (the “ **Arbitration Agreement**”) carefully. IT IS PART OF YOUR CONTRACT WITH SOLANA MOBILE AND AFFECTS YOUR RIGHTS. IT CONTAINS PROCEDURES FOR MANDATORY BINDING ARBITRATION AND A CLASS ACTION WAIVER (INCLUDING WITHOUT LIMITATION INVOLVING ANY DISPUTE WITH THE SOLANA MOBILE PARTIES).

16.1. **Applicability of Arbitration Agreement**. Subject to the terms of this Arbitration Agreement, and to the extent that it is not unenforceable, unlawful or unfair under applicable laws, you and Solana Mobile (including on behalf of the Solana Mobile Parties) agree that any dispute, claim, disagreements arising out of or relating in any way to this Agreement and prior versions of this Agreement, including claims and disputes that arose between us before the effective date of this Agreement (each, a “ **Dispute**”) will be resolved by binding arbitration, rather than in court, except that: (i) you and the Solana Mobile Parties may assert claims or seek relief in small claims court if such claims qualify and remain in small claims court; and (ii) you or the Solana Mobile Parties may seek equitable relief in court for infringement or other misuse of intellectual property rights (such as trademarks, trade dress, domain names, trade secrets, copyrights, and patents). For purposes of this Arbitration Agreement, “Dispute” will also include disputes that arose or involve facts occurring before the existence of this or any prior versions of this Agreement as well as claims that may arise after the termination of this Agreement.

16.2. **Informal Dispute Resolution**. There might be instances when a Dispute arises between you and a Solana Mobile Party. If that occurs, Solana Mobile states (including on behalf of the Solana Mobile Parties) that the applicable Solana Mobile Party is committed to working with you to reach a reasonable resolution. Solana Mobile (including on behalf of the Solana Mobile Parties) and You agree that good faith informal efforts to resolve Disputes can result in a prompt, low‐cost and mutually beneficial outcome. Solana Mobile (including on behalf of the Solana Mobile Parties) and You therefore agree that, to the extent that it is not unenforceable, unlawful or unfair under applicable laws, before a party commences arbitration against the other (or initiates an action in small claims court if a party so elects), the parties will personally meet and confer telephonically or via videoconference, in a good faith effort to resolve informally any Dispute covered by this Arbitration Agreement (“ **Informal Dispute Resolution Conference**”); provided, however, that any Solana Mobile Party may waive the requirement to engage in an Informal Dispute Resolution Conference and failure to schedule an Informal Dispute Resolution Conference within the 45 day period set forth below shall be deemed such a waiver. If you are represented by counsel, your counsel may participate in the conference, but you will also participate in the conference. The party initiating a Dispute must give notice to the other party in writing of its intent to initiate an Informal Dispute Resolution Conference (“ **Notice**”), which shall occur within 45 days after the other party receives such Notice, unless an extension is mutually agreed upon by the parties. Notice to any Solana Mobile Party that you intend to initiate an Informal Dispute Resolution Conference should be sent by email or regular mail to our offices located at the address set forth below. The Notice must include: (i) your name, telephone number, mailing address, and/or e‐mail address; (ii) the name, telephone number, mailing address and e‐ mail address of your counsel, if any; and (iii) a description of your Dispute. The Informal Dispute Resolution Conference shall be individualized such that a separate conference must be held each time either party initiates a Dispute, even if the same law firm or group of law firms represents multiple users in similar cases, unless all parties agree; multiple individuals initiating a Dispute cannot participate in the same Informal Dispute Resolution Conference unless all parties agree. In the time between a party receiving the Notice and the Informal Dispute Resolution Conference, nothing in this Arbitration Agreement shall prohibit the parties from engaging in informal communications to resolve the initiating party’s Dispute. Engaging in the Informal Dispute Resolution Conference is a condition precedent and requirement that must be fulfilled before commencing arbitration. The statute of limitations and any filing fee deadlines shall be tolled while the parties engage in the Informal Dispute Resolution Conference process required by this section.

16.3. **Waiver of Jury Trial**. TO THE EXTENT THAT IT IS NOT UNENFORCEABLE, UNLAWFUL OR UNFAIR UNDER APPLICABLE LAWS, THE SOLANA MOBILE PARTIES AND YOU HEREBY WAIVE ANY CONSTITUTIONAL AND STATUTORY RIGHTS TO SUE IN COURT AND HAVE A TRIAL IN FRONT OF A JUDGE OR A JURY. You and the Solana Mobile Parties are instead electing that all Disputes shall be resolved by arbitration under this Arbitration Agreement, except as specified in Section 16.1. There is no judge or jury in arbitration, and court review of an arbitration award is subject to very limited review. For the avoidance of doubt, to the extent any action is heard in court for any reason, you and the Solana Mobile Parties will still not be entitled to a jury.

16.4. **Waiver of Class and Other Non-Individualized Relief**. TO THE EXTENT THAT IT IS NOT UNENFORCEABLE, UNLAWFUL OR UNFAIR UNDER APPLICABLE LAWS, AND EXCEPT AS SPECIFIED IN SECTION 16.9, THE SOLANA MOBILE PARTIES AND YOU MAY BRING CLAIMS AGAINST THE OTHER ONLY ON AN INDIVIDUAL BASIS AND NOT ON A CLASS, REPRESENTATIVE, OR COLLECTIVE BASIS, AND THE SOLANA MOBILE PARTIES AND YOU HEREBY WAIVE ALL RIGHTS TO HAVE ANY DISPUTE BE BROUGHT, HEARD, ADMINISTERED, RESOLVED, OR ARBITRATED ON A CLASS, COLLECTIVE, REPRESENTATIVE, OR MASS ACTION BASIS IN ANY ARBITRAL, COURT, OR OTHER FORUM. EXCEPT AS SPECIFIED IN SECTION 16.9, ONLY INDIVIDUAL RELIEF IS AVAILABLE, AND DISPUTES OF MORE THAN ONE CUSTOMER OR USER CANNOT BE ARBITRATED OR CONSOLIDATED WITH THOSE OF ANY OTHER CUSTOMER OR USER. Subject to this Arbitration Agreement, the arbitrator may award declaratory or injunctive relief only in favor of the individual party seeking relief and only to the extent necessary to provide relief warranted by the party’s individual claim. Nothing in this paragraph is intended to, nor shall it, affect the terms and conditions under Section 16.9. Notwithstanding anything to the contrary in this Arbitration Agreement, if a court decides by means of a final decision, not subject to any further appeal or recourse, that the limitations of this section are invalid or unenforceable as to a particular claim or request for relief (such as a request for public injunctive relief), that particular claim or request for relief (and only that particular claim or request for relief) shall be severed from the arbitration and may be litigated on an individual basis in the state or federal courts located in the State of New York. All other Disputes shall be arbitrated or litigated in small claims court. This section does not prevent you or a Solana Mobile Party from participating in a class-wide settlement of claims.

16.5. **Rules and Forum**. This Agreement evidences a transaction involving interstate commerce; and notwithstanding any other provision herein with respect to the applicable substantive law, the Federal Arbitration Act, 9 U.S.C. § 1 et seq., will govern the interpretation and enforcement of this Arbitration Agreement and any arbitration proceedings. If the Informal Dispute Resolution Conference process described above does not resolve satisfactorily within sixty (60) days after receipt of your Notice, the Solana Mobile Party and You, as applicable, shall have the right to finally resolve the Dispute through binding arbitration. The arbitration will be administered by the American Arbitration Association (“ **AAA**”), in accordance with the Consumer Arbitration Rules (the “ **AAA Rules**”) then in effect, except as modified by this section of this Arbitration Agreement. The AAA Rules are currently available at [https://www.adr.org/media/yawntdvs/2025\_consumer\_arbitration\_rules.pdf](https://www.adr.org/media/yawntdvs/2025_consumer_arbitration_rules.pdf). A party who wishes to initiate arbitration must provide the other party with a request for arbitration (the “ **Request**”). The Request must include: (i) the name, telephone number, mailing address, email address of the party seeking arbitration (if applicable) as well as your email address; (ii) a statement of the legal claims being asserted and the factual bases of those claims; (iii) a description of the remedy sought and an accurate, good-faith calculation of the amount in controversy in United States Dollars; (iv) a statement certifying completion of the Informal Dispute Resolution Conference process as described above; and (v) evidence that the requesting party has paid any necessary filing fees in connection with such arbitration. If the party requesting arbitration is represented by counsel, the Request shall also include counsel’s name, telephone number, mailing address, and email address. Such counsel must also sign the Request. By signing the Request, counsel certifies to the best of counsel’s knowledge, information, and belief, formed after an inquiry reasonable under the circumstances, that: (a) the Request is not being presented for any improper purpose, such as to harass, cause unnecessary delay, or needlessly increase the cost of dispute resolution; (b) the claims, defenses and other legal contentions are warranted by existing law or by a nonfrivolous argument for extending, modifying, or reversing existing law or for establishing new law; and (c) the factual and damages contentions have evidentiary support or, if specifically so identified, will likely have evidentiary support after a reasonable opportunity for further investigation or discovery. Unless you and the applicable Solana Mobile Party otherwise agree, or the Batch Arbitration process discussed in Section 16.9 is triggered, the arbitration will be conducted in the county where you reside. Subject to the AAA Rules, the arbitrator may direct a limited and reasonable exchange of information between the parties, consistent with the expedited nature of the arbitration. If the AAA is not available to arbitrate, the parties will select an alternative arbitral forum. Your responsibility to pay any AAA fees and costs will be solely as set forth in the applicable AAA Rules. All materials and documents exchanged during the arbitration proceedings shall be kept confidential and shall not be shared with anyone except the parties’ attorneys, accountants, or business advisors, and then subject to the condition that they agree to keep all materials and documents exchanged during the arbitration proceedings confidential.

16.6. **Arbitrator**. The arbitrator will be either a retired judge or an attorney licensed to practice law in the state of New York and will be selected by the parties from the AAA’s roster of consumer dispute arbitrators. If the parties are unable to agree upon an arbitrator within thirty-five (35) days of delivery of the Request, then the AAA will appoint the arbitrator in accordance with the AAA Rules, provided that if the Batch Arbitration process under Section 16.9 is triggered, the AAA will appoint the arbitrator for each batch.

16.7. **Authority of Arbitrator**. To the extent that it is not unenforceable, unlawful or unfair under applicable laws, the arbitrator shall have exclusive authority to resolve any Dispute, including, without limitation, disputes arising out of or related to the interpretation or application of the Arbitration Agreement, including the enforceability, revocability, scope, or validity of the Arbitration Agreement or any portion of the Arbitration Agreement, except for the following: (i) all Disputes arising out of or relating to Section 16.4 including any claim that all or part of Section 16.4 is unenforceable, illegal, void or voidable, or that Section 16.4 has been breached, shall be decided by a court of competent jurisdiction and not by an arbitrator; (ii) except as expressly contemplated in Section 16.9, all Disputes about the payment of arbitration fees shall be decided only by a court of competent jurisdiction and not by an arbitrator; (iii) all Disputes about whether either party has satisfied any condition precedent to arbitration shall be decided only by a court of competent jurisdiction and not by an arbitrator; and (iv) all Disputes about which version of the Arbitration Agreement applies shall be decided only by a court of competent jurisdiction and not by an arbitrator. The arbitration proceeding will not be consolidated with any other matters or joined with any other cases or parties, except as expressly provided in Section 16.9. The arbitrator shall have the authority to grant motions dispositive of all or part of any Dispute. The arbitrator shall issue a written award and statement of decision describing the essential findings and conclusions on which the award is based, including the calculation of any damages awarded. The award of the arbitrator is final and binding upon you and us. Judgment on the arbitration award may be entered in any court having jurisdiction.

16.8. **Attorneys’ Fees and Costs**. The parties shall bear their own attorneys’ fees and costs in arbitration unless the arbitrator finds that either the substance of the Dispute or the relief sought in the Request was frivolous or was brought for an improper purpose (as measured by the standards set forth in Federal Rule of Civil Procedure 11(b)). If you or a Solana Mobile Party need to invoke the authority of a court of competent jurisdiction to compel arbitration, then the party that obtains an order compelling arbitration in such action shall have the right to collect from the other party its reasonable costs, necessary disbursements, and reasonable attorneys’ fees incurred in securing an order compelling arbitration. The prevailing party in any court action relating to whether either party has satisfied any condition precedent to arbitration, including the Informal Dispute Resolution Conference process, is entitled to recover their reasonable costs, necessary disbursements, and reasonable attorneys’ fees and costs.

16.9. **Batch Arbitration**. To increase the efficiency of administration and resolution of arbitrations, and to the extent that it is not unenforceable, unlawful or unfair under applicable laws, in the event that there are one hundred (100) or more individual Requests or other demand of a substantially similar nature filed against any Solana Mobile Party collectively by or with the assistance of the same law firm, group of law firms, or organizations, within a thirty (30) day period (or as soon as possible thereafter), the AAA shall (i) administer the arbitration demands in batches of 100 Requests per batch (plus, to the extent there are less than 100 Requests left over after the batching described above, a final batch consisting of the remaining Requests); (ii) appoint one arbitrator for each batch; and (iii) provide for the resolution of each batch as a single consolidated arbitration with one set of filing and administrative fees due per side per batch, one procedural calendar, one hearing (if any) in a place to be determined by the arbitrator, and one final award (“ **Batch Arbitration**”). All parties agree that Requests are of a “substantially similar nature” if they arise out of or relate to the same event or factual scenario and raise the same or similar legal issues and seek the same or similar relief. To the extent the parties disagree on the application of the Batch Arbitration process, the disagreeing party shall advise the AAA, and the AAA shall appoint a sole standing arbitrator to determine the applicability of the Batch Arbitration process (“ **Administrative Arbitrator**”). In an effort to expedite resolution of any such dispute by the Administrative Arbitrator, the parties agree the Administrative Arbitrator may set forth such procedures as are necessary to resolve any disputes promptly. The Administrative Arbitrator’s fees shall be paid by the Solana Mobile Parties. You and Solana Mobile (including on behalf of the Solana Mobile Parties) agree to cooperate in good faith with the AAA to implement the Batch Arbitration process including the payment of single filing and administrative fees for batches of Requests, as well as any steps to minimize the time and costs of arbitration, which may include: (a) the appointment of a discovery special master to assist the arbitrator in the resolution of discovery disputes; and (b) the adoption of an expedited calendar of the arbitration proceedings. This Batch Arbitration provision shall in no way be interpreted as authorizing a class, collective and/or mass arbitration or action of any kind, or arbitration involving joint or consolidated claims under any circumstances, except as expressly set forth in this provision.

16.10. **30-Day Right to Opt Out**. You have the right to opt out of the provisions of this Arbitration Agreement by sending written notice of your decision to opt out to the contact information set forth below, within thirty (30) days after first becoming subject to this Arbitration Agreement. Your notice must include your name and address, and/or your email address, and an unequivocal statement that you want to opt out of this Arbitration Agreement. If you opt out of this Arbitration Agreement, all other parts of this Agreement will continue to apply to you. Opting out of this Arbitration Agreement has no effect on any other arbitration agreements that you may currently have, or may enter in the future, with us.

16.11. **Invalidity, Expiration**. Except as provided Section 16.4, if any part or parts of this Arbitration Agreement are found under the law to be unfair, unlawful, invalid or unenforceable, then such specific part or parts shall be of no force and effect and shall be severed and the remainder of the Arbitration Agreement shall continue in full force and effect. To the fullest extent permitted by applicable law, you and the Solana Mobile Parties further agree that any Dispute must be initiated via arbitration within one-year after the cause of action accrues; otherwise, such cause of action is forever time barred.

16.12. **Modification**. Notwithstanding any provision in this Agreement to the contrary, we agree that if Solana Mobile makes any future material change to this Arbitration Agreement, it will notify you. Unless you reject the change within thirty (30) days of such change become effective by writing to Solana Mobile at the contact information set forth below, your continued use of the dApp Publishing Platform following the posting of changes to this Arbitration Agreement constitutes your acceptance of any such changes. To the extent that it is not unenforceable, unlawful or unfair under applicable laws, changes to this Arbitration Agreement do not provide you with a new opportunity to opt out of the Arbitration Agreement if you have previously agreed to a version of this Agreement and did not validly opt out of arbitration. If you reject any change or update to this Arbitration Agreement, and you were bound by an existing agreement to arbitrate Disputes arising out of or relating in any way to your access to or use of the dApp Publishing Platform, any communications you receive, or this Agreement, the provisions of this Arbitration Agreement as of the date you first accepted this Agreement (or accepted any subsequent changes to this Agreement) remain in full force and effect. The Solana Mobile Parties will continue to honor any valid opt outs of the Arbitration Agreement that you made to a prior version of this Agreement.

16.13. **Confidentiality**. All aspects of the arbitration proceeding, including but not limited to the award of the arbitrator and compliance therewith, shall be strictly confidential. The parties agree to maintain confidentiality unless otherwise required by law. This paragraph shall not prevent a party from submitting to a court of law any information necessary to enforce this Agreement, to enforce an arbitration award, or to seek injunctive or equitable relief.

16.14. **Survival of Agreement**. This Arbitration Agreement will survive the termination of your relationship with Solana Mobile.

17\. General Provisions

17.1. **Notices**. All notices hereunder shall be made as follows:

17.1.1. If to Developer: by email to the email address Developer provided to Solana Mobile when Developer registered for an account on the dApp Publishing Platform, or another address as subsequently designated by Developer according to the notice provisions hereof.

17.1.2. If to Solana Mobile: [legal@solanamobile.com](mailto:legal@solanamobile.com), or another address as subsequently designated by Solana Mobile according to the provisions hereof. Notices will be effective one (1) day after sending to the above email address(es).

17.2. **Relationship of the Parties**. Developer and Solana Mobile are independent contractors, and nothing in this Agreement is intended to, or should be construed to, create a partnership, agency, joint venture or employment relationship between the parties. Neither party is or shall represent itself as an agent, legal representative, employee, or partner of the other party.

17.3. **No Waiver**. If one party does not enforce a legal right or remedy available to it under this Agreement or Applicable Laws, that failure will not be considered a waiver of its right to enforce those rights or remedies in the future.

17.4. **Injunctive Relief**. Developer’s obligations under this Agreement are of a unique character that gives them particular value; breach of any of such obligations will result in irreparable and continuing damage to Solana Mobile for which there will be no adequate remedy at law; and, in the event of such breach, Developer agrees that Solana Mobile will be entitled to injunctive relief without the need to prove irreparable harm or the posting of any bond, and such other and further relief as may be proper (including monetary damages if appropriate).

17.5. **Assignment**. The Agreement, and your rights and obligations hereunder, may not be assigned, subcontracted, delegated or otherwise transferred by you, in whole or in part, by operation of law or otherwise, without Solana Mobile’s prior written consent, and any attempted assignment, subcontract, delegation, or transfer in violation of the foregoing will be null and void. Solana Mobile may assign, subcontract, delegate, or otherwise transfer any rights and obligations it may have without any notice to or consent by You.

17.6. **Exclusive Venue.** To the extent litigation in a court is permitted under the terms of this Agreement, and subject to Section 16, all such claims and disputes arising out of or relating to the Agreement will be litigated exclusively in the courts of New York, New York.

17.7. **Governing Law**. SUBJECT TO SECTION 16 (DISPUTES), THESE TERMS OF USE AND ANY ACTION RELATED HERETO WILL BE GOVERNED BY THE LAWS OF THE STATE OF DELAWARE, WITHOUT GIVING EFFECT TO ANY PRINCIPLES THAT PROVIDE FOR THE APPLICATION OF THE LAW OF ANOTHER JURISDICTION.

17.8. **Equal Interpretation**. To the fullest extent permitted by applicable law, each of you and Solana Mobile agree that rules relating to the interpretation of contracts against the drafter of any particular clause shall not apply in the case of this Agreement.

17.9. **Severability**. To the fullest extent permitted by applicable law, if any portion of this Agreement is held invalid or unenforceable, that portion shall be construed in a manner to reflect, as nearly as possible, the original intention of the parties, and the remaining portions shall remain in full force and effect.

17.10. **Third-party beneficiaries**. Except for the Solana Mobile Parties, there are no third-party beneficiaries to this Agreement.

17.11. **Government Rights**. Solana Mobile provides the dApp Publishing Platform, including any related software, data, and technology, for ultimate government end use solely in accordance with the following: The dApp Publishing Platform shall constitute “commercial” computer software. Government technical data and software rights related to the dApp Publishing Platform include only those rights customarily provided to the public as defined in the Agreement. These customary commercial licenses are provided in accordance with FAR 12.211 (Technical Data) and FAR 12.212 (Customer-Side Application) and, for Department of Defense transactions, DFAR 252.227-7015 (Technical Data – Commercial Items) and DFAR 227.7202-3 (Rights in Commercial Computer Customer-Side Application or Computer Customer-Side Application Documentation). If a government agency has a need for rights not granted under these terms, it must negotiate with Solana Mobile to determine if there are acceptable terms for granting those rights, and a mutually acceptable written addendum specifically granting those rights must be included in any applicable agreement.

17.12. **Export Regulations**. Developer is responsible for ensuring that its provision of Developer Assets to Solana Mobile and its offer of Developer Applications to its End Users on or through the dApp Store as contemplated by this Agreement does not and will not violate the Export Administration Regulations of the United States Department of Commerce or any other applicable U.S. government regulation regarding the export or re-export of United States source technical information as well as similar trade and export laws and regulations of Developer’s country.

17.13. **Force Majeure**. Any delay in the performance of any duties or obligations of either party will not be considered a breach of this Agreement if such delay is caused by a labor dispute, shortage of materials, fire, earthquake, flood, epidemic, pandemic, or any other event beyond the control of such party, provided that such party uses reasonable efforts, under the circumstances, to notify the other party of the cause of such delay and to resume performance as soon as possible.

17.14. **No Publicity**. Developer shall not make any public statement, press release, or other announcement relating to any Solana Mobile Properties (including, without limitation, the dApp Store) or this Agreement without the prior written approval of Solana Mobile, except as required by law.

17.15. **Entire Agreement**. Except as otherwise supplemented and amended, as provided in the introduction hereto, all terms, conditions and provisions of this Agreement shall remain in full force and effect. This Agreement, together with the Product Guidelines and any exhibits, which are incorporated by reference into the Agreement, contains the entire agreement between Developer and Solana Mobile with respect to the subject matter hereof and supersedes all prior or contemporaneous communications and proposals, whether electronic, oral or written, between Developer and Solana Mobile. Each party acknowledges and agrees that (a) it is a sophisticated party that has independently evaluated and verified the terms of this Agreement, (b) it has not relied upon any representation or warranty, express or implied, not expressly set forth in this Agreement, and (c) no party shall have any liability to the other with respect to any extra-contractual statements, representations, or warranties, whether oral or written. Each party further acknowledges that it has had the opportunity to consult with counsel regarding this Agreement.

**Annex 1**

**Data Processing Details**

**PART 1: DETAILS OF THE PARTIES**

**SOLANA MOBILE / ‘DATA IMPORTER’ DETAILS**

| Name: | As set out in the Agreement |
| --- | --- |
| **Address:** | As set out in the Agreement |
| **Activities:** | Provision of dApp Store |
| **Key Contact:** | As communicated in writing to Developer from time to time |

**DEVELOPER / ‘DATA EXPORTER’ DETAILS**

| Name: | As set out in the Agreement |
| --- | --- |
| **Address:** | As set out in the Agreement |
| **Activities:** | Provision of Developer Application |
| **Key Contact:** | As communicated in writing to Solana Mobile from time to time |

**PART 2: EXAI/DETAILS OF PROCESSING**

| Categories of Data Subjects: | Relevant data subjects include End Users |
| --- | --- |
| **Categories of** **Personal Data:** | Relevant personal data includes personal data provided to the data importer via the dApp Store services by (or at the direction of) the data exporter or as otherwise described in the Agreement. |
| **Special Categories of Personal Data and criminal convictions and offences** | n/a |
| **Subject matter and nature of the Processing:** | Processing operations required in order to carry out the parties’ obligations in accordance with the Agreement |
| **Nature and purpose of the Processing:** | Personal data will be processed as necessary to carry out the parties’ obligations in accordance with the Agreement |
| **Duration of Processing / Retention Period:** | For the period determined in accordance with the Agreement |

**PART 3: TECHNICAL AND ORGANISATIONAL MEASURES**

Taking into account the state of the art, the costs of implementation and the nature, scope, context and purposes of processing as well as the risk of varying likelihood and severity for the rights and freedoms of natural persons, Solana Mobile shall implement appropriate technical and organisational measures to ensure a level of security appropriate to the risk, including inter alia as appropriate:

(a) the pseudonymisation and encryption of personal data;

(b) the ability to ensure the ongoing confidentiality, integrity, availability and resilience of processing systems and services;

(c) the ability to restore the availability and access to personal data in a timely manner in the event of a physical or technical incident;

(d) a process for regularly testing, assessing and evaluating the effectiveness of technical and organisational measures for ensuring the security of the processing.

**PART 4: COMPETENT SUPERVISORY AUTHORITY**

The competent Supervisory Authority shall be determined as follows:

(a) where Developer is established in an EU Member State: the competent supervisory authority shall be the supervisory authority of that EU Member State in which Developer is established;

(b) where Developer is not established in an EU Member State, Article 3(2) of the GDPR applies and Developer has appointed an EEA Representative under Article 27 of the GDPR: the competent supervisory authority shall be the supervisory authority of the EU Member State in which Developer’s EEA Representative relevant to the processing hereunder is based (from time-to-time), which Developer shall notify to Solana Mobile in writing.

## Metaplex SDK Integration
[Skip to main content](https://docs.solanamobile.com/react-native/metaplex_integration#__docusaurus_skipToContent_fallback)

On this page

[**Metaplex**](https://docs.metaplex.com/) provides a collection of on-chain tools/programs for creating and managing NFTs on Solana. In addition, Metaplex provides multiple [Client SDKs](https://docs.metaplex.com/sdks/) that makes it easier for developers to interact and use their on chain programs.

This guide will focus on integrating with the [Metaplex JS SDK](https://docs.metaplex.com/sdks/js/) in a React Native app with Mobile Wallet Adapter.

[Example App Repo](https://github.com/solana-mobile/tutorial-apps/tree/main/MobileNFTMinter)

## Installation [​](https://docs.solanamobile.com/react-native/metaplex_integration\#installation "Direct link to Installation")

Install the Metaplex JS package to your project.

- yarn
- npm

```shell
yarn add @metaplex-foundation/js
```

```shell
npm install @metaplex-foundation/js
```

### Polyfill installation [​](https://docs.solanamobile.com/react-native/metaplex_integration\#polyfill-installation "Direct link to Polyfill installation")

The Metaplex JS SDK was originally written for a Browser/Node environment, so certain dependencies aren't immediately available on React Native. These polyfill libraries will fill in the missing libraries and enable React Native compatibility.

#### 1\. Install polyfills [​](https://docs.solanamobile.com/react-native/metaplex_integration\#1-install-polyfills "Direct link to 1. Install polyfills")

```shell
yarn add \
    assert \
    crypto-browserify \
    readable-stream \
    zlib \
    react-native-url-polyfill
```

#### 2\. Add polyfills to resolver in metro.config.js [​](https://docs.solanamobile.com/react-native/metaplex_integration\#2-add-polyfills-to-resolver-in-metroconfigjs "Direct link to 2. Add polyfills to resolver in metro.config.js")

Adding the `resolver` property lets the Metro know which packages to substitute with when seeing a `require`.

```js
module.exports = {
  resolver: {
    extraNodeModules: {
      crypto: require.resolve('crypto-browserify'),
      stream: require.resolve('readable-stream'),
      zlib: require.resolve('browserify-zlib'),
      path: require.resolve('path-browserify'),
      url: require.resolve('react-native-url-polyfill'),
    },
  },
  transformer: {
    getTransformOptions: async () => ({
      transform: {
        experimentalImportSupport: false,
        inlineRequires: true,
      },
    }),
  },
};
```

#### 3\. Add imports to index.js [​](https://docs.solanamobile.com/react-native/metaplex_integration\#3-add-imports-to-indexjs "Direct link to 3. Add imports to index.js")

```tsx
import 'react-native-url-polyfill/auto'; // Add this before the 'App' import!

import {AppRegistry} from 'react-native';
import App from './App';
import {name as appName} from './app.json';

AppRegistry.registerComponent(appName, () => App);
```

## Usage [​](https://docs.solanamobile.com/react-native/metaplex_integration\#usage "Direct link to Usage")

### Creating a Metaplex Instance [​](https://docs.solanamobile.com/react-native/metaplex_integration\#creating-a-metaplex-instance "Direct link to Creating a Metaplex Instance")

The entry point to the JavaScript SDK is a `Metaplex` instance that will give you access to its API. It provides a convenient API to interact with on-chain programs, simplifying actions like minting an NFT.

It accepts a `Connection` instance from `@solana/web3.js` that will be used to communicate with the cluster.

```tsx
import {Metaplex} from '@metaplex-foundation/js';
import {Connection} from '@solana/web3.js';

const metaplex = Metaplex.make(connection);
```

### Using MWA as an Identity Driver [​](https://docs.solanamobile.com/react-native/metaplex_integration\#using-mwa-as-an-identity-driver "Direct link to Using MWA as an Identity Driver")

Metaplex also allows you to further customize who the SDK should interact on behalf of, by providing an "Identity Driver". You can use the Mobile Wallet Adapter methods to implement an Identity Driver. With this provided, Metaplex SDK can request signing for transactions/messages when needed.

#### Create an MWA Identity Signer: [​](https://docs.solanamobile.com/react-native/metaplex_integration\#create-an-mwa-identity-signer "Direct link to Create an MWA Identity Signer:")

```tsx
import {IdentitySigner, Metaplex} from '@metaplex-foundation/js';
import {
  transact,
  Web3MobileWallet,
} from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';
import {Connection, Transaction} from '@solana/web3.js';

const mwaIdentitySigner: IdentitySigner = {
    publicKey: signersPublicKey,
    signMessage: async (message: Uint8Array): Promise<Uint8Array> => {
        return await transact(async (wallet: Web3MobileWallet) => {
            const authResult = await wallet.authorize({
                cluster: RPC_ENDPOINT,
                identity: APP_IDENTITY,
            });

            // Optionally, double check authResult returns the matching account to 'signersPublicKey'

            const signedMessages = await wallet.signMessages({
                addresses: [selectedAccount.publicKey.toBase58()],
                payloads: [message],
            });

            return signedMessages[0];
        });
    },
    signTransaction: async (
        transaction: Transaction,
    ): Promise<Transaction> => {
        return await transact(async (wallet: Web3MobileWallet) => {
            const authResult = await wallet.authorize({
                cluster: RPC_ENDPOINT,
                identity: APP_IDENTITY,
             });

            // Optionally, double check authResult returns the matching account to 'signersPublicKey'

            const signedTransactions = await wallet.signTransactions({
                transactions: [transaction],
            });

            return signedTransactions[0];
        });
    },
    signAllTransactions: async (
        transactions: Transaction[],
    ): Promise<Transaction[]> => {
        return transact(async (wallet: Web3MobileWallet) => {
            const authResult = await wallet.authorize({
                cluster: RPC_ENDPOINT,
                identity: APP_IDENTITY,
            })

            // Optionally, double check authResult returns the matching account to 'signersPublicKey'

            const signedTransactions = await wallet.signTransactions({
                transactions: transactions,
            });
            return signedTransactions;
        });
    },
};
```

#### Using the Identity Driver [​](https://docs.solanamobile.com/react-native/metaplex_integration\#using-the-identity-driver "Direct link to Using the Identity Driver")

Then you need to wrap the implemented `IdentitySigner` within a `MetaplexPlugin`. Now you can call the `use` method on the Metaplex instance and supply the identity driver plugin.

The Metaplex instance requires passing in a `MetaplexPlugin`, so you need to first create a plugin that wraps the identity signer. Lastly, you can call the `use` method on the `Metaplex` instance and supply the identity driver plugin.

```tsx
// Create a Metaplex Plugin for the identity driver
const mobileWalletAdapterIdentity = (
  mwaIdentitySigner: IdentitySigner,
): MetaplexPlugin => ({
  install(metaplex: Metaplex) {
    metaplex.identity().setDriver(mwaIdentitySigner);
  },
});

// Finally, create the Metaplex instance with the identity driver.
const metaplex = Metaplex.make(connection).use(
    mobileWalletAdapterIdentity(mwaIdentitySigner),
);
```

### Storage Drivers [​](https://docs.solanamobile.com/react-native/metaplex_integration\#storage-drivers "Direct link to Storage Drivers")

On Browser/Node environments, the SDK also allows you to specify a "Storage Driver" that conveniently integrates various de/centralized storage options (e.g: Bundlr, IPFS, AWS), for uploading media assets and metadata.

**For React Native, the usual storage driver plugins will not work**. Read the note below!

warning

The existing 3rd party storage drivers provided by Metaplex **are not compatible with React Native**, due to reliance on Node libraries! For example, the `bundlrStorage()` and `nftStorage()` plugins will not work and throw an error.

tip

The workaround solution is to manually interact with the storage providers directly, without relying on a prebuilt Metaplex SDK/plugin.
For example, you can upload directly to IPFS using [NFT.storage's REST API](https://nft.storage/api-docs/). You can see an code example of this in the [example app](https://github.com/solana-mobile/tutorial-apps/blob/main/MobileNFTMinter/ipfs/uploadToIPFS.ts#L7).

### Viewing owned NFTs [​](https://docs.solanamobile.com/react-native/metaplex_integration\#viewing-owned-nfts "Direct link to Viewing owned NFTs")

Now with the Metaplex instance, you can access the `nfts()` module that provides easy interaction and signing with onchain programs.

```tsx
const myNfts = await metaplex.nfts().findAllByOwner({
    owner: metaplex.identity().publicKey
});
```

### Minting an NFT [​](https://docs.solanamobile.com/react-native/metaplex_integration\#minting-an-nft "Direct link to Minting an NFT")

For example, to mint an NFT:

```tsx
// Uses the identity driver to request signing from a wallet.
const {nft, response} = await metaplex.nfts().create({
    name: 'NFT Name',
    uri: 'https://someService.com/path/to/metadata/json',
    sellerFeeBasisPoints: 0,
    tokenOwner: signersPublicKey,
});
```

The `nfts()` module provides plenty of other APIs. Look through the Metaplex [docs](https://github.com/metaplex-foundation/js#nfts) for full details.

- [Installation](https://docs.solanamobile.com/react-native/metaplex_integration#installation)
  - [Polyfill installation](https://docs.solanamobile.com/react-native/metaplex_integration#polyfill-installation)
- [Usage](https://docs.solanamobile.com/react-native/metaplex_integration#usage)
  - [Creating a Metaplex Instance](https://docs.solanamobile.com/react-native/metaplex_integration#creating-a-metaplex-instance)
  - [Using MWA as an Identity Driver](https://docs.solanamobile.com/react-native/metaplex_integration#using-mwa-as-an-identity-driver)
  - [Storage Drivers](https://docs.solanamobile.com/react-native/metaplex_integration#storage-drivers)
  - [Viewing owned NFTs](https://docs.solanamobile.com/react-native/metaplex_integration#viewing-owned-nfts)
  - [Minting an NFT](https://docs.solanamobile.com/react-native/metaplex_integration#minting-an-nft)

## Solana Mobile Apps
[Skip to main content](https://docs.solanamobile.com/sample-apps/sample_app_overview#__docusaurus_skipToContent_fallback)

A list of open-source sample apps in different languages/frameworks to help you get started!

- If you're new to using the mobile wallet adapter SDK or looking for a reference point for your own implementation, explore these sample apps.
- By exploring these sample apps, you can get a better understanding of the capabilities of the Mobile Wallet Adapter SDK and how it can be integrated into a project.

AllReact NativeAndroidTesting Apps

## React Native

_![Anchor Counter Program](https://docs.solanamobile.com/sample_app_imgs/anchor_counter_program.png)_

## [Anchor Counter Program](https://github.com/solana-mobile/tutorial-apps/tree/main/AnchorCounterDapp)

Generate an IDL and interact with an on-chain Anchor program.

React NativeAnchor

_![Idle Farming Game](https://docs.solanamobile.com/sample_app_imgs/idle_farming_game.jpg)_

## [Idle Farming Game](https://github.com/solana-mobile/tutorial-apps/tree/main/FarmingIdleGame)

A fully on-chain idle game with a global leaderboard, upgrades, and burner wallet.

ExpoZustandExpo RouterAnchor

_![Mobile NFT Minter](https://docs.solanamobile.com/sample_app_imgs/mobile_nft_minter.png)_

## [Mobile NFT Minter](https://github.com/solana-mobile/tutorial-apps/tree/main/MobileNFTMinter)

Mint photos as NFTs with Metaplex SDK and IPFS hosting.

React NativeMetaplexIPFS

_![Settle](https://docs.solanamobile.com/sample_app_imgs/settle.png)_

## [Settle](https://github.com/solana-mobile/react-native-samples/tree/main/settle)

Expense splitting app settling debts on chain with user to user transactions

React NativeExpoExpress

_![skr-address-resolution](https://docs.solanamobile.com/sample_app_imgs/skr-address-resolution.png)_

## [skr-address-resolution](https://github.com/solana-mobile/react-native-samples/tree/main/skr-address-resolution)

Demo application showcasing bidirectional domain lookup with AllDomains integration

React NativeExpoExpressAllDomains

_![cause-pots](https://docs.solanamobile.com/sample_app_imgs/cause-pots.png)_

## [cause-pots](https://github.com/solana-mobile/react-native-samples/tree/main/cause-pots)

Crypto Pooling app for a common goal, showcasing Anchor smart contract integration

React NativeExpoExpressAnchorRust

## Android

_![Hello World: Android](https://docs.solanamobile.com/sample_app_imgs/hello_world_android.png)_

## [Hello World: Android](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/examples/example-clientlib-ktx-app)

A Kotlin app that writes a message on the blockchain.

Kotlin

_![Hello World: Android (RxJava)](https://docs.solanamobile.com/sample_app_imgs/hello_world_rxjava.png)_

## [Hello World: Android (RxJava)](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/examples/example-clientlib-rxjava-app)

A Kotlin app showcasing MWA with the RxJava library.

KotlinRxJava

_![MintyFresh](https://docs.solanamobile.com/sample_app_imgs/mintyfresh.png)_

## [MintyFresh](https://github.com/solana-mobile/Minty-fresh/tree/main)

A full fledged production dApp. Mint NFTs directly from your phone.

KotlinMetaplexJetpack Compose

## Testing Apps

These are reference apps that also serve as development tools to test MWA integration.

_![fake dapp](https://docs.solanamobile.com/img/solana-mobile-developer-hub-social-card.png)_

## [fake dapp](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/android/fakedapp)

A Kotlin app with UI to simulate MWA methods.

Kotlin

_![fake wallet](https://docs.solanamobile.com/img/solana-mobile-developer-hub-social-card.png)_

## [fake wallet](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/android/fakewallet)

An unsafe, reference Kotlin wallet supporting MWA.

Kotlinwalletlib

_![Example RN wallet](https://docs.solanamobile.com/img/solana-mobile-developer-hub-social-card.png)_

## [Example RN wallet](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/examples/example-react-native-wallet)

An unsafe RN wallet with MWA bottom sheet signing.

React Nativewalletlib

## Solana Mobile Publisher Policy
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/publisher-policy#__docusaurus_skipToContent_fallback)

On this page

This Solana Mobile Publisher Policy (“Publisher Policy”) is part of and subject to the Solana Mobile dApp Store Developer Agreement (“Developer Agreement”). Capitalized words used but not defined herein have the meaning given in the Developer Agreement. By submitting any Developer Asset to Solana Mobile, you acknowledge and agree that such Developer Asset complies with the terms of this Publisher Policy. If you encounter any Developer Asset or other Content in the dApp Store or otherwise via our products and services that does not comply with the terms of this Publisher Policy, you may notify us at [concerns@dappstore.solanamobile.com](mailto:concerns@dappstore.solanamobile.com). We reserve the right, but assume no obligation, to investigate and take any action we deem appropriate.

## Restricted Content [​](https://docs.solanamobile.com/dapp-publishing/publisher-policy\#restricted-content "Direct link to Restricted Content")

Solana Mobile does not allow any Developer Assets, User Content, or text, images, audio content, code, or other content of any sort (“Content”) that Solana Mobile determines in its sole discretion may violate applicable law, rule, or regulation (“Applicable Law”), or the Solana dApp Store mission (“Restricted Content”). Restricted Content includes, without limitation, the following:

- **Illegality:**Content that violates or promotes the violation of Applicable Law, including the following:
  - Content that facilitates or promotes the facilitation of: the consumption of alcohol, tobacco, or other age-restricted products by minors; the purchase or sale of illegal narcotics; or the manufacturing of illegal substances, including narcotics;
  - Content that depicts, promotes, or encourages the abuse or exploitation of children, including all child sexual abuse materials; and
  - Content that depicts, promotes, or encourages activity or behavior that is illegal or restricted under Applicable Law, including (as applicable to your jurisdiction) pornography, prostitution, theft, murder, or other violent or offensive acts.
  - Content that infringes on intellectual property of any third-party.
- **Content Adverse to Community:**Content that is antithetical to our community values, including:
  - Hate speech or speech that threatens, promotes or incites hatred or violence against individuals or groups based on immutable characteristics or other characteristics associated with systemic discrimination;
  - Content that depicts, promotes, advocates for or facilitates gratuitous or real-world violence or other dangerous activity, including any Content that promotes self-harm, suicide, or games where serious injury or death may result;
  - Content that promotes or encourages the promotion of false or misleading health claims or claims that can cause physical harm to users;
  - Pornography, prostitution, other sexually explicit Content; and
  - Content designed to interfere with the proper functions of government, including false election Content (such as “official voting dApps”).
- **Deliberately Misleading Content:**Content that intentionally misleads users or can reasonably be expected to mislead users, e.g.,:
  - Content that falsely claims an affiliation with or endorsement by a third party (government, celebrity, private enterprise, etc.);
  - Content that falsely induces or influences a user to take action with respect to their device, such as encouraging users to modify security settings or features;
  - Content that misleads users as to the true intent, nature, or purpose of any dApp; and
  - Content designed to create, or to enable users to create, ‘deepfakes’ or other false or misleading Content.
  - Content designed to create a likelihood of confusion with a third-party’s entity, brand, products or services.

## Guidelines for User Data [​](https://docs.solanamobile.com/dapp-publishing/publisher-policy\#guidelines-for-user-data "Direct link to Guidelines for User Data")

dApps that collect, access, use, store, or disclose User Content or other information from or about a user, including without limitation device information (“User Data”), must be transparent about the collection and use of such User Data. Without limitation, all dApps on the dApp Store must:

- Disclose the dApp’s or its Developer’s practices with respect to the collection, use, and disclosure of User Data in a privacy policy or other statement that complies with Applicable Law;
- Obligate all third-party services used by or integrated with the dApp that may have access to the applicable User Data to comply with this Publisher Policy;
- Not collect User Data from minors (as determined by Applicable Law) without the consent of a parent or guardian;
- Provide a means or method for users to delete their account, and delete the User Data associated with such account (except to the extent you have lawful reasons, such as regulatory requirements or fraud prevention, to retain such data); and
- Not use fraudulent, deceptive, or coercive measures to obtain user consent to the collection, sharing, or any specific use of User Data, and respect users’ decisions if they decline to consent.

dApps that collect, access, share, or encourage the collection, access, or sharing of Regulated Data from or between or among end users must comply with all Applicable Laws with respect to such Regulated Data. “Regulated Data” means any (a) Social Security numbers or other government-issued identification numbers; (b) protected health information subject to the Health Insurance Portability and Accountability Act (HIPAA) or other information regarding an individual’s medical history, mental or physical condition, or medical treatment or diagnosis by a health care professional; (c) health insurance information; (d) biometric information or biometric identifiers; (e) credentials to any financial accounts or credit, debit or payment card data subject to the Payment Card Industry Data Security Standard (PCI DSS); (f) tax return data; (g) precise geolocation data; (h) data revealing racial or ethnic origin, religious beliefs, sex life or sexual orientation, union membership, citizenship, or immigration status; (i) genetic data; (j) personal data collected from an individual under the age of 18; (k) personal data subject to any Applicable Law related to data protection, including U.S. state consumer privacy laws such as the California Consumer Privacy Act; (l) data relating to criminal convictions or offenses; or (m) online account credentials. Without limiting the foregoing:

- dApps that collect Regulated Data should collect only the minimum amount of such Regulated Data required to perform such dApp’s function;
- dApps should not offer Regulated Data for sale or otherwise make it available to any third party except with the applicable users’ express consent and in compliance with Applicable Law; and
- dApps that collect, store, and transfer Regulated Data should use encryption and other industry best practices to protect such Regulated Data in transit and at rest.

## Restricted Activities and Transactions [​](https://docs.solanamobile.com/dapp-publishing/publisher-policy\#restricted-activities-and-transactions "Direct link to Restricted Activities and Transactions")

Solana Mobile does not knowingly allow any dApps that are designed to process transactions, provide services, or facilitate other activities that violate Applicable Law. Without limiting the foregoing:

- dApps may not facilitate the sale or purchase of prescription drugs without a prescription;
- dApps may not promote or sell any substance that is unapproved under Applicable Law, regardless of whether it is being sold for such purposes;
- dApps that provide or purport to provide financial services subject to any regulation under Applicable Law must obtain and provide in connection with such Developer Assets all documentation required by Applicable Law to provide such financial services;
- dApps that are or purport to be regulated medical devices must obtain and provide in connection with such Developer Assets all documentation required by Applicable Law to act as a medical device;
- dApps that make any medical or health-related claims with respect to their services must substantiate those claims, and must have required legal and regulatory disclosures;
- dApps may not interfere with, disrupt, damage, or gain unauthorized access to any user devices or any other devices, networks, or services; and
- dApps may not include, distribute, or incorporate code that would introduce or exploit security vulnerabilities.

Developer Assets may not include, and Solana Mobile will not knowingly permit the dApp Store to allow, any of the following:

- dApps that block or interfere with the display of ads on other dApps;
- dApps that facilitate the circumvention of or provide instructions on how to circumvent security protections or otherwise hack networks, services, software, or hardware;
- dApps that encourage or cause cheating on or otherwise affect the gameplay of other dApps;
- dApps that access or use any service in a manner that violates the terms of use of such service;
- dApps that install other dApps or any other Content on a device without the user’s prior consent;
- dApps that link to or facilitate the distribution or installation of viruses or other malicious software;
- dApps or other Content containing a webview that loads untrusted web Content or unverified URLs obtained from untrusted sources; and
- dApps that force user interaction with disruptive ads or notifications.

## Guidelines for User-Generated Content [​](https://docs.solanamobile.com/dapp-publishing/publisher-policy\#guidelines-for-user-generated-content "Direct link to Guidelines for User-Generated Content")

dApps that solicit, permit, host, display, enable, or otherwise make available (“Make Available”) user-generated Content (“UGC”) are solely responsible for ensuring that such UGC complies with the restrictions applicable to Content as set forth in this Publisher Policy. In particular, and without limitation, any dApp that Makes Available any UGC must:

- Cause its user terms to include the same restrictions as this Publisher Policy, and require end users to agree to such user terms;
- Enable users to report or flag offensive or inappropriate content from within the dApp;
- Moderate UGC to ensure that there is no Restricted Content or other UGC that would violate this Publisher Policy or Applicable Law; and
- Provide reasonable self-help remedies for end users (e.g., a “block” function) to enable end users to minimize disputes, and support user dispute resolution through established processes.

- [Restricted Content](https://docs.solanamobile.com/dapp-publishing/publisher-policy#restricted-content)
- [Guidelines for User Data](https://docs.solanamobile.com/dapp-publishing/publisher-policy#guidelines-for-user-data)
- [Restricted Activities and Transactions](https://docs.solanamobile.com/dapp-publishing/publisher-policy#restricted-activities-and-transactions)
- [Guidelines for User-Generated Content](https://docs.solanamobile.com/dapp-publishing/publisher-policy#guidelines-for-user-generated-content)

## Submit dApp to Solana
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/submit-new-app#__docusaurus_skipToContent_fallback)

On this page

Use the [Solana dApp Publisher Portal](https://publish.solanamobile.com/) to submit your dApp to the Solana dApp Store.

## Before you begin [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#before-you-begin "Direct link to Before you begin")

Ensure you have:

- A release-ready APK file signed with your release key.
- App metadata prepared (name, description, screenshots, icon).
- A Solana wallet browser extension (Phantom, Solflare, etc.) with sufficient SOL.
- Reviewed the [Publisher Policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy) and [Developer Agreement](https://docs.solanamobile.com/dapp-publishing/agreement)

## 1\. Sign up for a Publisher Account [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#1-sign-up-for-a-publisher-account "Direct link to 1. Sign up for a Publisher Account")

- Navigate to the [Publisher Portal](https://publish.solanamobile.com/) and sign up for an account.
- Fill out your publisher profile and submit your KYC/KYB verification.

## 2\. Connect your publisher wallet [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#2-connect-your-publisher-wallet "Direct link to 2. Connect your publisher wallet")

- Connect a Solana wallet via a browser extension wallet (e.g Phantom, Solflare, Backpack). This will be your _publisher wallet_.
- Ensure the publisher wallet has sufficient SOL (~0.2 SOL) to cover transaction fees and ArDrive upload costs.

warning

Your publisher wallet is required for all future submissions of this app. Do not lose access to it or you will not be able
to make new submissions of this app.

## 3\. Set a storage provider [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#3-set-a-storage-provider "Direct link to 3. Set a storage provider")

Your storage provider selection determines where all your dApp assets (e.g APK file, Icon, Description, Preview Images/Videos, etc) are uploaded and stored during app submission.

**ArDrive is recommended** for storage costs and ease of setup.

Use the storage cost tool to estimate the SOL amount required for upload based on your app's size.

![Storage provider selection screenshot](https://docs.solanamobile.com/assets/images/storage-provider-8dd72669f533ae2d0a99da4354563840.png)

## 4\. Add your dApp details [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#4-add-your-dapp-details "Direct link to 4. Add your dApp details")

In the bottom-left menu, press "Add a dApp" > "New dApp" and a form will appear where you can input your app details.

![dApp details screenshot](https://docs.solanamobile.com/assets/images/new-dapp-details-9c6709ce084d8d177a2bd6642b4e4dae.png)

Save the form once you've filled out the details. These details can be changed before submission and updated in later submissions.

See [Listing Page Guidelines](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines) for detailed requirements.

## 5\. Submit your first release version [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#5-submit-your-first-release-version "Direct link to 5. Submit your first release version")

After adding your dApp, navigate to the app's **Home** menu in the sidebar. In the top-right, press the "New Version" button to begin the APK upload process.

![dApp details screenshot](https://docs.solanamobile.com/assets/images/home-new-version-a79028c083ceb79727808f0a1f2c15d2.png)

After uploading your APK and pressing "Submit", you will be prompted to sign multiple messages and transactions. These are required for uploading assets to Arweave and minting your release NFT.

warning

Ensure you approve each signing request and you do not skip any or else certain assets could be missing from your app submission.

![dApp details screenshot](https://docs.solanamobile.com/assets/images/dapp-apk-upload-8b7ee38f8b03a7e706d79fda38597f42.png)

Congratulations on submitting your first app! 🎉

## After Submission [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#after-submission "Direct link to After Submission")

Once submitted, your app automatically enters the app review queue and will go live immediately under an appropriate category once approved.

### App Review [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#app-review "Direct link to App Review")

- It typically takes 2-5 business days for app review, so please be patient as we go through the review queue.
- You'll be notified via your developer email when the app is approved or if changes are needed.

### Get in contact [​](https://docs.solanamobile.com/dapp-publishing/submit-new-app\#get-in-contact "Direct link to Get in contact")

To get in contact for any questions regarding publishing, app review, or launching on the dApp Store, please see
join the [Solana Mobile Discord](http://discord.gg/solanamobile) and see the `#dapp-store` channel for instructions to get in touch.

- [Before you begin](https://docs.solanamobile.com/dapp-publishing/submit-new-app#before-you-begin)
- [1\. Sign up for a Publisher Account](https://docs.solanamobile.com/dapp-publishing/submit-new-app#1-sign-up-for-a-publisher-account)
- [2\. Connect your publisher wallet](https://docs.solanamobile.com/dapp-publishing/submit-new-app#2-connect-your-publisher-wallet)
- [3\. Set a storage provider](https://docs.solanamobile.com/dapp-publishing/submit-new-app#3-set-a-storage-provider)
- [4\. Add your dApp details](https://docs.solanamobile.com/dapp-publishing/submit-new-app#4-add-your-dapp-details)
- [5\. Submit your first release version](https://docs.solanamobile.com/dapp-publishing/submit-new-app#5-submit-your-first-release-version)
- [After Submission](https://docs.solanamobile.com/dapp-publishing/submit-new-app#after-submission)
  - [App Review](https://docs.solanamobile.com/dapp-publishing/submit-new-app#app-review)
  - [Get in contact](https://docs.solanamobile.com/dapp-publishing/submit-new-app#get-in-contact)

## Android Development Setup
[Skip to main content](https://docs.solanamobile.com/getting-started/development-setup#__docusaurus_skipToContent_fallback)

On this page

This guide demonstrates how to set up your development environment for Android mobile development. Regardless of framework choice, ensure you follow these steps to start developing.

## Prerequisites [​](https://docs.solanamobile.com/getting-started/development-setup\#prerequisites "Direct link to Prerequisites")

### 1\. Install Android Studio [​](https://docs.solanamobile.com/getting-started/development-setup\#1-install-android-studio "Direct link to 1. Install Android Studio")

Install Android Studio to build apps and manage your device/emulator, following the official [Android developer docs](https://developer.android.com/studio/install). If you're planning on developing with React Native, then follow the [React Native Android environment setup guide](https://reactnative.dev/docs/environment-setup).

### 2\. Setup Device/Emulator [​](https://docs.solanamobile.com/getting-started/development-setup\#2-setup-deviceemulator "Direct link to 2. Setup Device/Emulator")

To test and preview your app as you develop, you can build and deploy your app to an Android device or emulator in Android Studio.
Follow official Android developer documentation to [create an emulator](https://developer.android.com/studio/run/emulator) or deploy your app to a [hardware device](https://developer.android.com/studio/run/device).

### 3\. Install a wallet app [​](https://docs.solanamobile.com/getting-started/development-setup\#3-install-a-wallet-app "Direct link to 3. Install a wallet app")

The [Mobile Wallet Adapter](https://github.com/solana-mobile/mobile-wallet-adapter) (MWA) library allows your dApp to connect and interface with Wallet Apps that implement the MWA protocol. For testing, you want to have an MWA-compatible wallet on the same device or emulator as your dApp.

#### 1\. Download, build, and install fakewallet [​](https://docs.solanamobile.com/getting-started/development-setup\#1-download-build-and-install-fakewallet "Direct link to 1. Download, build, and install fakewallet")

The [fakewallet](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/android/fakewallet) app is a 'fake' Mobile Wallet Adapter compliant wallet. Install it on your Android emulator or device. It does not store persistent keypairs, and the wallet is "reset" each time the app is exited.

Installation steps

1. Clone the Mobile Wallet Adapter repo, containing the fakewallet app from the [github repository](https://github.com/solana-mobile/mobile-wallet-adapter)

```text
git clone https://github.com/solana-mobile/mobile-wallet-adapter.git
```

2. In Android Studio, `Open project > Navigate to the cloned directory > Select mobile-wallet-adapter/android/build.gradle`

3. After Android Studio finishes loading the project, select `fakewallet` in the build/run configuration dropdown in the top right


![fakewallet build](https://docs.solanamobile.com/assets/images/fakewallet-install-11e2efa6965944b9be68de402ab70af0.png)

4. After it builds successfully, you should see the app on your Android device or emulator.

#### 2\. Install real wallet apps [​](https://docs.solanamobile.com/getting-started/development-setup\#2-install-real-wallet-apps "Direct link to 2. Install real wallet apps")

fakewallet was created for implementation reference and quick testing purposes. You should also test your dApp with popular MWA-compatible wallet apps like [Phantom](https://play.google.com/store/apps/details?id=app.phantom), [Solflare](https://play.google.com/store/apps/details?id=com.solflare.mobile), and [Ultimate](https://ultimate.app/).

You can install these onto an emulator by using an emulator with Google Play Store support. From there, you can login to your Google account and search for Phantom or Solflare to install it onto the emulator.

## Choose a development framework [​](https://docs.solanamobile.com/getting-started/development-setup\#choose-a-development-framework "Direct link to Choose a development framework")

Although, the Solana Mobile Stack is primarily written in native Android, we also have support for popular mobile
development frameworks.

These are our official SDKs that are maintained by the Solana Mobile team.

[_![](https://docs.solanamobile.com/img/react-native-96.svg)_ **React Native**\\
\\
Quickly start building your mobile dApp with React Native, with access to a selection of familiar web libraries.](https://docs.solanamobile.com/react-native/quickstart)

[_![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)_ **Kotlin**\\
\\
Develop a Kotlin Android app to utilize the full capabilities of the Android OS and build a performant native experience.](https://docs.solanamobile.com/android-native/overview)

### Community SDKs [​](https://docs.solanamobile.com/getting-started/development-setup\#community-sdks "Direct link to Community SDKs")

These SDKs are actively maintained, supported, and used by members and developers of our community. Click to learn more about
the capabilities supported by each, the state of development, and how to get started.

[_![](https://docs.solanamobile.com/img/flutter-icon.svg)_ **Flutter**\\
\\
An actively maintained SDK for building Solana mobile dApps with Flutter.](https://docs.solanamobile.com/flutter/overview)

[_![](https://docs.solanamobile.com/img/unity-logo.png)_ **Unity**\\
\\
Integrate the Solana Mobile stack into your Unity mobile game.](https://docs.solanamobile.com/unity/unity_sdk)

[_![](https://docs.solanamobile.com/img/unreal-logo.png)_ **Unreal Engine**\\
\\
An early stage SDK for integrating Solana Mobile into an Unreal Engine mobile game.](https://docs.solanamobile.com/unreal/unreal_sdk)

- [Prerequisites](https://docs.solanamobile.com/getting-started/development-setup#prerequisites)
  - [1\. Install Android Studio](https://docs.solanamobile.com/getting-started/development-setup#1-install-android-studio)
  - [2\. Setup Device/Emulator](https://docs.solanamobile.com/getting-started/development-setup#2-setup-deviceemulator)
  - [3\. Install a wallet app](https://docs.solanamobile.com/getting-started/development-setup#3-install-a-wallet-app)
- [Choose a development framework](https://docs.solanamobile.com/getting-started/development-setup#choose-a-development-framework)
  - [Community SDKs](https://docs.solanamobile.com/getting-started/development-setup#community-sdks)

## dApp Listing Guidelines
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines#__docusaurus_skipToContent_fallback)

Your dApp's listing page is often the first impression users will have of your application.
These guidelines will help you create a compelling and informative listing that showcases your dApp.

## App Icon

The app icon is often a user's first point of contact with your app on the dApp Store, so it is crucial that it is thoughtfully crafted to convey your dApp's brand and value.

**Requirements**

- Icon must be 512px by 512px dimensions.

![App Icon](https://docs.solanamobile.com/listing_page_imgs/appicon.png)

## App Name

Your app name should be unique, memorable, and suggest your app's core functionality. Set yourself apart by choosing a name that isn't generic or too similar to existing apps.

![App Name](https://docs.solanamobile.com/listing_page_imgs/appname.png)

## Description

**Short Description**

Your app’s subtitle, or short description, should concisely communicate the purpose of your app. Use this space to showcase your app's "elevator pitch" and capture a user's attention.

##### **Requirements** [​](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines\#requirements "Direct link to requirements")

- Short description cannot exceed 30 characters.

**Long Description**

Your app's long description should be a well-written, concise overview of your app' features and functionality. Use this space to give more context to users about what your app is and how they will use it. Users should be able to read it and quickly understand your app's core purpose.

![Description](https://docs.solanamobile.com/listing_page_imgs/subtitle.png)

## Preview

### Videos [​](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines\#videos "Direct link to Videos")

An app preview video should effectively showcase your app's main features, UI flow, and core user experience.

##### **Requirements** [​](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines\#requirements-1 "Direct link to requirements-1")

- All videos must be at least 720px in width and height. 1080p (1920px by 1080px) is strongly recommended.
- All videos must be `.mp4` video file format.

### Screenshots [​](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines\#screenshots "Direct link to Screenshots")

An app preview screenshot should highlight a core feature or screen of your app. The preview gallery should tell a compelling visual story of your app's core user experience.

##### **Requirements** [​](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines\#requirements-2 "Direct link to requirements-2")

- All images must be at least 1080px in width and height.
- All images must have consistent orientation (landscape or portrait).
- All images must have equal aspect ratio.

![Preview](https://docs.solanamobile.com/listing_page_imgs/apppreview.gif)

## Seeker Genesis Token
[Skip to main content](https://docs.solanamobile.com/marketing/engaging-seeker-users#__docusaurus_skipToContent_fallback)

On this page

## Overview [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#overview "Direct link to Overview")

The Seeker Genesis Token is a unique NFT that represents a verified owner of a Seeker device. It can only be minted once per device and is minted into the primary account in a user's Seed Vault Wallet.

## NFT Details [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#nft-details "Direct link to NFT Details")

The Seeker Genesis Token implements Token Extensions (formerly Token-2022).

### Transferability [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#transferability "Direct link to Transferability")

The Seeker Genesis Token can only be transferred between a user's wallet accounts on a permissioned basis within the Seed Vault Wallet.
A transfer occurs when a user changes their primary account in the Seed Vault Wallet.

The **mint address** of the SGT remains the same when it is transferred.

#### Anti-Sybil Example: In-App Rewards Claim [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#anti-sybil-example-in-app-rewards-claim "Direct link to Anti-Sybil Example: In-App Rewards Claim")

Even with transferability, the Seeker Genesis Token is still useful as an anti-sybil measure.

As an example, imagine an in-app rewards claim that wants to use the Seeker Genesis Token to limit the claim to once per Seeker device.

To implement this, the app should check for 3 properties:

1. The connected wallet owns a Seeker Genesis Token.
2. The user proves ownership of the wallet via [signing a message](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#dapp-integration).
3. The Seeker Genesis Token has not been previously used to claim a reward (i.e check that its **mint address** has not been seen before).

Step 3 is crucial to exclude wallets that have previously claimed the reward on another wallet (and then transferred the SGT to a new wallet).

### Token Extensions [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#token-extensions "Direct link to Token Extensions")

Seeker Genesis Token implements several extensions, notably:

- Metadata Pointer
- Token Group Member and Pointer

### Key Addresses [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#key-addresses "Direct link to Key Addresses")

- **Mint Authority**: `GT2zuHVaZQYZSyQMgJPLzvkmyztfyXg2NJunqFp4p3A4`
- **Metadata Address**: `GT22s89nU4iWFkNXj1Bw6uYhJJWDRPpShHt4Bk8f99Te`
- **Group Address**: `GT22s89nU4iWFkNXj1Bw6uYhJJWDRPpShHt4Bk8f99Te`

#### View on an Explorer [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#view-on-an-explorer "Direct link to View on an Explorer")

- An individual [Seeker Genesis Token](https://explorer.solana.com/address/5mXbkqKz883aufhAsx3p5Z1NcvD2ppZbdTTznM6oUKLj/token-extensions) and its extensions
- Seeker Genesis Token [Metadata Account](https://explorer.solana.com/address/GT22s89nU4iWFkNXj1Bw6uYhJJWDRPpShHt4Bk8f99Te/)

## Verifying Seeker Genesis Token Ownership [​](https://docs.solanamobile.com/marketing/engaging-seeker-users\#verifying-seeker-genesis-token-ownership "Direct link to Verifying Seeker Genesis Token Ownership")

To verify a wallet owns a Seeker Genesis Token, you can use the [`getTokenAccountsByOwnerV2` API call](https://www.helius.dev/docs/api-reference/rpc/http/gettokenaccountsbyownerv2) provided by Helius.

Here's an example script:

```js
const { Connection, PublicKey } = require('@solana/web3.js');
const { unpackMint, getMetadataPointerState, getTokenGroupMemberState, TOKEN_2022_PROGRAM_ID } = require('@solana/spl-token');

async function checkWalletForSGT(walletAddress) {
  const HELIUS_RPC_URL = `https://mainnet.helius-rpc.com/?api-key=${HELIUS_API_KEY}`;

  const SGT_MINT_AUTHORITY = 'GT2zuHVaZQYZSyQMgJPLzvkmyztfyXg2NJunqFp4p3A4';

  // The metadata mint and group mint address are intentionally the same.
  const SGT_METADATA_ADDRESS = 'GT22s89nU4iWFkNXj1Bw6uYhJJWDRPpShHt4Bk8f99Te';
  const SGT_GROUP_MINT_ADDRESS = 'GT22s89nU4iWFkNXj1Bw6uYhJJWDRPpShHt4Bk8f99Te';

  try {
    const connection = new Connection(HELIUS_RPC_URL);

    // Use getTokenAccountsByOwnerV2 with pagination
    let allTokenAccounts = [];
    let paginationKey = null;
    let pageCount = 0;

    console.log(`Starting paginated fetch for wallet: ${walletAddress}`);

    do {
      pageCount++;
      console.log(`Fetching page ${pageCount}...`);

      const requestPayload = {
        jsonrpc: '2.0',
        id: `page-${pageCount}`,
        method: 'getTokenAccountsByOwnerV2',
        params: [\
          walletAddress,\
          { "programId": "TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb" }, // Token-2022 program\
          {\
            encoding: 'jsonParsed',\
            limit: 1000, // Maximum accounts per request\
            ...(paginationKey && { paginationKey })\
          }\
        ]
      };

      const response = await fetch(HELIUS_RPC_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(requestPayload)
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();

      if (data.error) {
        throw new Error(`RPC error: ${data.error.message}`);
      }

      const pageResults = data.result?.value.accounts || [];
      console.log(`Page ${pageCount}: Found ${pageResults.length} token accounts`);

      if (pageResults.length > 0) {
        allTokenAccounts.push(...pageResults);
      }
      paginationKey = data.result?.paginationKey;

      // Log pagination info
      if (data.result.totalResults) {
        console.log(`Total results available: ${data.result.totalResults}`);
      }

    } while (paginationKey); // Continue until no more pages

    console.log(`\nCompleted pagination: ${pageCount} pages, ${allTokenAccounts.length} total token accounts`);

    if (allTokenAccounts.length === 0) {
      console.log("No Token-2022 accounts found for this wallet.");
      return false;
    }

    // Extract mint addresses from token accounts
    const mintPubkeys = allTokenAccounts
      .map((accountInfo) => {
        try {
          if (accountInfo?.account?.data?.parsed?.info?.mint) {
            return new PublicKey(accountInfo.account.data.parsed.info.mint);
          } else {
            console.log('No mint found for account:', accountInfo);
            return null;
          }
        } catch (error) {
          return null;
        }
      })
      .filter((mintPubkey) => mintPubkey !== null);

    console.log(`Extracted ${mintPubkeys.length} mint addresses`);

    // Fetch all mint account data in batches of 100 to avoid RPC limits
    const BATCH_SIZE = 100;
    const mintAccountInfos = [];

    for (let i = 0; i < mintPubkeys.length; i += BATCH_SIZE) {
      const batch = mintPubkeys.slice(i, i + BATCH_SIZE);
      console.log(`Fetching mint info batch ${Math.floor(i / BATCH_SIZE) + 1}/${Math.ceil(mintPubkeys.length / BATCH_SIZE)}`);

      const batchResults = await connection.getMultipleAccountsInfo(batch);
      mintAccountInfos.push(...batchResults);
    }

    // Check each mint for SGT verification
    console.log(`Checking ${mintAccountInfos.length} mints for SGT verification...`);

    for (let i = 0; i < mintAccountInfos.length; i++) {
      const mintInfo = mintAccountInfos[i];
      if (mintInfo) {
        const mintPubkey = mintPubkeys[i];

        try {
          // Unpack the raw mint account data
          const mint = unpackMint(mintPubkey, mintInfo, TOKEN_2022_PROGRAM_ID);
          const mintAuthority = mint.mintAuthority?.toBase58();

          const hasCorrectMintAuthority = mintAuthority === SGT_MINT_AUTHORITY;

          // Check for correct SGT Metadata
          const metadataPointer = getMetadataPointerState(mint);
          const hasCorrectMetadata = metadataPointer &&
              metadataPointer.authority?.toBase58() === SGT_MINT_AUTHORITY &&
              metadataPointer.metadataAddress?.toBase58() === SGT_METADATA_ADDRESS;

          // Check for correct SGT Group Member
          const tokenGroupMemberState = getTokenGroupMemberState(mint);
          const hasCorrectGroupMember = tokenGroupMemberState &&
              tokenGroupMemberState.group?.toBase58() === SGT_GROUP_MINT_ADDRESS;

          // If all extensions match and mint authority is correct, then it is an SGT
          if (hasCorrectMintAuthority && hasCorrectMetadata && hasCorrectGroupMember) {
            console.log(`\nVERIFIED SGT FOUND: Wallet holds a verified SGT (${mint.address.toBase58()}).`);
            return true;
          }
        } catch (mintError) {
          // Skip this mint if we can't unpack it
          console.log(`Warning: Could not unpack mint ${mintPubkey.toBase58()}: ${mintError.message}`);
          continue;
        }
      }
    }

    // No verified SGT found in wallet
    console.log("\nNo verified SGT found in wallet.");
    return false;

  } catch (error) {
    console.error("Error verifying SGT ownership:", error.message);
    return false;
  }
}
```

- [Overview](https://docs.solanamobile.com/marketing/engaging-seeker-users#overview)
- [NFT Details](https://docs.solanamobile.com/marketing/engaging-seeker-users#nft-details)
  - [Transferability](https://docs.solanamobile.com/marketing/engaging-seeker-users#transferability)
  - [Token Extensions](https://docs.solanamobile.com/marketing/engaging-seeker-users#token-extensions)
  - [Key Addresses](https://docs.solanamobile.com/marketing/engaging-seeker-users#key-addresses)
- [Verifying Seeker Genesis Token Ownership](https://docs.solanamobile.com/marketing/engaging-seeker-users#verifying-seeker-genesis-token-ownership)

## Solana Mobile Wallet SDK
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/mobile-apps#__docusaurus_skipToContent_fallback)

## Overview [​](https://docs.solanamobile.com/mobile-wallet-adapter/mobile-apps\#overview "Direct link to Overview")

Solana Mobile maintains an open-source **Android** SDK for Mobile Wallet Adapter that enables mobile apps to connect to wallet apps on the same device.

### Installation

[![](https://docs.solanamobile.com/img/react-native-96.svg)\\
\\
React Native](https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter) [![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)\\
\\
Kotlin](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter) [Mobile Web](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation) [![](https://docs.solanamobile.com/img/flutter-icon.svg)\\
\\
Flutter](https://docs.solanamobile.com/flutter/overview) [![](https://docs.solanamobile.com/img/unity-logo.png)\\
\\
Unity](https://docs.solanamobile.com/unity/unity_sdk) [![](https://docs.solanamobile.com/img/unreal-logo.png)\\
\\
Unreal](https://docs.solanamobile.com/unreal/unreal_sdk)

note

These SDKs are only supported on Android because MWA is incompatible with iOS. View this [blog post](https://docs.solanamobile.com/blog/ios-wallet-signing) to learn why.

### SDK Compatibility [​](https://docs.solanamobile.com/mobile-wallet-adapter/mobile-apps\#sdk-compatibility "Direct link to SDK Compatibility")

| Mobile Platform | Is MWA Supported? | Notes |
| --- | --- | --- |
| Android | ✅ | Full support for dApps and Wallet apps. |
| Mobile Web - Chrome (Android) | ✅ | Automatic integration if using `@solana/wallet-adapter-react`. |
| iOS | ❌ | MWA is not currently available for any iOS platform (app or browser). |
| Mobile Web - Safari, Firefox, Opera, Brave | ❌ | These browsers currently do not support MWA on Android or iOS. |

SV WalletSolflarePhantom

## Supported Wallets [​](https://docs.solanamobile.com/mobile-wallet-adapter/mobile-apps\#supported-wallets "Direct link to Supported Wallets")

These wallets support MWA and are compatible on Android with any dApp using the Mobile Wallet Adapter SDK.

- Seed Vault Wallet (Coming soon!)
- Solflare
- Phantom

## DApp Publishing Preparation
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/prepare#__docusaurus_skipToContent_fallback)

On this page

To prepare for publishing, you must

1. Collect your publishing assets into a folder
2. Build and sign your Android APK
3. Populate the `config.yaml`

It is recommended that you colocate app publishing files with your dApp and source control them together.

## Example [​](https://docs.solanamobile.com/dapp-publishing/prepare\#example "Direct link to Example")

For reference, view these two apps with dApp Store Publishing Repos:

- [Solana Mobile Example Repo](https://github.com/solana-mobile/dapp-publishing/tree/main/example)
- [Gem Wallet Open Source Repo](https://github.com/gemwalletcom/solana-mobile-publishing/blob/main/config.yaml)

## 1\. Collect publishing assets [​](https://docs.solanamobile.com/dapp-publishing/prepare\#1-collect-publishing-assets "Direct link to 1. Collect publishing assets")

Once your publishing folder is initialized, place your publishing assets (e.g., APK file, icons, screenshot images, videos) in a sub-folder (e.g `/media`, `/files`).

### Asset Requirements [​](https://docs.solanamobile.com/dapp-publishing/prepare\#asset-requirements "Direct link to Asset Requirements")

Your submission must meet the following requirements to pass app review:

- **Icon(s)**must be 512px by 512px dimensions.
  - Follow the [Google Play icon design spec](https://developer.android.com/distribute/google-play/resources/icon-design-specifications) for best practices.
- **Banner Graphic** image of size 1200px by 600px is required.
- (optional) **Feature Graphic** image of size 1200x1200px is required to be featured in Editor's choice carousel
- Provide a minimum of **4 screenshot images or videos** of your app.
  - We recommend preview images and videos to be 1080p resolution (1920px by 1080px).
- Image Requirements
  - All images provided must be at least 1080px in width and height.
  - All images provided must have consistent orientation (landscape or portrait).
  - All images provided must have equal aspect ratio.
- Videos Requirements
  - All videos provided must be at least 720px in width and height.
  - All videos provided must be `.mp4` video file format.
    - If you have `.mp4` videos included, make sure you have `ffmpeg` utility library [installed](https://docs.solanamobile.com/dapp-publishing/setup#ffmpeg).
- A release build of your **Android APK** signed with a unique signing key.

## 2\. Build and sign your APK [​](https://docs.solanamobile.com/dapp-publishing/prepare\#2-build-and-sign-your-apk "Direct link to 2. Build and sign your APK")

To submit your app, you will need to include an APK.

It must be:

- A release build version of your APK. Debug builds cannot be accepted.
- Signed with a new [signing key](https://developer.android.com/studio/publish/app-signing#opt-out) solely for the dApp Store. If signed by an existing Google Play Store signing key, the app cannot be accepted.

If you're publishing an Expo app, view this [APK building and signing guide](https://docs.solanamobile.com/dapp-publishing/building-expo-apk).

#### Recommendations [​](https://docs.solanamobile.com/dapp-publishing/prepare\#recommendations "Direct link to Recommendations")

- [Securely store](https://developer.android.com/studio/publish/app-signing#secure_key) your signing key. It is required to make future updates to your app and if lost you cannot make updates to the app.
- Ensure your APK is localized properly, and that your `build.gradle` file identifies the languages & locales that your dApp supports. See [the Android developer documentation](https://developer.android.com/guide/topics/resources/multilingual-support#specify-the-languages-your-app-supports) for more details.

## 3\. Populate the configuration file [​](https://docs.solanamobile.com/dapp-publishing/prepare\#3-populate-the-configuration-file "Direct link to 3. Populate the configuration file")

When you initialized the publishing repo, a `config.yaml` will have been generated. This is what the CLI will read to create your app listing page.

For this step, you must edit the configuration file with your app details and asset file paths.

Instructions:

1. Replace all fields in `<< >>` with your app details.
2. Remove any fields that don't apply (for e.g., `saga_features`, `google_store_package`, etc).
3. Do **not** modify or remove the `address` fields. These will be automatically populated by the CLI in later steps.
4. You may need to provide details in the `testing_instructions` field of the configuration file that you would not want published on-chain (e.g `test_username` and `test_password`). Rest assured, this data is not published as part of the on-chain metadata.

Reference

For a reference of a completed configuration file, view the two open source examples:

- [Solana Mobile Example Repo](https://github.com/solana-mobile/dapp-publishing/tree/main/example)
- [Gem Wallet Open Source Repo](https://github.com/gemwalletcom/solana-mobile-publishing/blob/main/config.yaml)

Publishing Config Explanation

There are 3 sections to fill out: `publisher`, `app`, and `release`:

- The `publisher` section describes you, the app developer.
- The `app` section represents a single logical app produced by a publisher. A single publisher will always have at least one app, but if you publish multiple different apps under a single identity, there will be one for each of your apps.
- The `release` section is the most important, and describes all the metadata for a single release of an app, including its display name, description, icons, screenshots, etc. The text you enter in the `catalog` subsection, along with the icon and screenshots in the `media` subsections, are what application stores will use to display details about your app to the end user, so be as descriptive as you can.

### Localization of store details (Optional) [​](https://docs.solanamobile.com/dapp-publishing/prepare\#localization-of-store-details-optional "Direct link to Localization of store details (Optional)")

The configuration file allows for localization of the details/copy you provide that describes your app. To be clear, this localized text is different from the strings localized _within your app itself_. Localized store details will be presented to users browsing dApp stores based on the locale they have chosen on their device. If a user's device is set to a locale you have provided, they will be presented that localized text.

As a tangible example, here's how you would localize details strings for French (France). This would be placed at the same hierarchical level alongside the default `en-US` locale text:

```yaml
release:
    catalog:
        en-US:
          name: Name of app in English
          ...
        fr-FR:
            name: >-
              Name of app in French (France)
            short_description: >-
              Short app description in French (France)
            long_description: |
              Long app description in French (France)
            new_in_version: >-
              New version features in French (France)
            saga_features: >-
              Saga features in French (France)
```

- [Example](https://docs.solanamobile.com/dapp-publishing/prepare#example)
- [1\. Collect publishing assets](https://docs.solanamobile.com/dapp-publishing/prepare#1-collect-publishing-assets)
  - [Asset Requirements](https://docs.solanamobile.com/dapp-publishing/prepare#asset-requirements)
- [2\. Build and sign your APK](https://docs.solanamobile.com/dapp-publishing/prepare#2-build-and-sign-your-apk)
- [3\. Populate the configuration file](https://docs.solanamobile.com/dapp-publishing/prepare#3-populate-the-configuration-file)
  - [Localization of store details (Optional)](https://docs.solanamobile.com/dapp-publishing/prepare#localization-of-store-details-optional)

## Detecting Seeker Users
[Skip to main content](https://docs.solanamobile.com/react-native/detecting-seeker-users#__docusaurus_skipToContent_fallback)

On this page

This guide outlines the two primary methods for identifying Seeker users within your React Native application. Choose the appropriate method based on your requirements and use case.

## Overview [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#overview "Direct link to Overview")

There are two main approaches to detect Seeker users:

1. **Platform Constants Check**: A lightweight client-side check using React Native's Platform API
2. **Seeker Genesis Token Verification**: A secure on-chain verification method

## Method 1: Platform Constants Check [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#method-1-platform-constants-check "Direct link to Method 1: Platform Constants Check")

The Platform Constants method checks device information using React Native's built-in [Platform API](https://reactnative.dev/docs/platform). This is a quick, lightweight check suitable for UI treatments and non-critical features.

Security Consideration

The Platform Constants API can be spoofed and should **not** be used for use cases where you need a guaranteed Seeker user.

For use cases where you need a guarantee that you are interacting with a Seeker user, see [Method 2: Seeker Genesis Token Verification](https://docs.solanamobile.com/react-native/detecting-seeker-users#method-2-seeker-genesis-token-verification) instead.

### Checking Platform Constants [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#checking-platform-constants "Direct link to Checking Platform Constants")

```tsx
import { Platform } from 'react-native';

console.log(JSON.stringify(Platform.constants, null, 2));
```

When running on a Seeker device, the above code outputs something like:

```json
{
  "uiMode": "normal",
  "reactNativeVersion": {
    "minor": 79,
    "prerelease": null,
    "major": 0,
    "patch": 5
  },
  "isTesting": false,
  "ServerHost": "localhost:8081",
  "Brand": "solanamobile",
  "Manufacturer": "Solana Mobile Inc.",
  "Release": "15",
  "Fingerprint": "solanamobile/seeker/seeker:15/AP3A.250103.524.A2/mp1V912:userdebug/release-keys",
  "Serial": "unknown",
  "Model": "Seeker",
  "Version": 35
}
```

To check if the user on a Seeker, you can check the `Model` constant:

```ts
const isSeekerDevice = (): boolean => {
  return Platform.constants.Model === 'Seeker';
};
```

### Use Cases [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#use-cases "Direct link to Use Cases")

- **UI Treatments**: Show special welcome messages, themes, or layouts for Seeker users
- **Feature Flags**: Enable/disable certain features based on device type
- **Analytics**: Track usage patterns by device type
- **Marketing**: Display device-specific promotional content

### Limitations [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#limitations "Direct link to Limitations")

**The main limitation is that this method is spoofable** \- rooted devices or modified apps can change the Platform constants to mimic a Seeker device.

See the next method for a guaranteed way to check for interaction with a Seeker user.

## Method 2: Seeker Genesis Token Verification [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#method-2-seeker-genesis-token-verification "Direct link to Method 2: Seeker Genesis Token Verification")

For use cases where you need a guarantee that you are interacting with a Seeker user, verify that the user's wallet contains the Seeker Genesis Token (SGT).

The SGT is a unique NFT that is minted to a user's wallet only _once_ per Seeker device. Owning an SGT represents verified ownership of a Seeker device.

Learn more about the [Seeker Genesis Token](https://docs.solanamobile.com/marketing/engaging-seeker-users).

### Genesis Token Verification Process [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#genesis-token-verification-process "Direct link to Genesis Token Verification Process")

The verification process has **two main steps**:

1. **SIWS to prove wallet ownership**: Use Sign-in-with-Solana to prove the user owns the wallet
2. **Check the wallet contains an SGT**: Once wallet ownership is proven, verify that the wallet contains a Seeker Genesis Token

#### Step 1: Prove Wallet Ownership with SIWS [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#step-1-prove-wallet-ownership-with-siws "Direct link to Step 1: Prove Wallet Ownership with SIWS")

**Client-side: Sign the SIWS Payload**

Use Mobile Wallet Adapter to request the user to sign the SIWS payload:

```tsx
import { transact } from '@solana-mobile/mobile-wallet-adapter-protocol-web3js';

const APP_IDENTITY = {
  name: 'Your React Native dApp',
  uri: 'https://yourdapp.com',
  icon: 'favicon.ico',
};

async function signSIWSPayload() {
  const result = await transact(async (wallet) => {
    const authorizationResult = await wallet.authorize({
      cluster: 'solana:mainnet',
      identity: APP_IDENTITY,
      sign_in_payload: {
        domain: 'yourdapp.com',
        statement: 'Sign in to verify Seeker ownership',
        uri: 'https://yourdapp.com',
      },
    });

    return {
      walletAddress: authorizationResult.accounts[0].address,
      signInResult: authorizationResult.sign_in_result,
    };
  });

  return result;
}
```

**Server-side: Verify the SIWS signature**

The `signInResult` from the MWA response needs to be verified on your backend server:

```tsx
// This happens on your backend server
import { verifySignIn } from "@solana/wallet-standard-util";

async function verifySIWS(signInPayload, signInResult): Promise<boolean> {
  const serialisedOutput = {
    account: {
      publicKey: new Uint8Array(signInResult.account.publicKey),
      ...signInResult.account,
    },
    signature: new Uint8Array(signInResult.signature),
    signedMessage: new Uint8Array(signInResult.signedMessage),
  };

  // Verify the signature against the original payload
  return verifySignIn(signInPayload, serialisedOutput);
}
```

For complete SIWS verification details, see the [Phantom SIWS spec](https://github.com/phantom/sign-in-with-solana).

#### Step 2: Check SGT Ownership [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#step-2-check-sgt-ownership "Direct link to Step 2: Check SGT Ownership")

**Server-side: Query an RPC to verify SGT ownership**

On your backend, make an RPC query to check if the user's wallet contains a Seeker Genesis Token.

- Reference this [**example script**](https://docs.solanamobile.com/marketing/engaging-seeker-users#verifying-seeker-genesis-token-ownership) that uses the Helius `getTokenAccountsByOwnerV2` API.

#### Step 3: Combine SIWS Verification and SGT Check [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#step-3-combine-siws-verification-and-sgt-check "Direct link to Step 3: Combine SIWS Verification and SGT Check")

On your backend server, combine the SIWS verification and SGT ownership check together to confirm the user is a verified Seeker owner:

```tsx
// On your backend server
async function verifySeekerUser(signInResult) {
    // Verify SIWS signature
    const siwsVerified = await verifySIWS(signInResult);

    // Check SGT ownership
    const hasSGT = await checkWalletForSGT(signInResult.walletAddress);

    // If both true, user is a verified owner of a Seeker device.
    return siwsVerified && hasSGT;
}
```

### Use Cases [​](https://docs.solanamobile.com/react-native/detecting-seeker-users\#use-cases-1 "Direct link to Use Cases")

warning

SGTs are transferrable between a user's wallet, so you must verify uniqueness by checking the SGT's unique mint address.

For full details and best practices, see the [Transferability](https://docs.solanamobile.com/marketing/engaging-seeker-users#transferability) documentation.

- **Gated Content**: Restrict certain features or content to verified Seeker users.
- **Rewards Programs**: Distribute exclusive rewards to Seeker owners.
- **Anti-Sybil Measures**: Prevent multiple claims or actions per device.

- [Overview](https://docs.solanamobile.com/react-native/detecting-seeker-users#overview)
- [Method 1: Platform Constants Check](https://docs.solanamobile.com/react-native/detecting-seeker-users#method-1-platform-constants-check)
  - [Checking Platform Constants](https://docs.solanamobile.com/react-native/detecting-seeker-users#checking-platform-constants)
  - [Use Cases](https://docs.solanamobile.com/react-native/detecting-seeker-users#use-cases)
  - [Limitations](https://docs.solanamobile.com/react-native/detecting-seeker-users#limitations)
- [Method 2: Seeker Genesis Token Verification](https://docs.solanamobile.com/react-native/detecting-seeker-users#method-2-seeker-genesis-token-verification)
  - [Genesis Token Verification Process](https://docs.solanamobile.com/react-native/detecting-seeker-users#genesis-token-verification-process)
  - [Use Cases](https://docs.solanamobile.com/react-native/detecting-seeker-users#use-cases-1)

## Solana Expo Guide
[Skip to main content](https://docs.solanamobile.com/react-native/expo#__docusaurus_skipToContent_fallback)

On this page

[Expo](https://expo.dev/) is a popular open-source platform that simplifies the development, building, and deployment process for React Native applications. Expo apps have their own managed development flow and utilize the Expo SDK.

tip

All React Native guides and tutorials for the Solana Mobile SDKs **are all applicable for Expo as well**! After the initial setup, the development of an Expo app and a React Native app are very similar.

## Expo Starter Template [​](https://docs.solanamobile.com/react-native/expo\#expo-starter-template "Direct link to Expo Starter Template")

The quickest option to get started with Expo development is using the [Solana Mobile Expo dApp Template](https://docs.solanamobile.com/react-native/expo-dapp-template). Run a single CLI command to initialize an Expo app with pre-installed Solana libraries and UI components.

Initialize the template with:

```bash
yarn create expo-app --template @solana-mobile/solana-mobile-expo-template
```

Then follow the [_Running the app_](https://docs.solanamobile.com/react-native/expo#running-the-app) guide below.

[View on Github](https://github.com/solana-mobile/solana-mobile-expo-template)

## Manual Installation [​](https://docs.solanamobile.com/react-native/expo\#manual-installation "Direct link to Manual Installation")

If you want to create a new Expo project from scratch then follow these steps. If you want to integrate an existing project with the SDK, then skip to [installing the dependencies](https://docs.solanamobile.com/react-native/expo#step-2-install-dependencies).

As a prerequisite, follow the [React Native official documentation](https://reactnative.dev/docs/environment-setup) and set up your environment for Android.

#### Step 1: Initialize a new Expo project [​](https://docs.solanamobile.com/react-native/expo\#step-1-initialize-a-new-expo-project "Direct link to Step 1: Initialize a new Expo project")

```shell
npx create-expo-app
```

Enter your app project name then move into the newly generated folder.

#### Step 2: Install dependencies [​](https://docs.solanamobile.com/react-native/expo\#step-2-install-dependencies "Direct link to Step 2: Install dependencies")

- yarn
- npm

```shell
yarn add \
  @solana/web3.js \
  @solana-mobile/mobile-wallet-adapter-protocol-web3js \
  @solana-mobile/mobile-wallet-adapter-protocol \
  react-native-get-random-values \
  buffer
```

```shell
npm install \
  @solana/web3.js \
  @solana-mobile/mobile-wallet-adapter-protocol-web3js \
  @solana-mobile/mobile-wallet-adapter-protocol \
  react-native-get-random-values \
  buffer
```

A brief overview of each dependency:

- `@solana-mobile/mobile-wallet-adapter-protocol`: A React Native/Javascript API enabling interaction with MWA-compatible wallets.
- `@solana-mobile/mobile-wallet-adapter-protocol-web3js`: A convenience wrapper to use common primitives from [@solana/web3.js](https://github.com/solana-labs/solana-web3.js) – such as `Transaction` and `Uint8Array`.
- `@solana/web3.js`: Solana Web Library for interacting with Solana network through the [JSON RPC API](https://docs.solana.com/api/http).
- `react-native-get-random-values` Secure random number generator polyfill for `web3.js` underlying Crypto library on React Native.
- `buffer` Buffer polyfill also needed for `web3.js` on React Native.

#### Step 3: Update App.js with polyfills [​](https://docs.solanamobile.com/react-native/expo\#step-3-update-appjs-with-polyfills "Direct link to Step 3: Update App.js with polyfills")

##### For Expo SDK 48 and below [​](https://docs.solanamobile.com/react-native/expo\#for-expo-sdk-48-and-below "Direct link to For Expo SDK 48 and below")

For basic Expo apps, the entrypoint file is usually in the root of the project (i.e: `App.js`, `App.tsx`, `index.js`).

Add the following two lines to the top of the entrypoint file:

```javascript
import "react-native-get-random-values";
import { Buffer } from "buffer";
global.Buffer = Buffer;
```

##### For Expo SDK Version 49+ and Expo Router [​](https://docs.solanamobile.com/react-native/expo\#for-expo-sdk-version-49-and-expo-router "Direct link to For Expo SDK Version 49+ and Expo Router")

If using Expo Router _and_ Expo SDK Version 49+ the entrypoint and polyfill setup is different. See the specific instructions below.

Polyfills: Expo SDK Version 49+ and Expo Router

If you are using Expo SDK Version 49+ and Expo Router, the `expo-crypto` package will replace `react-native-get-random-values` and you'll create your own entrypoint file for polyfilling.

#### Install expo-crypto [​](https://docs.solanamobile.com/react-native/expo\#install-expo-crypto "Direct link to Install expo-crypto")

`expo-crypto` is an official SDK by Expo that provides the polyfill functionality we need for libraries like `@solana/web3.js`. See official
docs for [installation instructions](https://docs.expo.dev/versions/latest/sdk/crypto/).

```shell
npx expo install expo-crypto
```

#### Entrypoint file polyfills [​](https://docs.solanamobile.com/react-native/expo\#entrypoint-file-polyfills "Direct link to Entrypoint file polyfills")

In the root of your project create a new entrypoint file (i.e `index.js`). In this new file,
you can initialize the polyfills at the top of the file.

In this case, we polyfill the global `Crypto` object with `getRandomValues` from `expo-crypto`.

Paste the following code:

```javascript
// index.js
import { getRandomValues as expoCryptoGetRandomValues } from "expo-crypto";
import { Buffer } from "buffer";
global.Buffer = Buffer;

// getRandomValues polyfill
class Crypto {
  getRandomValues = expoCryptoGetRandomValues;
}

const webCrypto = typeof crypto !== "undefined" ? crypto : new Crypto();

(() => {
  if (typeof crypto === "undefined") {
    Object.defineProperty(window, "crypto", {
      configurable: true,
      enumerable: true,
      get: () => webCrypto,
    });
  }
})();

import "expo-router/entry";
```

Then at the end, import `"expo-router/entry"` to ensure the app is using Expo Router.

#### Update package.json entrypoint [​](https://docs.solanamobile.com/react-native/expo\#update-packagejson-entrypoint "Direct link to Update package.json entrypoint")

Lastly, in `package.json`, update the `main` field to point to the new entrypoint file.

```json
// Old entrypoint
{
  "main": "node_modules/expo/AppEntry.js"
}

// New entrypoint
{
  "main": "index.js"
}
```

#### Step 4. Build and run the app [​](https://docs.solanamobile.com/react-native/expo\#step-4-build-and-run-the-app "Direct link to Step 4. Build and run the app")

Now the project is properly installed and configured, all that's left is to build a custom development APK, install it, then launch the Expo dev client.
Follow the steps on the next section.

### Running the app [​](https://docs.solanamobile.com/react-native/expo\#running-the-app "Direct link to Running the app")

#### Custom Development Build [​](https://docs.solanamobile.com/react-native/expo\#custom-development-build "Direct link to Custom Development Build")

The traditional [Expo Go](https://github.com/expo/fyi/blob/main/whats-in-the-sdk.md) development flow is only limited to certain hand-picked modules and does not support further customized native code, which Solana Mobile SDKs need.

Instead, we'll need to use a [custom development build](https://docs.expo.dev/develop/development-builds/create-a-build) which makes Solana Mobile React Native libraries (i.e Mobile Wallet Adapter) fully compatible with Expo.

Full steps of building and running a custom development build below.

#### Local vs EAS builds [​](https://docs.solanamobile.com/react-native/expo\#local-vs-eas-builds "Direct link to Local vs EAS builds")

The `eas build` command deploys a job to the EAS Build service that builds your APK using Expo's build infrastructure.

You can also run the build process locally by adding the `--local` flag that runs, which builds and generates the APK on your computer. You'll need Android Studio and Java correctly setup for this step.

See the Expo official documentation for [local builds](https://docs.expo.dev/build-reference/local-builds/).

- EAS build
- Build locally

#### Build with eas build [​](https://docs.solanamobile.com/react-native/expo\#build-with-eas-build "Direct link to Build with eas build")

You can use Expo's build service to build your app with no development environment setup required. Make sure you have an Expo account and have logged in with `expo login`.

In the project directory, run the command:

```shell
npx eas build --profile development --platform android
```

After it's finished building you should receive a QR code and download URL to the `apk` of your app. You can download this to your emulator/device.

#### Prerequisites [​](https://docs.solanamobile.com/react-native/expo\#prerequisites "Direct link to Prerequisites")

Before building locally, follow the [_React Native CLI Quickstart_ guide](https://reactnative.dev/docs/environment-setup) to set up your development environment.

After following the guide, you should:

- Install and use the recommended JDK 17
- Install and configure Android Studio
- Set your `JAVA_HOME` and `ANDROID_HOME` environment variables

#### Configure `eas.json` [​](https://docs.solanamobile.com/react-native/expo\#configure-easjson "Direct link to configure-easjson")

Ensure your development profile has the `developmentClient` field set to true.

```json
"development": {
    "developmentClient": true,
    "distribution": "internal"
},
```

#### Build locally [​](https://docs.solanamobile.com/react-native/expo\#build-locally "Direct link to Build locally")

Run the build locally with the specified profile and `--local` flag.

```shell
npx eas build --profile development --platform android --local
```

Troubleshooting:

#### Incorrect JDK version or Missing Android SDK [​](https://docs.solanamobile.com/react-native/expo\#incorrect-jdk-version-or-missing-android-sdk "Direct link to Incorrect JDK version or Missing Android SDK")

Follow the [React Native CLI setup instructions](https://reactnative.dev/docs/environment-setup) to make sure your local environment is setup for Android development.
You'll need:

- JDK version 11
- Android SDK installed and configured through Android Studio SDK Manager
- ANDROID\_HOME environment variable

#### Missing Android NDK [​](https://docs.solanamobile.com/react-native/expo\#missing-android-ndk "Direct link to Missing Android NDK")

If you are seeing errors about missing Android NDK, make sure you've installed Android NDK in Android Studio. You can do this following:
`File -> Project Structure -> SDK Location -> "Android NDK Location" -> Download Android NDK`

![ndk-download](https://docs.solanamobile.com/assets/images/ndk-download-c7adebb1cb08c1d5e77d7c02aff3f167.png)

#### Install the custom development build APK [​](https://docs.solanamobile.com/react-native/expo\#install-the-custom-development-build-apk "Direct link to Install the custom development build APK")

After successfully building locally, the APK should be generated and outputted to the same directory you ran the command. Install that APK into your device/emulator (drag and drop APK file into emulator).

#### Run the app [​](https://docs.solanamobile.com/react-native/expo\#run-the-app "Direct link to Run the app")

At this point, the APK should be installed onto your emulator or device. You can launch the app and connect it to the development client with:

```shell
npx expo start --dev-client
```

This will launch the template app and you can select the newly created development server. Now you can edit your code and see changes reflected immediately!

- [Expo Starter Template](https://docs.solanamobile.com/react-native/expo#expo-starter-template)
- [Manual Installation](https://docs.solanamobile.com/react-native/expo#manual-installation)
  - [Running the app](https://docs.solanamobile.com/react-native/expo#running-the-app)

## dApp Store Terms
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/tou#__docusaurus_skipToContent_fallback)

**Last Updated: December 3, 2025**

Solana Mobile Inc. (“ **Solana Mobile**”, “ **us**” or “ **we**”) provides a marketplace (our “ **dApp Store**”) through which you can purchase or otherwise access mobile decentralized applications (“ **Applications**,” as further defined below) that operate on, interact with or otherwise complement (i) Solana Mobile’s mobile operating system running on the Solana Mobile Phone (as defined below) (the “ **Operating System**”); and (ii) the Solana Network (as defined below).

THESE DAPP STORE TERMS OF USE (THE “ **DAPP STORE TERMS**” OR “ **AGREEMENT**”) GOVERN YOUR USE OF THE DAPP STORE. WHEN YOU DOWNLOAD AN APPLICATION FROM THE DAPP STORE OR OTHERWISE ACCESS AND/OR USE THE DAPP STORE, YOU ACKNOWLEDGE AND AGREE THAT YOU HAVE READ, UNDERSTAND, AND AGREE TO BE BOUND BY THESE DAPP STORE TERMS.

We may amend or modify these dApp Store Terms at any time and from time to time. When we modify these dApp Store Terms, we will update the “Last Updated” date on these dApp Store Terms. You are solely responsible for regularly reviewing these dApp Store Terms and any updates hereto. Any updates will be binding (i) for new users of the dApp Store, immediately upon publication, and (ii) for existing users of the dApp Store, the sooner of (a) the next time any such user connects to the dApp Store, or (b) thirty (30) days after the updated dApp Store Terms are published. If you do not agree to the terms set forth in these dApp Store Terms or any updates or modifications hereto, you may not access and use the dApp Store.

THE DAPP STORE IS A MARKETPLACE ON WHICH DEVELOPERS (AS DEFINED BELOW) CAN MAKE AVAILABLE AND SELL, AND USERS CAN PURCHASE, DOWNLOAD, OR OTHERWISE ACCESS, APPLICATIONS (DEFINED BELOW). SOLANA MOBILE MAY FACILITATE TRANSACTIONS BETWEEN A DEVELOPER AND YOU, BUT SOLANA MOBILE IS NOT A PARTY TO ANY AGREEMENT BETWEEN YOU AND ANY SUCH DEVELOPER. YOU AGREE THAT NONE OF SOLANA MOBILE, ITS PARENTS, SUBSIDIARIES, AFFILIATES, OFFICERS, EMPLOYEES, AGENTS, PARTNERS, SUPPLIERS, OR LICENSORS (EACH, A “ **SOLANA MOBILE PARTY**” AND COLLECTIVELY, THE “ **SOLANA MOBILE PARTIES**”) SHALL BE A PARTY TO OR HAVE ANY RESPONSIBILITY OR LIABILITY FOR, ARISING OUT OF, OR RESULTING FROM ANY DISPUTE BETWEEN YOU AND ANY DEVELOPER OR ANY OTHER USER OF THE DAPP STORE. THE SOLANA MOBILE PARTIES MAKE NO CLAIMS ABOUT THE FUNCTIONALITY OR AUTHENTICITY OF ANY APPLICATION OFFERED OR OTHERWISE MADE AVAILABLE ON OR THROUGH THE DAPP STORE.

**PLEASE BE AWARE THAT SECTION 15 (DISPUTES) OF THIS AGREEMENT, BELOW, CONTAINS PROVISIONS GOVERNING HOW DISPUTES THAT YOU AND WE HAVE AGAINST EACH OTHER ARE RESOLVED, INCLUDING, WITHOUT LIMITATION, ANY DISPUTES THAT AROSE OR WERE ASSERTED PRIOR TO THE EFFECTIVE DATE OF THIS AGREEMENT. IN PARTICULAR, SECTION 15 (DISPUTES) CONTAINS AN ARBITRATION AGREEMENT WHICH WILL, WITH LIMITED EXCEPTIONS, REQUIRE DISPUTES BETWEEN YOU AND ANY OF THE SOLANA MOBILE PARTIES TO BE SUBMITTED TO BINDING AND FINAL ARBITRATION. UNLESS YOU OPT OUT OF THE ARBITRATION AGREEMENT: (1) YOU WILL ONLY BE PERMITTED TO PURSUE DISPUTES OR CLAIMS AND SEEK RELIEF AGAINST THE SOLANA MOBILE PARTIES ON AN INDIVIDUAL BASIS, NOT AS A PLAINTIFF OR CLASS MEMBER IN ANY CLASS OR REPRESENTATIVE ACTION OR PROCEEDING; AND (2) YOU ARE WAIVING YOUR RIGHT TO PURSUE DISPUTES OR CLAIMS AND SEEK RELIEF IN A COURT OF LAW AND TO HAVE A JURY TRIAL.**

**PLEASE BE AWARE THAT SECTION 22.9 OF THIS AGREEMENT, BELOW, CONTAINS YOUR OPT-IN CONSENT TO RECEIVE COMMUNICATIONS FROM US.**

**NOTHING IN THESE TERMS AFFECTS YOUR STATUTORY LEGAL RIGHTS UNDER APPLICABLE LAW.**

1\. Definitions. The following definitions shall apply for the purposes of these dApp Store Terms:

1.1. “ **Application**” means a decentralized application that is compatible with the Operating System and the Solana Network and that is offered or otherwise made available for end users to download, purchase, or otherwise access in or through the dApp Store, and includes any products **and** services that may be made available through such Application.

1.2. “ **dApp Store User Interface**” means the interactive, visual components of the Operating System through which you view and interact with the dApp Store, whether made available to you on the Solana Mobile Phone or any other mobile device which supports such Operating System.

1.3. “ **Developer**” means, with respect to an Application, the developer or provider thereof. The Solana Mobile Parties are not the Developer of any Application except to the extent expressly identified as such in the dApp Store in connection with such Application.

1.4. “ **Digital Wallet**” means any software and associated user interface used by you (i) to store or interact with your Keypair (defined below) and/or (ii) to sign transactions on the Solana Network.

1.5. “ **Mnemonics**” refers to any series of words or characters utilized by you for the purpose of aiding in your decryption of a Private Key, Digital Wallet Data, or any other data.

1.6. “ **Private Key**” means a 256-bit number which can be asymmetrically applied to a 256-bit secure hash algorithm to yield an associated public key (together with the Private Key, a “ **Keypair**”), which Keypair can be used to (i) interact with Programs on the Solana Network and (ii) hold or store digital or crypto assets.

1.7. “ **Program**” means a discrete piece of software compatible or integrated with, or otherwise accessible through, the dApp Store or one or more Applications, and may include without limitation the following: (i) a smart contract, or networks of smart contracts, existing on the Solana Network, which may be interacted with through an Application; (ii) Operating System-level software pre-installed on the Solana Mobile Phone; and (iii) other independent software running on the Operating System, which you may not explicitly opt to download or otherwise interact with. A Program may be owned or made available by Solana Mobile or by a third party.

1.8. “ **Review**” means any User Content that you submit to or through the Reviews Feature.

1.9. “ **Reviews Feature**” means the portal on the dApp Store through which users may be able to submit Reviews and view other users’ Reviews, and Developers may be able to view and respond to such Reviews.

1.10. “ **Solana Mobile Phone**” means any mobile device offered, sold, or otherwise distributed by Solana Mobile which utilizes the Operating System.

1.11. “ **Solana Network**” means the permissionless digital blockchain network ledger known as Solana.

1.12. “ **Update**” means, with respect to the Solana Mobile Phone, Operating System, or any other Solana Mobile product made available by Solana Mobile, a new version or series of such product or service that is publicly released or otherwise generally made commercially available.

1.13. “ **User Content**” means any and all information and content, including, without limitation, comments, ratings, and Reviews, photos or videos, that a user submits to, or uses with, the dApp Store.

2\. Overview. If you purchase or obtain an Application, you will be purchasing or obtaining such Application directly from the Developer, not from a Solana Mobile Party, and your purchase and/or use thereof may be subject to additional terms and conditions as made available by such Developer. You acknowledge and agree that the Solana Mobile Parties have no responsibility or liability to you arising from or in connection with any Application with any other Program, including without limitation any such interaction that results in any: (i) loss of any digital or crypto asset; and (ii) loss of other rights or opportunities available to you on the Solana Network or any other decentralized network. For clarity, the Operating System includes all variations of the Operating System made available through any Solana Mobile Phone or any other mobile device running the Operating System and Updates thereto, or any of its variations, including such variations as may be developed by third party sources not controlled by and/or affiliated with the Solana Mobile Parties, but which variations nonetheless may provide you access to the dApp Store.

2.1. Third-Party Services. Certain features of the dApp Store may rely on third-party websites, services, technology, or applications accessible or otherwise connected to the dApp Store but not provided by Solana Mobile (each, a “ **Third-Party Service**” and, collectively, “ **Third-Party Services**”). Notwithstanding anything to the contrary in these dApp Store Terms, you acknowledge and agree that (i) the Solana Mobile Parties shall not be liable for any damages, liabilities, or other harms in connection with your use of and/or any inability to access the Third-Party Services; and (ii) the Solana Mobile Parties shall be under no obligation to inquire into and shall not be liable for any damages, other liabilities or harm to any person or entity relating to any losses, delays, failures, errors, interruptions, or loss of data occurring directly or indirectly by reason of Third-Party Services or any other circumstances beyond Solana Mobile’s control, including without limitation the failure of any Third-Party Service. You use all Third-Party Services at your own risk, and your use of such Third-Party Services shall be governed by separate terms and conditions set forth by the applicable third-party service provider. Third-Party Services are provided to you through the dApp Store for your convenience only. We do not and cannot verify, curate, or control any Third-Party Services. We do not guarantee, endorse, or recommend Third-Party Services. YOU ACKNOWLEDGE AND AGREE THAT THE SOLANA MOBILE PARTIES ARE NOT LIABLE, AND YOU AGREE NOT TO SEEK TO HOLD ANY OF THE SOLANA MOBILE PARTIES LIABLE, FOR THE CONDUCT OF THIRD PARTIES, INCLUDING OPERATORS OF THIRD-PARTY SERVICES, AND THAT THE RISK OF INJURY FROM SUCH THIRD PARTIES RESTS ENTIRELY WITH YOU. SOLANA MOBILE SHALL BE UNDER NO OBLIGATION TO INQUIRE INTO AND SHALL NOT BE LIABLE FOR ANY DAMAGES, OTHER LIABILITIES OR HARM TO ANY PERSON OR ENTITY RELATING TO ANY LOSSES, DELAYS, FAILURES, ERRORS, INTERRUPTIONS, OR LOSS OF DATA OCCURRING DIRECTLY OR INDIRECTLY BY REASON OF CIRCUMSTANCES BEYOND SOLANA MOBILE’S CONTROL, INCLUDING WITHOUT LIMITATION, ANY THIRD-PARTY SERVICES.

3\. Prioritized Applications. Solana Mobile may prioritize the display of certain Applications (the “ **Prioritized Applications**”) in the dApp Store User Interface from time to time. Prioritized Applications may be selected by Solana Mobile, or by other users of the dApp Store. Solana Mobile reserves the right (but shall have no obligation) to pre-screen, review, flag, filter, modify, refuse, or remove any or all Applications from the dApp Store, at any time and for any or no reason. You agree that by using the dApp Store you may be exposed to Applications, including Prioritized Applications, that you may find offensive, indecent, or objectionable, and that you use the dApp Store at your own risk. You agree that Solana Mobile does not make any representations and warranties with respect to any Prioritized Application.

4\. User Agreement; Representations and Warranties

4.1. When you use the dApp Store, including without limitation to propose, initiate, agree to, or complete a purchase of an Application, you acknowledge and agree to the following:

4.1.1. The Solana Mobile Parties are not an agent or intermediary of any user. The Solana Mobile Parties do not store or have access to or control over any of your digital or crypto assets or any of a user’s Keypair, passwords, Digital Wallets, or other property. The Solana Mobile Parties are not capable of performing transactions or sending transaction messages on behalf of any user.

4.1.2. The prices of digital or crypto assets can be extremely volatile. The Solana Mobile Parties cannot and do not guarantee that any digital or crypto asset will not lose value.

4.1.3. You are solely responsible for determining what, if any, taxes apply to your transactions involving any digital or crypto asset.

4.1.4. Digital or crypto asset exist and can be transferred only by virtue of the ownership record maintained on the Solana Network.

4.1.5. There are risks associated with using any digital or crypto asset, including but not limited to, the risk of hardware, software, and Internet connections, the risk of malicious software introduction, and the risk that third parties may obtain unauthorized access to your information.

4.1.6. The legal and regulatory regime governing blockchain technologies, cryptocurrencies, and tokens is evolving, and new regulations or policies may materially adversely affect the same.

4.2. When you use the dApp Store, you represent and warrant to and on behalf of the Solana Mobile Parties that:

4.2.1. You are (i) at least eighteen (18) years old; (ii) of legal age to form a binding contract; and (iii) not a person barred from using the dApp Store under the laws of the United States, your place of residence or any other applicable jurisdiction. If you are acting on behalf of a DAO or other entity, whether or not such entity is formally incorporated, you represent and warrant that you have all right and authority necessary to act on behalf of such entity;

4.2.2. You are sophisticated, experienced and knowledgeable in the selling, buying or staking of any digital or crypto asset, as applicable. Additionally, you have conducted an independent investigation of the dApp Store and the matters contemplated by this Agreement, have formed your own independent judgment regarding the benefits and risks of and necessary and desirable practices regarding the foregoing, and, in making the determination to engage in any transaction using the dApp Store, you have relied solely on the results of such investigation and such independent judgement. Without limiting the generality of the foregoing, you understand, acknowledge and agree that the legal requirements pertaining to blockchain technologies generally are uncertain, and you have conducted an independent investigation of such potentially applicable legal requirements and the resulting risks and uncertainties, including the risk that one or more governmental entities or other persons may assert that any digital or crypto asset may constitute securities under applicable legal requirements. You hereby irrevocably disclaim and disavow reliance upon any statements or representations made by or on behalf of, or information made available by, the Solana Mobile Parties, in determining to enter into this Agreement or use the dApp Store.

4.2.3. There are no legal proceedings pending that relate to your activities relating to any digital or crypto asset or other token-trading or blockchain technology related activities.

4.2.4. You have not failed to comply with, and have not violated, any applicable legal requirement relating to any blockchain technologies, token trading or staking activities or minting any digital or crypto asset. No investigations or reviews by any governmental entity are pending or, to your knowledge, has been threatened against or with respect to you, nor does any government order or action prohibit you or any of your representatives from engaging in or continuing any conduct, activity, or practice relating to minting or staking digital or crypto assets.

4.2.5. You are not, and you will not authorize, enable, or permit any use of the dApp Store by any person that is: (i) in, under the control of, or a national or resident of any jurisdiction subject to a U.S. trade embargo (currently, Cuba, Iran, North Korea, Syria, and the Crimea, Donetsk People’s Republic, and Luhansk People’s Republic regions of Ukraine); (ii) identified on any export- or sanctions-related restricted party list, including but not limited to the U.S. Department of the Treasury’s Specially Designated Nationals and Blocked Persons List or the U.S. Department of Commerce’s Denied Persons List, Unveriﬁed List, or Entity List.

4.2.6. If you are a purchaser or owner of a Solana Mobile Phone, you expressly agree to and, where applicable, reaffirm your agreement to the Solana Mobile Terms of Sale, located at [https://solanamobile.com/tos-web](https://solanamobile.com/tos-web) and any successor website.

4.3. Disclaimer of Representations and Warranties by Solana Mobile. YOU ACKNOWLEDGE AND AGREE THAT THE SOLANA MOBILE PARTIES MAKE NO REPRESENTATIONS OR WARRANTIES ABOUT ANY APPLICATION MADE AVAILABLE BY ANY THIRD-PARTY DEVELOPER THROUGH THE DAPP STORE. Without limiting the foregoing, you expressly acknowledge that the Solana Mobile Parties make no representations or warranties regarding (i) the timeframe that any Applications, including Prioritized Applications, will remain available for use by you, any of your counterparties within such Application, or the general public; (ii) the safety and security of any Applications, including Prioritized Applications (e.g., an Application that contains malicious code, an Application with exploitable flaws, etc.); (iii) the utility of any Application, including such Application’s ability to function as represented by the Developer, any other third party, or otherwise as commonly understood; (iv) the stability of any Application, including such Application’s capacity to operate without substantial bugs, glitches, or other software failures which may materially undermine such Application’s primary and/or stated functionality; or (v) any Application’s compatibility with your Solana Mobile Products, including any Updates thereto.

5\. User Content.

5.1. User Content. You assume all risks associated with any User Content, including any reliance on its accuracy, completeness, or usefulness by others, or any disclosure of your User Content that identifies you or any third party. You may not represent or imply to others that your User Content is in any way provided, sponsored, or endorsed by the Solana Mobile Parties. Because you are solely responsible for your User Content, you may incur liability if, for example, your User Content violates our Acceptable Use Policy (defined in Section 5.4) or applicable law. The Solana Mobile Parties are not obligated to review, monitor, store, or backup any User Content, and your User Content may be deleted at any time without prior notice.

5.2. Ownership of User Content. The Solana Mobile Parties do not own any User Content. Subject to Section 5.3, as between the Solana Mobile Parties and you, you own all right, title, and interest in and to your User Content.

5.3. License to Your Content. You hereby grant (and you represent and warrant that you have the right to grant) to Solana Mobile an irrevocable, perpetual, transferable, nonexclusive, royalty-free and fully paid, sublicensable (through multiple tiers of sublicensees) worldwide right, (including any moral rights) and license to use, copy, reproduce, modify, distribute, translate, publicly display, publicly perform, prepare derivative works of, incorporate into other works, and otherwise use and exploit your User Content, and to grant sublicenses of the foregoing rights, for any lawful purpose, including, without limitation, for the purposes of operating, improving, providing, advertising and promoting Solana, Solana Mobile, any of the Solana Mobile Parties, our hardware, software, products and services, including, without limitation, the dApp Store and related services. You hereby irrevocably waive (and agree to cause to be waived) any claims and assertions of moral rights or attribution with respect to your User Content. You further represent and warrant that your User Content is accurate, that the use of your User Content does not violate these dApp Store Terms or any applicable law, and your User Content will not cause injury to any person or entity. You agree to indemnify and hold harmless Solana Mobile for all claims resulting from your User Content. You acknowledge that Solana Mobile may utilize certain artificial intelligence tools, including third-party artificial intelligence tools (“ **AI Tools**”), including without limitation to moderate and train on Reviews. Accordingly, you acknowledge that your User Content may be used by Solana Mobile, or third-party providers of AI Tools, to train, develop, enhance, evolve, and improve AI Tools and other artificial intelligence models, algorithms, and related technology, products, and services.

5.4. Acceptable Use Policy. The following terms constitute our “ **Acceptable Use Policy**”. You agree not to, directly or indirectly, cause, permit, take any action or make available any User Content that would or could:

5.4.1. upload, transmit, or distribute any computer viruses, worms, or any software intended to damage or alter a computer system or data;

5.4.2. send unsolicited or unauthorized advertising, promotional materials, junk mail, spam, chain letters, pyramid schemes, or any other form of duplicative or unsolicited messages, whether commercial or otherwise;

5.4.3. abuse other users’ personal information, such as to harvest, collect, gather, or assemble information or data regarding other users, including e-mail addresses, without their consent;

5.4.4. interfere with, disrupt, or create an undue burden on servers or networks, or violate the regulations, policies, or procedures of such networks;

5.4.5. attempt to gain unauthorized access to any systems, networks, products or services, whether through password mining or any other means;

5.4.6. interfere with any other user’s use and enjoyment of any systems, networks, products or services;

5.4.7. request or offer to perform a request that is illegal or violates any of the terms set forth herein;

5.4.8. impersonate any person or entity, including any employee or representative of the Solana Mobile Parties;

5.4.9. use software or automated agents or scripts to generate automated searches, requests, or queries (or to strip, scrape, or mine data); provided, however, that we may conditionally grant to the operators of public search engines revocable permission to use spiders to copy materials from the dApp Store for the sole purpose of and solely to the extent necessary for creating publicly available searchable indices of the materials, but not caches or archives of such materials;

5.4.10. use or attempt to use a Digital Wallet without authorization;

5.4.11. create, list, or otherwise make available counterfeit digital assets;

5.4.12. attempt to circumvent any content-filtering techniques we employ, or attempt to access any feature or area of the dApp Store that you are not authorized to access;

5.4.13. use the dApp Store for any illegal or unauthorized purpose, or engage in, encourage, or promote any activity that violates any applicable law or this Agreement, including but not limited to money laundering, terrorist financing, or deliberately engaging in activities designed to adversely affect the performance of any such offering;

5.4.14. engage in or knowingly facilitate any “front-running,” “wash trading,” “pump and dump trading,” “ramping,” “cornering,” or fraudulent, deceptive, or manipulative trading activities;

5.4.15. promote, market, or advertise any token or other digital asset on or through the dApp Store, including without limitation in any Review;

5.4.16. use the dApp Store to carry out any financial activities subject to registration or licensing, including but not limited to using the dApp Store to transact in or promote transactions in securities, debt financings, equity financings, or other similar transactions; or

5.4.17. use the dApp Store to participate or promote participation in fundraising for a business, protocol, or platform, including but not limited to creating, listing, or buying assets that (i) are redeemable for financial instruments, (ii) give owner’s rights to participate in an ICO or any securities offering, or (iii) entitle owners to financial rewards, including but not limited to, DeFi yield bonuses, staking bonuses, and burn discounts.

6\. Review Policy. The dApp Store may allow you to submit Reviews. You hereby represent and warrant that your Reviews do not violate our [dApp Store Review Policy](https://solanamobile.com/review-policy), which may be updated from time to time. Solana Mobile has the right, but not the obligation, to monitor and remove or edit any Reviews, including via AI Tools, automated content filters, and/or human review. If we become aware of Reviews that violate our [dApp Store Review Policy](https://solanamobile.com/review-policy), we reserve the right to prevent such user from leaving other Reviews, and/or block such user from the dApp Store, in our sole discretion.

7\. Security. You acknowledge and agree that the Solana Mobile Parties have no obligation to, and may not, verify or screen for any security features of any Applications made available on or through the dApp Store, including without limitation Prioritized Applications. Such features include, but are not limited to: (i) the encryption and management of your Private Key; (ii) any Mnemonics used to encrypt your Private Key; (iii) any other passwords, keys, and encryption devices used to obtain and/or protect your Private Key; as well as (iv) any other sensitive data, the loss of which could lead to negative economic, or other, consequences for you. You agree that your use of the dApp Store may expose you to Applications with a range of possible security vulnerabilities, resulting in (a) malicious theft of your Private Key; (b) use of your Private Key for staking or other economic or community purposes not authorized or intended by you; and (c) use of your Private Key for the exploitation of bugs or other vulnerabilities in the Applications or the Solana Network, and that you use the dApp Store at your own risk. You expressly acknowledge and agree that all use of the dApp Store and any Applications made available thereby or therethrough is at your own risk, and that Solana Mobile makes no representations or warranties regarding the security or safety of any Applications, or of the interaction of any Application with any Program.

8\. EULA. Your access to and use of any Application will be subject to any applicable agreement made available by the Developer for such Application (“ **EULA**”). The EULA will govern the Applications and be directly between you and Developer. Solana Mobile is not a party to the EULA. In the event of any conflict between these dApp Store Terms and any EULA, the terms of these dApp Store Terms will take precedence, but solely to the extent of such conflict. Applications shall be used solely within the Operating System and solely by the user who purchased or otherwise acquired such Application. You will not copy, publish, transmit, distribute, transfer, or sell any Application you have accessed through dApp Store for any purpose, unless otherwise explicitly permitted by the applicable Developer. In certain cases, a Developer may terminate its provision of Applications to the dApp Store. The Solana Mobile Parties have no responsibility to ensure that this termination process takes place in the manner stipulated by Developer, and you agree and acknowledge that the Solana Mobile Parties cannot control the Developers or Applications, makes no commitment about the future availability of any Application, and shall have no liability to you arising from any such termination. Notwithstanding any failure by any Developer to provide a EULA to you (either directly, through the dApp Store, or through such Developer’s website or other publicly accessible display), Solana Mobile shall not be a party to any agreement between you and any Developer, whether express or implied.

9\. Wallet Connection. You may be required to use a Digital Wallet in order to use certain features of the dApp Store and interact with Applications, including without limitation to: (i) effect purchases of Applications on the dApp Store; (ii) interact with Programs through Applications, including without limitation to purchase any digital or crypto asset; and (iii) interact with third-party digital networks that are interoperable with the Solana Network protocol. Any such Digital Wallet, its security, the Private Key such Digital Wallet encrypts, any Mnemonics used by you to access or utilize your Private Key, and any other private or public data held, or purported to be held, by such Digital Wallet (collectively, the “ **Digital Wallet Data**”) remain your sole responsibility, and the Solana Mobile Parties shall have no responsibility or liability to you or any third party in connection with the same. The Solana Mobile Parties make no representations or warranties with regard to the Digital Wallet Data, or any loss of such data resulting from your interaction with the dApp Store or any Applications downloaded from the dApp Store, including the permanent loss of all digital or crypto asset or any other assets stored in or held by such Digital Wallet.

10\. Fees. Some Applications may be made available to you by the applicable Developer at no charge while your access to and use of other Applications may be subject to a fee (a “ **dApp Fee**”). Your continued use of and interaction with an Application or Programs or featured enabled by or through such Application may also be subject to additional fees charged by the Developer of such Application (such fees, together with the dApp Fees, the “ **Application Fees**”). Application Fees are set by and payable to the Developer of the respective Application.

10.1. Payment. Application Fees may be payable in a specific form of digital or crypto asset, in each case as set forth at point of sale. You agree to pay all Application Fees or other charges with your Digital Wallet in accordance with the Application Fees and billing terms in effect at the time an Application Fee is charged. You are solely responsible for ensuring that your Digital Wallet contains sufficient assets to complete any transaction entered into by you and to pay all Application Fees that you have contracted to pay. If your Digital Wallet does not have the requisite amount of the applicable digital or crypto asset to pay a particular Application Fee, the Developer may terminate your access to the applicable Application or other purchased product or service. Application Fees, including dApp Fees, are subject to change at any time. YOU ARE SOLELY RESPONSIBLE FOR THE TIMELY PAYMENT OF ALL APPLICATION FEES. Application Fees are, unless otherwise altered by a Program, irreversible. Notwithstanding any stipulations made to you by the Developer or under the EULA, Solana Mobile has no obligation to return or refund any Application Fees for any reason. Further, Solana Mobile has no obligation to reverse any Application Fee transaction, including to the extent that such Application Fees are charged subject to fraud, theft, or abuse by the Developer or by any other third party. Additional terms related to Application Fees may apply, as set forth in any EULA and any other agreements between you and the Developer.

10.2. Transactions Effected Through a Digital Wallet. In order to be successfully completed, any transaction involving a digital or crypto asset must be confirmed by and recorded on the Solana Network. The Solana Mobile Parties have no control over the Solana Network and cannot and do not ensure that any transaction details that you submit or receive via the dApp Store will be validated by or confirmed on the Solana Network. You accept and acknowledge that you take full responsibility for all activities that you effect through your Digital Wallet and accept all risks of loss, including loss as a result of any authorized or unauthorized access to your Digital Wallet, to the maximum extent permitted by law.

11\. Copyright Policy and DMCA.

11.1. Solana Mobile respects the intellectual property of others and asks that users of our dApp Store do the same. We have adopted and implemented a policy that provides for the removal of any infringing materials and for the termination, in appropriate circumstances, of users of our dApp Store who may repeatedly violate intellectual property rights. If you believe that one of our users is unlawfully infringing the copyright(s) in a work, and wish to have the allegedly infringing material removed, the following information in the form of a written notification (pursuant to 17 U.S.C. § 512(c)) must be provided to our designated Copyright Agent:

11.1.1. a physical or electronic signature of the person authorized to act on behalf of the owner of the copyright interest;

11.1.2. a description of the copyrighted work(s) that you claim to have been infringed;

11.1.3. a description of the material on our dApp Store that you claim is infringing and that you request us to remove and sufficient information to permit us to locate such material;

11.1.4. your address, telephone number, and e-mail address;

11.1.5. a statement that you have a good faith belief that use of the objectionable material is not authorized by the copyright owner, its agent, or under the law; and

11.1.6. a statement by you, made under the penalty of perjury, that the information in the notification is accurate and that you are either the owner of the copyright that has allegedly been infringed or that you are authorized to act on behalf of the copyright owner.

11.2. Please note that, pursuant to 17 U.S.C. § 512(f), any misrepresentation of material fact in a written notification automatically subjects the complaining party to liability for any damages, costs, and attorneys’ fees incurred by us in connection with the written notification and allegation of copyright infringement. Contact information for Solana Mobile’s Copyright Agent for notice of claims of copyright infringement is as follows: Copyright Agent, 605 N Michigan Ave, Floor 4 #1478783, Chicago, IL 60611; [dmcacopyrightagent@solanamobile.com](mailto:dmcacopyrightagent@solanamobile.com).

12\. Privacy. Your use of the dApp Store is subject to Solana Mobile’s dApp Store Privacy Policy (found at [https://solanamobile.com/privacy-policy-web](https://solanamobile.com/privacy-policy-web)).

13\. Support. Any request for support related to any Application should be directed to the applicable Developer. In the event that any issues arise related to your use of the dApp Store (and not related to any Application), you may direct any feedback to Solana Mobile by sending an email to [concerns@dappstore.solanamobile.com](mailto:concerns@dappstore.solanamobile.com). Solana Mobile reserves the right, but has no obligation, to respond to any such feedback or issues.

14\. Cancellation; Removal of Applications. If technical problems prevent or unreasonably delay delivery of any Application or other product, you acknowledge and agree that the Solana Mobile Parties do not provide any technical support or assistance for such issues, the Solana Mobile Parties bear no responsibility or liability for resolving any technical problems, and you may have no remedy or recourse to seek the return of your Application Fees from the Developer. From time to time, Solana Mobile may discover an Application in the dApp Store that it determines in its sole discretion violates Solana Mobile’s policies, another legal agreement, or applicable law, regulation, and/or policy. You agree that in such event, Solana Mobile retains the right to immediately (i) remove such Application from the dApp Store and (ii) remove such Application from your Solana Mobile Phone (or other mobile device or Solana Mobile product), after its download. The Solana Mobile Parties have no liability for any losses you may incur as a result of any such removal and has no obligation to remove any software, including any malware. Given the decentralized nature of the Solana Network, Solana Mobile may be unable to remove the Programs associated with such Application from the Solana Network.

15\. Disputes.  Please read this Arbitration Agreement (the “ **Arbitration Agreement**”) carefully. IT IS PART OF YOUR CONTRACT WITH SOLANA MOBILE AND AFFECTS YOUR RIGHTS. IT CONTAINS PROCEDURES FOR MANDATORY BINDING ARBITRATION AND A CLASS ACTION WAIVER (INCLUDING WITHOUT LIMITATION INVOLVING ANY DISPUTE WITH THE SOLANA MOBILE PARTIES).

15.1. Applicability of Arbitration Agreement. Subject to the terms of this Arbitration Agreement, and to the extent that it is not unenforceable, unlawful or unfair under applicable laws, you and Solana Mobile (including on behalf of the Solana Mobile Parties) agree that any dispute, claim, disagreements arising out of or relating in any way to your access to or use of the dApp Store, any communications you receive from us, or these dApp Store Terms and prior versions of these dApp Store Terms, including claims and disputes that arose between us before the effective date of these dApp Store Terms (each, a “ **Dispute**”) will be resolved by binding arbitration, rather than in court, except that: (i) you and the Solana Mobile Parties may assert claims or seek relief in small claims court if such claims qualify and remain in small claims court; and (ii) you or the Solana Mobile Parties may seek equitable relief in court for infringement or other misuse of intellectual property rights (such as trademarks, trade dress, domain names, trade secrets, copyrights, and patents). For purposes of this Arbitration Agreement, “Dispute” will also include disputes that arose or involve facts occurring before the existence of this or any prior versions of these dApp Store Terms as well as claims that may arise after the termination of these dApp Store Terms.

15.2. Informal Dispute Resolution. There might be instances when a Dispute arises between you and a Solana Mobile Party. If that occurs, Solana Mobile states (including on behalf of the Solana Mobile Parties) that the applicable Solana Mobile Party is committed to working with you to reach a reasonable resolution. Solana Mobile (including on behalf of the Solana Mobile Parties) and You agree that good faith informal efforts to resolve Disputes can result in a prompt, low‐cost and mutually beneficial outcome. Solana Mobile (including on behalf of the Solana Mobile Parties) and You therefore agree that, to the extent that it is not unenforceable, unlawful or unfair under applicable laws, before a party commences arbitration against the other (or initiates an action in small claims court if a party so elects), the parties will personally meet and confer telephonically or via videoconference, in a good faith effort to resolve informally any Dispute covered by this Arbitration Agreement (“ **Informal Dispute Resolution Conference**”); provided, however, that any Solana Mobile Party may waive the requirement to engage in an Informal Dispute Resolution Conference. If you are represented by counsel, your counsel may participate in the conference, but you will also participate in the conference. The party initiating a Dispute must give notice to the other party in writing of its intent to initiate an Informal Dispute Resolution Conference (“ **Notice**”), which shall occur within 45 days after the other party receives such Notice, unless an extension is mutually agreed upon by the parties. Notice to any Solana Mobile Party that you intend to initiate an Informal Dispute Resolution Conference should be sent by email or regular mail to our offices located at the address set forth below. The Notice must include: (i) your name, telephone number, mailing address, e‐mail address and/or Digital Wallet address associated with your access to the dApp Store (if applicable); (ii) the name, telephone number, mailing address and e‐ mail address of your counsel, if any; and (iii) a description of your Dispute. The Informal Dispute Resolution Conference shall be individualized such that a separate conference must be held each time either party initiates a Dispute, even if the same law firm or group of law firms represents multiple users in similar cases, unless all parties agree; multiple individuals initiating a Dispute cannot participate in the same Informal Dispute Resolution Conference unless all parties agree. In the time between a party receiving the Notice and the Informal Dispute Resolution Conference, nothing in this Arbitration Agreement shall prohibit the parties from engaging in informal communications to resolve the initiating party’s Dispute. Engaging in the Informal Dispute Resolution Conference is a condition precedent and requirement that must be fulfilled before commencing arbitration. The statute of limitations and any filing fee deadlines shall be tolled while the parties engage in the Informal Dispute Resolution Conference process required by this section.

15.3. Waiver of Jury Trial. TO THE EXTENT THAT IT IS NOT UNENFORCEABLE, UNLAWFUL OR UNFAIR UNDER APPLICABLE LAWS, THE SOLANA MOBILE PARTIES AND YOU HEREBY WAIVE ANY CONSTITUTIONAL AND STATUTORY RIGHTS TO SUE IN COURT AND HAVE A TRIAL IN FRONT OF A JUDGE OR A JURY. You and the Solana Mobile Parties are instead electing that all Disputes shall be resolved by arbitration under this Arbitration Agreement, except as specified in Section 15.1. There is no judge or jury in arbitration, and court review of an arbitration award is subject to very limited review. For the avoidance of doubt, to the extent any action is heard in court for any reason, you and the Solana Mobile Parties will still not be entitled to a jury.

15.4. Waiver of Class and Other Non-Individualized Relief. TO THE EXTENT THAT IT IS NOT UNENFORCEABLE, UNLAWFUL OR UNFAIR UNDER APPLICABLE LAWS, AND EXCEPT AS SPECIFIED IN SECTION 15.9, THE SOLANA MOBILE PARTIES AND YOU MAY BRING CLAIMS AGAINST THE OTHER ONLY ON AN INDIVIDUAL BASIS AND NOT ON A CLASS, REPRESENTATIVE, OR COLLECTIVE BASIS, AND THE SOLANA MOBILE PARTIES AND YOU HEREBY WAIVE ALL RIGHTS TO HAVE ANY DISPUTE BE BROUGHT, HEARD, ADMINISTERED, RESOLVED, OR ARBITRATED ON A CLASS, COLLECTIVE, REPRESENTATIVE, OR MASS ACTION BASIS IN ANY ARBITRAL, COURT, OR OTHER FORUM. EXCEPT AS SPECIFIED IN SECTION 15.9, ONLY INDIVIDUAL RELIEF IS AVAILABLE, AND DISPUTES OF MORE THAN ONE CUSTOMER OR USER CANNOT BE ARBITRATED OR CONSOLIDATED WITH THOSE OF ANY OTHER CUSTOMER OR USER. Subject to this Arbitration Agreement, the arbitrator may award declaratory or injunctive relief only in favor of the individual party seeking relief and only to the extent necessary to provide relief warranted by the party’s individual claim. Nothing in this paragraph is intended to, nor shall it, affect the terms and conditions under Section 15.9. Notwithstanding anything to the contrary in this Arbitration Agreement, if a court decides by means of a final decision, not subject to any further appeal or recourse, that the limitations of this section are invalid or unenforceable as to a particular claim or request for relief (such as a request for public injunctive relief), that particular claim or request for relief (and only that particular claim or request for relief) shall be severed from the arbitration and may be litigated on an individual basis in the state or federal courts located in the State of New York. All other Disputes shall be arbitrated or litigated in small claims court. This section does not prevent you or a Solana Mobile Party from participating in a class-wide settlement of claims.

15.5. Rules and Forum. These dApp Store Terms evidence a transaction involving interstate commerce; and notwithstanding any other provision herein with respect to the applicable substantive law, the Federal Arbitration Act, 9 U.S.C. § 1 et seq., will govern the interpretation and enforcement of this Arbitration Agreement and any arbitration proceedings. If the Informal Dispute Resolution Conference process described above does not resolve satisfactorily within sixty (60) days after receipt of your Notice, the Solana Mobile Party and You, as applicable, shall have the right to finally resolve the Dispute through binding arbitration. The arbitration will be administered by the American Arbitration Association (“ **AAA**”), in accordance with the Consumer Arbitration Rules (the “ **AAA Rules**”) then in effect, except as modified by this section of this Arbitration Agreement. The AAA Rules are currently available at [https://www.adr.org/media/yawntdvs/ 2025\_consumer\_arbitration\_rules.pdf](https://www.adr.org/media/yawntdvs/2025_consumer_arbitration_rules.pdf). A party who wishes to initiate arbitration must provide the other party with a request for arbitration (the “ **Request**”). The Request must include: (i) the name, telephone number, mailing address, email address of the party seeking arbitration (if applicable) as well as the email address and/or Digital Wallet associated with your use of the dApp Store; (ii) a statement of the legal claims being asserted and the factual bases of those claims; (iii) a description of the remedy sought and an accurate, good-faith calculation of the amount in controversy in United States Dollars; (iv) a statement certifying completion of the Informal Dispute Resolution Conference process as described above; and (v) evidence that the requesting party has paid any necessary filing fees in connection with such arbitration. If the party requesting arbitration is represented by counsel, the Request shall also include counsel’s name, telephone number, mailing address, and email address. Such counsel must also sign the Request. By signing the Request, counsel certifies to the best of counsel’s knowledge, information, and belief, formed after an inquiry reasonable under the circumstances, that: (a) the Request is not being presented for any improper purpose, such as to harass, cause unnecessary delay, or needlessly increase the cost of dispute resolution; (b) the claims, defenses and other legal contentions are warranted by existing law or by a nonfrivolous argument for extending, modifying, or reversing existing law or for establishing new law; and (c) the factual and damages contentions have evidentiary support or, if specifically so identified, will likely have evidentiary support after a reasonable opportunity for further investigation or discovery. Unless you and the applicable Solana Mobile Party otherwise agree, or the Batch Arbitration process discussed in Section 15.9 is triggered, the arbitration will be conducted in the county where you reside. Subject to the AAA Rules, the arbitrator may direct a limited and reasonable exchange of information between the parties, consistent with the expedited nature of the arbitration. If the AAA is not available to arbitrate, the parties will select an alternative arbitral forum. Your responsibility to pay any AAA fees and costs will be solely as set forth in the applicable AAA Rules. All materials and documents exchanged during the arbitration proceedings shall be kept confidential and shall not be shared with anyone except the parties’ attorneys, accountants, or business advisors, and then subject to the condition that they agree to keep all materials and documents exchanged during the arbitration proceedings confidential.

15.6. Arbitrator. The arbitrator will be either a retired judge or an attorney licensed to practice law in the state of New York and will be selected by the parties from the AAA’s roster of consumer dispute arbitrators. If the parties are unable to agree upon an arbitrator within thirty-five (35) days of delivery of the Request, then the AAA will appoint the arbitrator in accordance with the AAA Rules, provided that if the Batch Arbitration process under Section 15.9 is triggered, the AAA will appoint the arbitrator for each batch.

15.7. Authority of Arbitrator. To the extent that it is not unenforceable, unlawful or unfair under applicable laws, the arbitrator shall have exclusive authority to resolve any Dispute, including, without limitation, disputes arising out of or related to the interpretation or application of the Arbitration Agreement, including the enforceability, revocability, scope, or validity of the Arbitration Agreement or any portion of the Arbitration Agreement, except for the following: (i) all Disputes arising out of or relating to Section 15.4 including any claim that all or part of Section 15.4 is unenforceable, illegal, void or voidable, or that Section 15.4 has been breached, shall be decided by a court of competent jurisdiction and not by an arbitrator; (ii) except as expressly contemplated in Section 15.9, all Disputes about the payment of arbitration fees shall be decided only by a court of competent jurisdiction and not by an arbitrator; (iii) all Disputes about whether either party has satisfied any condition precedent to arbitration shall be decided only by a court of competent jurisdiction and not by an arbitrator; and (iv) all Disputes about which version of the Arbitration Agreement applies shall be decided only by a court of competent jurisdiction and not by an arbitrator. The arbitration proceeding will not be consolidated with any other matters or joined with any other cases or parties, except as expressly provided in Section 15.9. The arbitrator shall have the authority to grant motions dispositive of all or part of any Dispute. The arbitrator shall issue a written award and statement of decision describing the essential findings and conclusions on which the award is based, including the calculation of any damages awarded. The award of the arbitrator is final and binding upon you and us. Judgment on the arbitration award may be entered in any court having jurisdiction.

15.8. Attorneys’ Fees and Costs. The parties shall bear their own attorneys’ fees and costs in arbitration unless the arbitrator finds that either the substance of the Dispute or the relief sought in the Request was frivolous or was brought for an improper purpose (as measured by the standards set forth in Federal Rule of Civil Procedure 11(b)). If you or a Solana Mobile Party need to invoke the authority of a court of competent jurisdiction to compel arbitration, then the party that obtains an order compelling arbitration in such action shall have the right to collect from the other party its reasonable costs, necessary disbursements, and reasonable attorneys’ fees incurred in securing an order compelling arbitration. The prevailing party in any court action relating to whether either party has satisfied any condition precedent to arbitration, including the Informal Dispute Resolution Conference process, is entitled to recover their reasonable costs, necessary disbursements, and reasonable attorneys’ fees and costs.

15.9. Batch Arbitration. To increase the efficiency of administration and resolution of arbitrations, and to the extent that it is not unenforceable, unlawful or unfair under applicable laws, in the event that there are one hundred (100) or more individual Requests or other demand of a substantially similar nature filed against any Solana Mobile Party collectively by or with the assistance of the same law firm, group of law firms, or organizations, within a thirty (30) day period (or as soon as possible thereafter), the AAA shall (i) administer the arbitration demands in batches of 100 Requests per batch (plus, to the extent there are less than 100 Requests left over after the batching described above, a final batch consisting of the remaining Requests); (ii) appoint one arbitrator for each batch; and (iii) provide for the resolution of each batch as a single consolidated arbitration with one set of filing and administrative fees due per side per batch, one procedural calendar, one hearing (if any) in a place to be determined by the arbitrator, and one final award (“ **Batch Arbitration**”). All parties agree that Requests are of a “substantially similar nature” if they arise out of or relate to the same event or factual scenario and raise the same or similar legal issues and seek the same or similar relief. To the extent the parties disagree on the application of the Batch Arbitration process, the disagreeing party shall advise the AAA, and the AAA shall appoint a sole standing arbitrator to determine the applicability of the Batch Arbitration process (“ **Administrative Arbitrator**”). In an effort to expedite resolution of any such dispute by the Administrative Arbitrator, the parties agree the Administrative Arbitrator may set forth such procedures as are necessary to resolve any disputes promptly. The Administrative Arbitrator’s fees shall be paid by the Solana Mobile Parties. You and Solana Mobile (including on behalf of the Solana Mobile Parties) agree to cooperate in good faith with the AAA to implement the Batch Arbitration process including the payment of single filing and administrative fees for batches of Requests, as well as any steps to minimize the time and costs of arbitration, which may include: (a) the appointment of a discovery special master to assist the arbitrator in the resolution of discovery disputes; and (b) the adoption of an expedited calendar of the arbitration proceedings. This Batch Arbitration provision shall in no way be interpreted as authorizing a class, collective and/or mass arbitration or action of any kind, or arbitration involving joint or consolidated claims under any circumstances, except as expressly set forth in this provision.

15.10. 30-Day Right to Opt Out. You have the right to opt out of the provisions of this Arbitration Agreement by sending written notice of your decision to opt out to the contact information set forth below, within thirty (30) days after first becoming subject to this Arbitration Agreement. Your notice must include your name and address, the email address and/or Digital Wallet you used to interact with the dApp Store (if applicable), and an unequivocal statement that you want to opt out of this Arbitration Agreement. If you opt out of this Arbitration Agreement, all other parts of these dApp Store Terms will continue to apply to you. Opting out of this Arbitration Agreement has no effect on any other arbitration agreements that you may currently have, or may enter in the future, with us.

15.11. Invalidity, Expiration. Except as provided Section 15.4, if any part or parts of this Arbitration Agreement are found under the law to be unfair, unlawful, invalid or unenforceable, then such specific part or parts shall be of no force and effect and shall be severed and the remainder of the Arbitration Agreement shall continue in full force and effect. To the fullest extent permitted by applicable law, you and the Solana Mobile Parties further agree that any Dispute must be initiated via arbitration within one-year after the cause of action accrues; otherwise, such cause of action is forever time barred.

15.12. Modification. Notwithstanding any provision in these dApp Store Terms to the contrary, we agree that if Solana Mobile makes any future material change to this Arbitration Agreement, it will notify you. Unless you reject the change within thirty (30) days of such change become effective by writing to Solana Mobile at the contact information set forth below, your continued use of the dApp Store following the posting of changes to this Arbitration Agreement constitutes your acceptance of any such changes. To the extent that it is not unenforceable, unlawful or unfair under applicable laws, changes to this Arbitration Agreement do not provide you with a new opportunity to opt out of the Arbitration Agreement if you have previously agreed to a version of these dApp Store Terms and did not validly opt out of arbitration. If you reject any change or update to this Arbitration Agreement, and you were bound by an existing agreement to arbitrate Disputes arising out of or relating in any way to your access to or use of the dApp Store, any communications you receive, or these dApp Store Terms, the provisions of this Arbitration Agreement as of the date you first accepted these dApp Store Terms (or accepted any subsequent changes to these dApp Store Terms) remain in full force and effect. The Solana Mobile Parties will continue to honor any valid opt outs of the Arbitration Agreement that you made to a prior version of these dApp Store Terms.

15.13. Confidentiality. All aspects of the arbitration proceeding, including but not limited to the award of the arbitrator and compliance therewith, shall be strictly confidential. The parties agree to maintain confidentiality unless otherwise required by law. This paragraph shall not prevent a party from submitting to a court of law any information necessary to enforce these dApp Store Terms, to enforce an arbitration award, or to seek injunctive or equitable relief.

15.14. Survival of Agreement. This Arbitration Agreement will survive the termination of your relationship with Solana Mobile.

16\. Release. You hereby release and forever discharge the Solana Mobile Parties from, and hereby waive and relinquish, each and every past, present, and future dispute, claim, controversy, demand, right, obligation, liability, action, and cause of action of every kind and nature (including personal injuries, death, and property damage), that has arisen or arises directly or indirectly out of, or that relates directly or indirectly to, the dApp Store (including any interactions with, or act or omission of, any Developer or any other user of the dApp Store). YOU HEREBY WAIVE CALIFORNIA CIVIL CODE SECTION 1542, OR ANY SIMILAR LAW OR RULE OF ANY OTHER JURISDICTION, WHICH STATES IN SUBSTANCE: “A GENERAL RELEASE DOES NOT EXTEND TO CLAIMS THAT THE CREDITOR OR RELEASING PARTY DOES NOT KNOW OR SUSPECT TO EXIST IN HIS OR HER FAVOR AT THE TIME OF EXECUTING THE RELEASE AND THAT, IF KNOWN BY HIM OR HER, WOULD HAVE MATERIALLY AFFECTED HIS OR HER SETTLEMENT WITH THE DEBTOR OR RELEASED PARTY.”

17\. Complaints. In accordance with California Civil Code §1789.3, you may report complaints to the Complaint Assistance Unit of the Division of Consumer Services of the California Department of Consumer Affairs by contacting them in writing at 1625 North Market Blvd., Suite N 112, Sacramento, CA 95834, or by telephone at (800) 952-5210.

18\. Indemnification. To the fullest extent permitted by applicable law, you agree to indemnify, defend, and hold harmless Solana Mobile and the Solana Mobile Parties from and against all actual or alleged third party claims, damages, awards, judgments, losses, liabilities, obligations, penalties, interest, fees, expenses (including, without limitation, attorneys’ fees and expenses), and costs (including, without limitation, court costs, costs of settlement, and costs of or associated with pursuing indemnification and insurance), of every kind and nature whatsoever arising out of or related to these dApp Store Terms or your use of the dApp Store, whether known or unknown, foreseen or unforeseen, matured or unmatured, or suspected or unsuspected, in law or equity, whether in tort, contract, or otherwise (collectively, “ **Claims**”), including, but not limited to, damages to property or personal injury, that are caused by, arise out of or are related to: (i) your use or misuse of the dApp Store, or any Application enabled thereby; (ii) any feedback you provide to us; (iii) your violation of these dApp Store Terms; or (iv) your violation of the rights of any third party, including a Developer. You agree to promptly notify Solana Mobile of any third-party Claims and cooperate with the Solana Mobile Parties in defending such Claims. You further agree that the applicable Solana Mobile Party shall have control of the defense or settlement of any third-party Claims. THIS INDEMNITY IS IN ADDITION TO, AND NOT IN LIEU OF, ANY OTHER INDEMNITIES SET FORTH IN A SEPARATE WRITTEN AGREEMENT BETWEEN YOU AND SOLANA MOBILE.

19\. Disclaimers. THE DAPP STORE AND ALL CONTENT AND INFORMATION MADE AVAILABLE BY SOLANA MOBILE THEREIN IS PROVIDED ON AN “AS IS” AND “AS AVAILABLE” BASIS WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED. THE SOLANA MOBILE PARTIES MAKE NO WARRANTY THAT THE DAPP STORE: (i) WILL MEET YOUR REQUIREMENTS; (ii) WILL BE AVAILABLE ON AN UNINTERRUPTED, TIMELY, SECURE, OR ERROR-FREE BASIS; OR (iii) WILL BE ACCURATE, RELIABLE, COMPLETE, LEGAL, OR SAFE. SOLANA MOBILE DISCLAIMS ALL OTHER WARRANTIES OR CONDITIONS, EXPRESS OR IMPLIED, INCLUDING, WITHOUT LIMITATION, IMPLIED WARRANTIES OR CONDITIONS OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE, AND NON- INFRINGEMENT AS TO THE DAPP STORE OR ANY CONTENT CONTAINED THEREIN. THE SOLANA MOBILE PARTIES DO NOT REPRESENT OR WARRANT THAT CONTENT (INCLUDING WITHOUT LIMITATION ANY APPLICATIONS) ON THE DAPP STORE IS ACCURATE, COMPLETE, RELIABLE, CURRENT, OR ERROR-FREE. THE SOLANA MOBILE PARTIES WILL NOT BE LIABLE FOR ANY LOSS OF ANY KIND FROM ANY ACTION TAKEN OR TAKEN IN RELIANCE ON MATERIAL OR INFORMATION, CONTAINED ON THE DAPP STORE. THE SOLANA MOBILE PARTIES CANNOT AND DO NOT REPRESENT OR WARRANT THAT THE DAPP STORE OR ANY APPLICATIONS LISTED ON THE DAPP STORE ARE FREE OF VIRUSES OR OTHER HARMFUL COMPONENTS. THE SOLANA MOBILE PARTIES CANNOT GUARANTEE THE SECURITY OF ANY DATA THAT YOU DISCLOSE ONLINE. YOU ACCEPT THE INHERENT SECURITY RISKS OF PROVIDING INFORMATION AND DEALING ONLINE OVER THE INTERNET AND WILL NOT HOLD ANY SOLANA MOBILE PARTY RESPONSIBLE FOR ANY BREACH OF SECURITY. THE SOLANA MOBILE PARTIES WILL NOT BE RESPONSIBLE OR LIABLE TO YOU FOR ANY LOSSES YOU SUSTAIN AS A RESULT OF YOUR USE OF THE DAPP STORE. THE SOLANA MOBILE PARTIES TAKE NO RESPONSIBILITY FOR, AND WILL NOT BE LIABLE TO YOU FOR, ANY USE OF APPLICATIONS OR YOUR DIGITAL WALLET BY YOU, INCLUDING BUT NOT LIMITED TO ANY LOSSES, DAMAGES, OR CLAIMS ARISING FROM: (a) USER ERROR SUCH AS FORGOTTEN PASSWORDS, INCORRECTLY CONSTRUCTED TRANSACTIONS, OR MISTYPED ADDRESSES; (b) SERVER FAILURE OR DATA LOSS; (c) CORRUPTED DIGITAL WALLET FILES; (d) UNAUTHORIZED ACCESS TO APPLICATIONS; OR (e) ANY UNAUTHORIZED THIRD PARTY ACTIVITIES, INCLUDING WITHOUT LIMITATION THE USE OF VIRUSES, PHISHING, BRUTEFORCING OR OTHER MEANS OF ATTACK AGAINST THE DAPP STORE OR DIGITAL WALLETS. The Solana Mobile Parties are not responsible for any losses or harms sustained by you due to vulnerability or any kind of failure, abnormal behavior of software (e.g., smart contract), blockchains, or any other features of or inherent to the Solana Network. The Solana Mobile Parties are not responsible for any delay or failure to report any issues with the Solana Network, including without limitation forks, technical node issues, or any other issues that result in losses of any sort.

20\. Limitation of Liability. TO THE FULLEST EXTENT PERMITTED BY LAW, IN NO EVENT WILL THE SOLANA MOBILE PARTIES BE LIABLE TO YOU OR ANY THIRD PARTY FOR ANY LOST PROFIT OR ANY INDIRECT, CONSEQUENTIAL, EXEMPLARY, INCIDENTAL, SPECIAL OR PUNITIVE DAMAGES ARISING FROM OR RELATED TO THIS AGREEMENT, THE DAPP STORE, ANY APPLICATION, OR FOR ANY DAMAGES RELATED TO LOSS OF REVENUE, LOSS OF PROFITS, LOSS OF BUSINESS OR ANTICIPATED SAVINGS, LOSS OF USE, LOSS OF GOODWILL, OR LOSS OF DATA, AND WHETHER CAUSED BY TORT (INCLUDING NEGLIGENCE), BREACH OF CONTRACT, OR OTHERWISE, EVEN IF FORESEEABLE AND EVEN IF ANY SOLANA MOBILE PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES. ACCESS TO, AND USE OF, THE DAPP STORE IS UNDERTAKEN BY YOU AT YOUR OWN DISCRETION AND RISK, AND YOU WILL BE SOLELY RESPONSIBLE FOR ANY DAMAGE TO YOUR COMPUTER SYSTEM OR MOBILE DEVICE OR LOSS OF DATA RESULTING THEREFROM. NOTWITHSTANDING ANYTHING TO THE CONTRARY CONTAINED HEREIN, IN NO EVENT SHALL THE MAXIMUM AGGREGATE, COLLECTIVE LIABILITY OF THE SOLANA MOBILE PARTIES ARISING OUT OF OR IN ANY WAY RELATED TO THIS AGREEMENT, YOUR ACCESS TO AND USE OF THE DAPP STORE, OR ANY APPLICATIONS DOWNLOADED, PURCHASED, OR OTHERWISE ACQUIRED THROUGH THE DAPP STORE EXCEED THE GREATER OF (i) $100 OR (ii) THE AMOUNT PAID TO SOLANA MOBILE BY YOU IN THE TWELVE MONTHS PRECEDING THE DATE OF THE CLAIM. Some jurisdictions do not allow the exclusion or limitation of incidental or consequential damages, so the above limitation or exclusion may not apply to you.

21\. Term and Termination.

21.1. Term. You and we agree that: (i) subject to any eligibility requirements for accessing and using the dApp Store or entering into these dApp Store Terms, these dApp Store Terms commenced on the earlier to occur of (a) the date you first used the dApp Store, or (b) the date you accepted these dApp Store Terms, and (ii) these dApp Store Terms will remain in full force and effect while you use the dApp Store or any Application acquired thereby, unless earlier terminated in accordance with these dApp Store Terms.

21.2. Termination by Solana Mobile. We may terminate these dApp Store Terms or your ability to access or use the dApp Store at any time for any reason, with or without notice, including if timely payment of any Application Fee is not made by you for any reason, if you have breached any provision of these dApp Store Terms, or if we are required to do so by law (e.g., where the provision of the dApp Store is, or becomes, unlawful). We may limit or restrict your access to the dApp Store immediately if you fail to comply with any provisions of these dApp Store Terms, at our sole discretion. Your use of any specific Application will be subject to, and may terminate pursuant to, the applicable EULA.

21.3. Termination by You. If you want to terminate these dApp Store Terms, you must do so by ceasing all further use of the dApp Store and any Applications enabled thereby.

21.4. Effect of Termination. Termination of these dApp Store Terms, or of your access to or use of any the dApp Store, may include removal of access to certain Applications and/or barring of further use of such Applications. Upon termination of these dApp Store Terms, your right to use the dApp Store will automatically terminate. Solana Mobile will not have any liability whatsoever to you for any suspension or termination. All provisions of these dApp Store Terms which by their nature should survive, shall survive termination of these dApp Store Terms, including without limitation, ownership provisions, warranty disclaimers, and limitation of liability.

22\. General Provisions.

22.1. Irreparable Harm. Any breach or threatened breach of this Agreement by you will cause irreparable harm to Solana Mobile for which damages would not be an adequate remedy, and therefore, Solana Mobile shall be entitled to injunctive relief with respect thereto in addition to any other remedies without the need to prove irreparable harm or post a bond.

22.2. Assignment. The Agreement, and your rights and obligations hereunder, may not be assigned, subcontracted, delegated or otherwise transferred by you, in whole or in part, by operation of law or otherwise, without Solana Mobile’s prior written consent, and any attempted assignment, subcontract, delegation, or transfer in violation of the foregoing will be null and void. Solana Mobile may assign, subcontract, delegate, or otherwise transfer any rights and obligations it may have without any notice to or consent by You.

22.3. Force Majeure. The Solana Mobile Parties shall not be liable for any delay or failure to perform resulting from causes outside its reasonable control, including, but not limited to, acts of God, war, terrorism, riots, embargos, acts of civil or military authorities, fire, floods, accidents, strikes or shortages of transportation facilities, fuel, energy, labor or materials.

22.4. Exclusive Venue. To the extent litigation in a court is permitted under the terms of this Agreement, and subject to Section 15, all such claims and disputes arising out of or relating to the Agreement will be litigated exclusively in the courts of New York, New York.

22.5. Governing Law. SUBJECT TO SECTION 15 (DISPUTES) AND ANY OVERRIDING CONSUMER RIGHTS UNDER THE LAWS OF YOUR COUNTRY OF RESIDENCE, THIS AGREEMENT AND ANY ACTION RELATED HERETO WILL BE GOVERNED BY THE LAWS OF THE STATE OF DELAWARE, WITHOUT GIVING EFFECT TO ANY PRINCIPLES THAT PROVIDE FOR THE APPLICATION OF THE LAW OF ANOTHER JURISDICTION.

22.6. Equal Interpretation. To the fullest extent permitted by applicable law, each of you and Solana Mobile agree that rules relating to the interpretation of contracts against the drafter of any particular clause shall not apply in the case of this Agreement.

22.7. Waiver. If you do not comply with this Agreement, and the Solana Mobile Parties do not take action right away, this does not mean that the Solana Mobile Parties are waiving its rights to enforce this Agreement with respect to such breach or any future breach. For the avoidance of doubt, any waiver or failure to enforce any provision of the Agreement on one occasion will not be deemed a waiver of any other provision or of such provision on any other occasion.

22.8. Severability. To the fullest extent permitted by applicable law, if any portion of this Agreement is held invalid or unenforceable, that portion shall be construed in a manner to reflect, as nearly as possible, the original intention of the parties, and the remaining portions shall remain in full force and effect.

22.9. Contact. You may contact Solana Mobile by email [legal@solanamobile.com](mailto:legal@solanamobile.com) or by mail at 605 N Michigan Ave, Floor 4 #1478783, Chicago, IL 60611. The communications between you and Solana Mobile may take place via electronic means, whether you visit the dApp Store or send Solana Mobile e-mails, or whether Solana Mobile posts notices on the dApp Store or communicates with you via e- mail. For contractual purposes, you (i) consent to receive communications from us in an electronic form; and (ii) agree that all terms and conditions, agreements, notices, disclosures, and other communications that we provide to you electronically satisfy any legal requirement that such communications would satisfy if it were to be in writing. Where Solana Mobile requires that you provide an e-mail address, you are responsible for providing Solana Mobile with your most current e-mail address. In the event that the last e-mail address you provided to Solana Mobile is not valid, or for any reason is not capable of delivering to you any notices required/ permitted by the Agreement, Solana Mobile’s dispatch of the e-mail containing such notice will nonetheless constitute effective notice. The foregoing does not affect your statutory rights, including but not limited to the Electronic Signatures in Global and National Commerce Act at 15 U.S.C. §7001 et seq. (“ **E-Sign**”).

22.10. EU Digital Services Act (“DSA”). If you use dApp Store while located in the European Union (“EU”), you may be covered by the rights and protections established under the EU DSA (Regulation (EU) 2022/2065). In accordance with the DSA, dApp Store provides clear information about the identity of developers offering dApps, including their verified contact details where applicable. You may report illegal or policy-violating content through dApp Store’s reporting mechanism and, if any User Content you have uploaded is removed or restricted, you may have the right to contest that decision through Solana Mobile’s internal complaint-handling process or, where available, through an independent out-of-court dispute settlement body certified under the DSA.

22.11. Third-party beneficiaries. Except for the Solana Mobile Parties, there are no third-party beneficiaries to this Agreement.

22.12. Entire Agreement. The Agreement is the final, complete and exclusive agreement of the parties with respect to the subject matter hereof and supersedes and merges all prior discussions between the parties with respect to such subject matter. Each party acknowledges and agrees that (a) it has not relied upon any representation or warranty, express or implied, not expressly set forth in this Agreement, and (b) no party shall have any liability to the other with respect to any extra-contractual statements, representations, or warranties, whether oral or written. Each party further acknowledges that it has had the opportunity to consult with counsel regarding this Agreement.

## Solana Mobile Support
[Skip to main content](https://docs.solanamobile.com/marketing/support#__docusaurus_skipToContent_fallback)

On this page

The resources in this section cover information related to marketing and partnerships with Solana Mobile.

For other resources, view our documentation regarding the [dApp Store](https://docs.solanamobile.com/dapp-publishing/intro) or [App Development](https://docs.solanamobile.com/developers/development-setup).

## Discord [​](https://docs.solanamobile.com/marketing/support\#discord "Direct link to Discord")

For any further questions, you can also chat with us on our [Discord](https://discord.gg/solanamobile) in the `#dapp-store` channel.

- [Discord](https://docs.solanamobile.com/marketing/support#discord)

## Solana Mobile Documentation
https://docs.solanamobile.com/blogweekly0.5https://docs.solanamobile.com/blog/archiveweekly0.5https://docs.solanamobile.com/blog/ios-wallet-signingweekly0.5https://docs.solanamobile.com/blog/tagsweekly0.5https://docs.solanamobile.com/blog/tags/custodyweekly0.5https://docs.solanamobile.com/blog/tags/i-osweekly0.5https://docs.solanamobile.com/blog/tags/mobile-wallet-adapterweekly0.5https://docs.solanamobile.com/blog/tags/mwaweekly0.5https://docs.solanamobile.com/blog/tags/passkeysweekly0.5https://docs.solanamobile.com/blog/tags/safari-web-extensionweekly0.5https://docs.solanamobile.com/blog/tags/signingweekly0.5https://docs.solanamobile.com/blog/tags/transactionweekly0.5https://docs.solanamobile.com/grants/weekly0.5https://docs.solanamobile.com/hackathon/weekly0.5https://docs.solanamobile.com/searchweekly0.5https://docs.solanamobile.com/weekly0.5https://docs.solanamobile.com/tagsweekly0.5https://docs.solanamobile.com/tags/chapter-2weekly0.5https://docs.solanamobile.com/tags/nftweekly0.5https://docs.solanamobile.com/tags/sagaweekly0.5https://docs.solanamobile.com/additional-sdks/dapp\_store\_introweekly0.5https://docs.solanamobile.com/additional-sdks/seedvault\_introweekly0.5https://docs.solanamobile.com/android-native/building\_transactionsweekly0.5https://docs.solanamobile.com/android-native/building-json-rpc-requestsweekly0.5https://docs.solanamobile.com/android-native/overviewweekly0.5https://docs.solanamobile.com/android-native/quickstartweekly0.5https://docs.solanamobile.com/android-native/rpc-requestsweekly0.5https://docs.solanamobile.com/android-native/sending-solweekly0.5https://docs.solanamobile.com/android-native/setupweekly0.5https://docs.solanamobile.com/android-native/using\_mobile\_wallet\_adapterweekly0.5https://docs.solanamobile.com/android-native/using-anchor-programsweekly0.5https://docs.solanamobile.com/dapp-publishing/agreementweekly0.5https://docs.solanamobile.com/dapp-publishing/app-nftweekly0.5https://docs.solanamobile.com/dapp-publishing/building-expo-apkweekly0.5https://docs.solanamobile.com/dapp-publishing/checklistweekly0.5https://docs.solanamobile.com/dapp-publishing/faqweekly0.5https://docs.solanamobile.com/dapp-publishing/introweekly0.5https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-pageweekly0.5https://docs.solanamobile.com/dapp-publishing/listing-page-guidelinesweekly0.5https://docs.solanamobile.com/dapp-publishing/overviewweekly0.5https://docs.solanamobile.com/dapp-publishing/prepareweekly0.5https://docs.solanamobile.com/dapp-publishing/privacy-policyweekly0.5https://docs.solanamobile.com/dapp-publishing/publisher-policyweekly0.5https://docs.solanamobile.com/dapp-publishing/publishing\_releasesweekly0.5https://docs.solanamobile.com/dapp-publishing/publishing-a-pwaweekly0.5https://docs.solanamobile.com/dapp-publishing/publishing-from-google-playweekly0.5https://docs.solanamobile.com/dapp-publishing/publishing-updatesweekly0.5https://docs.solanamobile.com/dapp-publishing/qandaweekly0.5https://docs.solanamobile.com/dapp-publishing/setupweekly0.5https://docs.solanamobile.com/dapp-publishing/submitweekly0.5https://docs.solanamobile.com/dapp-publishing/submit-an-updateweekly0.5https://docs.solanamobile.com/dapp-publishing/submit-new-appweekly0.5https://docs.solanamobile.com/dapp-publishing/supportweekly0.5https://docs.solanamobile.com/dapp-publishing/touweekly0.5https://docs.solanamobile.com/developers/communityweekly0.5https://docs.solanamobile.com/developers/development-setupweekly0.5https://docs.solanamobile.com/developers/mobile-development-frameworksweekly0.5https://docs.solanamobile.com/developers/mobile-scaffold-appsweekly0.5https://docs.solanamobile.com/developers/mobile-wallet-adapterweekly0.5https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-diveweekly0.5https://docs.solanamobile.com/developers/mobile-wallet-adapter-webweekly0.5https://docs.solanamobile.com/developers/overviewweekly0.5https://docs.solanamobile.com/developers/seed-vaultweekly0.5https://docs.solanamobile.com/flutter/overviewweekly0.5https://docs.solanamobile.com/getting-started/chapter2-preorder-tokenweekly0.5https://docs.solanamobile.com/getting-started/development-setupweekly0.5https://docs.solanamobile.com/getting-started/introweekly0.5https://docs.solanamobile.com/getting-started/introduction-to-solanaweekly0.5https://docs.solanamobile.com/getting-started/mobile-dapp-architectureweekly0.5https://docs.solanamobile.com/getting-started/overviewweekly0.5https://docs.solanamobile.com/getting-started/saga-genesis-tokenweekly0.5https://docs.solanamobile.com/getting-started/web3-and-mobileweekly0.5https://docs.solanamobile.com/marketing/comarketing-guidelinesweekly0.5https://docs.solanamobile.com/marketing/engaging-saga-usersweekly0.5https://docs.solanamobile.com/marketing/engaging-seeker-usersweekly0.5https://docs.solanamobile.com/marketing/faqweekly0.5https://docs.solanamobile.com/marketing/overviewweekly0.5https://docs.solanamobile.com/marketing/supportweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/diagramsweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standardweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/mobile-appsweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/overviewweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelinesweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/web-appsweekly0.5https://docs.solanamobile.com/mobile-wallet-adapter/web-installationweekly0.5https://docs.solanamobile.com/mwa/migration/dapps/clientlibweekly0.5https://docs.solanamobile.com/mwa/migration/dapps/clientlib-ktxweekly0.5https://docs.solanamobile.com/mwa/migration/overviewweekly0.5https://docs.solanamobile.com/mwa/migration/wallets/walletlibweekly0.5https://docs.solanamobile.com/react-native/anchor\_integrationweekly0.5https://docs.solanamobile.com/react-native/building\_transactionsweekly0.5https://docs.solanamobile.com/react-native/detecting-seeker-usersweekly0.5https://docs.solanamobile.com/react-native/expoweekly0.5https://docs.solanamobile.com/react-native/expo-dapp-templateweekly0.5https://docs.solanamobile.com/react-native/first\_app\_tutorialweekly0.5https://docs.solanamobile.com/react-native/hello\_world\_tutorialweekly0.5https://docs.solanamobile.com/react-native/making\_rpc\_requestsweekly0.5https://docs.solanamobile.com/react-native/metaplex\_integrationweekly0.5https://docs.solanamobile.com/react-native/mobile\_nft\_minter\_tutorialweekly0.5https://docs.solanamobile.com/react-native/overviewweekly0.5https://docs.solanamobile.com/react-native/polyfill-guides/anchorweekly0.5https://docs.solanamobile.com/react-native/polyfill-guides/polyfillsweekly0.5https://docs.solanamobile.com/react-native/polyfill-guides/spl-tokenweekly0.5https://docs.solanamobile.com/react-native/polyfill-guides/web3-jsweekly0.5https://docs.solanamobile.com/react-native/quickstartweekly0.5https://docs.solanamobile.com/react-native/quickstart\_legacyweekly0.5https://docs.solanamobile.com/react-native/react-native-scaffoldweekly0.5https://docs.solanamobile.com/react-native/setupweekly0.5https://docs.solanamobile.com/react-native/storing\_mwa\_authweekly0.5https://docs.solanamobile.com/react-native/test-with-any-android-deviceweekly0.5https://docs.solanamobile.com/react-native/using\_mobile\_wallet\_adapterweekly0.5https://docs.solanamobile.com/reference/kotlin/mobile-wallet-adapterweekly0.5https://docs.solanamobile.com/reference/overviewweekly0.5https://docs.solanamobile.com/reference/typescript/mobile-wallet-adapterweekly0.5https://docs.solanamobile.com/reference/typescript/mobile-wallet-adapter-legacyweekly0.5https://docs.solanamobile.com/reference/typescript/web3jsweekly0.5https://docs.solanamobile.com/saga/release-notes/weekly0.5https://docs.solanamobile.com/saga/release-notes/2023-12-updateweekly0.5https://docs.solanamobile.com/saga/release-notes/mr1weekly0.5https://docs.solanamobile.com/saga/release-notes/mr2weekly0.5https://docs.solanamobile.com/saga/release-notes/mr3weekly0.5https://docs.solanamobile.com/saga/release-notes/mr4weekly0.5https://docs.solanamobile.com/saga/release-notes/mr5weekly0.5https://docs.solanamobile.com/sample-apps/sample\_app\_overviewweekly0.5https://docs.solanamobile.com/seeker/release-notes/weekly0.5https://docs.solanamobile.com/seeker/release-notes/mr4weekly0.5https://docs.solanamobile.com/seeker/release-notes/mr5weekly0.5https://docs.solanamobile.com/seeker/release-notes/mr6weekly0.5https://docs.solanamobile.com/solana-kmp/weekly0.5https://docs.solanamobile.com/unity/unity\_sdkweekly0.5https://docs.solanamobile.com/unreal/unreal\_sdkweekly0.5https://docs.solanamobile.com/web/developing-for-webweekly0.5https://docs.solanamobile.com/web/overviewweekly0.5

## iOS Wallet Solutions
[Skip to main content](https://docs.solanamobile.com/blog/tags/i-os#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/i-os\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/i-os\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/i-os\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/i-os\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/i-os\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/i-os\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/i-os\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/i-os\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/i-os\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/i-os\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/i-os\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/i-os\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/i-os\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/i-os\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/i-os\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/i-os\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Custody Solutions
[Skip to main content](https://docs.solanamobile.com/blog/tags/custody#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/custody\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/custody\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/custody\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/custody\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/custody\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/custody\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/custody\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/custody\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/custody\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/custody\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/custody\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/custody\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/custody\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/custody\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/custody\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/custody\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## Solana Mobile Development Overview
[Skip to main content](https://docs.solanamobile.com/developers/overview#__docusaurus_skipToContent_fallback)

On this page

## Getting Started [​](https://docs.solanamobile.com/developers/overview\#getting-started "Direct link to Getting Started")

Start developing apps for the Solana dApp Store on **any** Android device or emulator.

[**Quickstart**\\
\\
Launch a mobile app using the Solana Mobile Expo Template.](https://docs.solanamobile.com/react-native/quickstart)

[**Development Setup**\\
\\
Set up your environment for Solana mobile development.](https://docs.solanamobile.com/developers/development-setup)

## Development Guides [​](https://docs.solanamobile.com/developers/overview\#development-guides "Direct link to Development Guides")

Official guides and resources for building Solana mobile apps with our fully supported frameworks.

[_![](https://docs.solanamobile.com/img/react-native-96.svg)_\\
\\
**React Native**\\
\\
Build mobile apps with JavaScript and reuse familiar Solana web libraries.](https://docs.solanamobile.com/react-native/overview)

[_![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)_\\
\\
**Kotlin**\\
\\
Create high-performance native apps with full Android capabilities.](https://docs.solanamobile.com/android-native/overview)

### Community Supported Frameworks [​](https://docs.solanamobile.com/developers/overview\#community-supported-frameworks "Direct link to Community Supported Frameworks")

Third-party development guides and resources for additional frameworks created by the ecosystem members.

[_![](https://docs.solanamobile.com/img/flutter-icon.svg)_\\
\\
**Flutter**\\
\\
Third-party resources and SDKs for Solana Flutter development.](https://docs.solanamobile.com/flutter/overview)

[_![](https://docs.solanamobile.com/img/unity-logo.png)_\\
\\
**Unity**\\
\\
Third-party resources and SDKs for Solana Unity development.](https://docs.solanamobile.com/unity/unity_sdk)

[_![](https://docs.solanamobile.com/img/unreal-logo.png)_\\
\\
**Unreal Engine**\\
\\
Third-party resources and SDKs for Solana Unreal development.](https://docs.solanamobile.com/unreal/unreal_sdk)

## Resources [​](https://docs.solanamobile.com/developers/overview\#resources "Direct link to Resources")

Additional resources for building mobile apps on the Solana dApp Store.

[**Sample Apps**\\
\\
Browse reference apps to jumpstart your development.](https://docs.solanamobile.com/sample-apps/sample_app_overview)

[**dApp Store**\\
\\
Publish your app on the Solana dApp Store.](https://docs.solanamobile.com/dapp-publishing/submit-new-app)

[**API Reference**\\
\\
Explore comprehensive SDK and API documentation.](https://docs.solanamobile.com/reference/overview)

- [Getting Started](https://docs.solanamobile.com/developers/overview#getting-started)
- [Development Guides](https://docs.solanamobile.com/developers/overview#development-guides)
  - [Community Supported Frameworks](https://docs.solanamobile.com/developers/overview#community-supported-frameworks)
- [Resources](https://docs.solanamobile.com/developers/overview#resources)

## Solana Kotlin dApp Setup
[Skip to main content](https://docs.solanamobile.com/android-native/quickstart#__docusaurus_skipToContent_fallback)

On this page

The quickest way to start building Solana Kotlin dApps is to build off the [Solana Jetpack Compose Scaffold](https://github.com/solana-mobile/solana-kotlin-compose-scaffold).

## Solana Jetpack Compose Scaffold [​](https://docs.solanamobile.com/android-native/quickstart\#solana-jetpack-compose-scaffold "Direct link to Solana Jetpack Compose Scaffold")

The scaffold app serves as both a starting implementation and an example reference of how to use the core Kotlin SDKs, like `web3-core`, `rpc-core`,
and Mobile Wallet Adapter.

It includes:

- Core Solana kotlin libraries
- Pre-built Compose UI components,
- Code examples of transaction building and RPC requests.

![Scaffold dApp Screenshot 1](https://docs.solanamobile.com/kotlin_images/scaffoldScreenshot1.png)

![Scaffold dApp Screenshot 2](https://docs.solanamobile.com/kotlin_images/scaffoldScreenshot2.png)

![Scaffold dApp Screenshot 3](https://docs.solanamobile.com/kotlin_images/scaffoldScreenshot3.png)

## Prerequisites [​](https://docs.solanamobile.com/android-native/quickstart\#prerequisites "Direct link to Prerequisites")

Follow the [prerequisite setup](https://docs.solanamobile.com/developers/development-setup#prerequisite-setup) guide to set up Android Studio, your [Android Device/Emulator](https://docs.solanamobile.com/developers/development-setup#2-setup-deviceemulator) and install a MWA-compatible wallet, like [fakewallet](https://docs.solanamobile.com/developers/development-setup#3-install-a-wallet-app).

## Install the Jetpack Compose Scaffold [​](https://docs.solanamobile.com/android-native/quickstart\#install-the-jetpack-compose-scaffold "Direct link to Install the Jetpack Compose Scaffold")

**Clone the repo**

The scaffold app is open source and can be fetched from [Github](https://github.com/solana-mobile/solana-kotlin-compose-scaffold).

```shell
git clone https://github.com/solana-mobile/solana-kotlin-compose-scaffold.git
```

**Open the project in Android Studio**

In Android Studio, open the project with `File > Open > SolanaKotlinComposeScaffold/build.gradle.kts`

**Build and run**

Ensure you have connected an Android emulator or device and it is detected by Android Studio. If not, follow
this [guide](https://docs.solanamobile.com/developers/development-setup#2-setup-deviceemulator) to setup your emulator/device.

In the top bar of Android Studio, select `"app"` as the configuration and your emulator/device, then click run.

![Build and run the app](https://docs.solanamobile.com/assets/images/compose-build-run-953a48b83f21f65098b34cb964f6e008.png)

If successful, the scaffold app will launch on your emulator/device.

Connect with a locally installed wallet app to start interacting with the Solana network! 🎉

## Further learning [​](https://docs.solanamobile.com/android-native/quickstart\#further-learning "Direct link to Further learning")

To learn how to better use the core Solana Kotlin SDKs, check out these developer guides.

[🌐\\
\\
**JSON RPC Requests**\\
\\
Learn the rpc-core library to create and send Solana RPC Requests.](https://docs.solanamobile.com/android-native/rpc-requests)

[🔧\\
\\
**Transaction building**\\
\\
Use the web3-core library to construct Solana transactions and Program instructions.](https://docs.solanamobile.com/android-native/building_transactions)

[📱\\
\\
**Mobile Wallet Adapter**\\
\\
Learn how to connect to mobile wallets and request signing services.](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter)

- [Solana Jetpack Compose Scaffold](https://docs.solanamobile.com/android-native/quickstart#solana-jetpack-compose-scaffold)
- [Prerequisites](https://docs.solanamobile.com/android-native/quickstart#prerequisites)
- [Install the Jetpack Compose Scaffold](https://docs.solanamobile.com/android-native/quickstart#install-the-jetpack-compose-scaffold)
- [Further learning](https://docs.solanamobile.com/android-native/quickstart#further-learning)

## Mobile Wallet Adapter
[Skip to main content](https://docs.solanamobile.com/developers/mobile-wallet-adapter#__docusaurus_skipToContent_fallback)

On this page

[**Mobile Wallet Adapter (MWA)**](https://github.com/solana-mobile/mobile-wallet-adapter) is a generic protocol specification that enables dApps to connect with mobile wallet apps for Solana transaction and message signing.

## Why is it important? [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter\#why-is-it-important "Direct link to Why is it important?")

- Developers only need to implement MWA once to be compatible with [all MWA-compliant wallets](https://solanamobile.com/wallets)! It eliminates the need to integrate with each wallet individually.

- Developers can focus entirely on their dApp's core functionality, with wallet integration handled at no cost.

- Users have freedom to select and use the mobile wallet app of their choice.


## Supported Platforms [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter\#supported-platforms "Direct link to Supported Platforms")

| Mobile Platform | Is MWA Supported? | Notes |
| --- | --- | --- |
| Android | ✅ | Full support for dApps and Wallet apps. |
| Mobile Web - Chrome (Android) | ✅ | Automatic integration if using `@solana/wallet-adapter-react`. |
| iOS | ❌ | MWA is not currently available for any iOS platform (app or browser). |
| Mobile Web - Safari, Firefox, Opera, Brave | ❌ | These browsers currently do not support MWA on Android (or iOS). |

## Using the SDK [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter\#using-the-sdk "Direct link to Using the SDK")

Solana Mobile maintains an official [Mobile Wallet Adapter SDK](https://github.com/solana-mobile/mobile-wallet-adapter) that implements the protocol, originally written as a Android Kotlin/Java library.

- For dApps
- For Wallets

The SDK is available for:

- [Kotlin](https://docs.solanamobile.com/android-native/overview)
- [React Native](https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter)
- Flutter
- Unity
- Unreal Engine

Explore the _SDKs_ section of the site to learn how to integrate the MWA SDK into the framework of your choice.

The SDK is available for:

- [Kotlin](https://docs.solanamobile.com/android-native/overview)
- [React Native](https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter)
- Flutter
- Unity
- Unreal Engine

**Migrating to MWA 2.0**

Check out the [2.0 migration guide](https://docs.solanamobile.com/mwa/migration/overview) to migrate from 1.x version of Mobile Wallet Adapter to the latest version.

- [Why is it important?](https://docs.solanamobile.com/developers/mobile-wallet-adapter#why-is-it-important)
- [Supported Platforms](https://docs.solanamobile.com/developers/mobile-wallet-adapter#supported-platforms)
- [Using the SDK](https://docs.solanamobile.com/developers/mobile-wallet-adapter#using-the-sdk)

## Publish a PWA
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#__docusaurus_skipToContent_fallback)

On this page

## PWAs on the dApp Store [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#pwas-on-the-dapp-store "Direct link to PWAs on the dApp Store")

[Progressive Web Apps (PWAs)](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps) are web applications that use modern web capabilities to deliver an app-like experience to users.

PWAs can be published on the dApp Store, as an Android app wrapped within a **Trusted Web Activity (TWA)**.

## Trusted Web Activities (TWAs) [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#trusted-web-activities-twas "Direct link to Trusted Web Activities (TWAs)")

[Trusted Web Activities (TWAs)](https://developer.chrome.com/docs/android/trusted-web-activity) allow you to package your PWA into an Android app. TWAs use Chrome to render the web app, providing a full screen, native-like experience without any browser UI.

Once you create a TWA, you will have an Android APK file and you can follow the dApp publishing guide to submit the app.

Follow the guide below to get your PWA ready for the dApp Store.

## Tutorial: Converting a PWA to an Android App [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#tutorial-converting-a-pwa-to-an-android-app "Direct link to Tutorial: Converting a PWA to an Android App")

This guide shows you how to:

- Install the Bubblewrap CLI tool
- Build the TWA and output an APK
- Generate the Digital Asset Link for the APK

By the end, you will have a functional, signed release APK that can be published on the dApp Store!

### Prerequisite [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#prerequisite "Direct link to Prerequisite")

- A PWA [web manifest](https://developer.mozilla.org/en-US/docs/Web/Manifest) hosted at `https://your-pwa-url.com/manifest.json`

### Template: Web Manifest [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#template-web-manifest "Direct link to Template: Web Manifest")

At minimum, a typical manifest file includes:

- The app's name
- The icons the app should use
- The URL that should be opened when the app launches

You can use this template to quickly stand up a `manifest.json` on your website.

```json
{
    "name": "APP_NAME",
    "short_name": "APP_NAME",
    "scope": "/",
    "start_url": "/",
    "icons": [\
        {\
            "src": "/android-chrome-192x192.png",\
            "sizes": "192x192",\
            "type": "image/png"\
        },\
        {\
            "src": "/android-chrome-512x512.png",\
            "sizes": "512x512",\
            "type": "image/png"\
        }\
    ],
    "theme_color": "#ffffff",
    "background_color": "#ffffff",
    "display": "standalone"
}
```

For more information on web manifests, view this [documentation](https://web.dev/articles/add-manifest).

### 1\. Installing Bubblewrap CLI [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#1-installing-bubblewrap-cli "Direct link to 1. Installing Bubblewrap CLI")

[Bubblewrap CLI](https://github.com/GoogleChromeLabs/bubblewrap/tree/main/packages/cli) is a tool that simplifies the process of converting your PWA into an Android app using TWA.

Requires Node 14.15.0 and above

```bash
npm i -g @bubblewrap/cli
```

### 2\. Initializing Your Project [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#2-initializing-your-project "Direct link to 2. Initializing Your Project")

In a new directory, run the `init` command and supply the URL to your web manifest.
Bubblewrap will download the existing manifest and use it to help fill in metadata for the TWA's manifest.

- See the Bubblewrap official [documentation](https://github.com/GoogleChromeLabs/bubblewrap/tree/main/packages/cli#init).

```bash
bubblewrap init --manifest https://your-pwa-url.com/manifest.json
```

This command will guide you through the process of creating the TWA manifest for the project.

- If it asks to install additional tooling (e.g Android SDK, JDK, or build tools), it is necessary and you should allow it to install.

#### Manifest Configuration [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#manifest-configuration "Direct link to Manifest Configuration")

It will also prompt a series of questions regarding configurations for:

- **Domain and URL path**
  - Ensure this points directly to where your PWA is hosted.
- **Display mode and Status Bar settings**
  - See the [Android documentation](https://material.io/design/platform-guidance/android-bars.html) to see how Status Bar and Navigation Bars appear and decide what configuration is appropriate for your app.
- **Splash Screen and Icons**
  - Create a cohesive splash screen by providing a splash screen color and an icon that displays over it.
- **Keystore location and Password**
  - See _Caution_ below.

caution

The `init` command will ask you to generate an **Android Keystore and password**.

The [Android Keystore](https://developer.android.com/privacy-and-security/keystore) is a security tool that:

- Contains a private key used to digitally sign your app. This signature is used to verify the app's authenticity and integrity.
- The same key must be used to sign all future updates of your app. This ensures that only you can make updates to your app.

Keep the Keystore file and password secure – losing them can prevent future app updates. Consider following
Google's [official guide for best practices around Keystore management](https://developer.android.com/studio/publish/app-signing#secure_key).

After completion, Bubblewrap will create in your directory:

- A `twa-manifest.json` configured with the options from above.
- TWA Android project files generated from `twa-manifest.json`.

note

The Android project is entirely generated from the `twa-manifest.json`, so you only need to include
`twa-manifest.json` in source control. The Android project files are unncessary to track as they are generated.

Any changes to the Android project will be deleted or overwritten by the `update` command (explained in the _Updating your TWA_ section).

### 3\. Building the Android APK [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#3-building-the-android-apk "Direct link to 3. Building the Android APK")

#### Add supported langauges [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#add-supported-langauges "Direct link to Add supported langauges")

Before running the build command, you need to specify the languages your app supports.

warning

Do not skip this step!

By default, Bubblewrap CLI incorrectly declares that your app supports all locales. This inaccuracy will be displayed on your dApp Store listing page.

In the generated Android project, edit the `build.gradle` and add:

```kt
android {
    defaultConfig {
        ...
        resConfigs "en", "es" // Add any locales your app supports
    }
}
```

See the [Android documentation](https://developer.android.com/guide/topics/resources/multilingual-support#specify-the-languages-your-app-supports) for more details.

#### Build the APK [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#build-the-apk "Direct link to Build the APK")

The next step is to build initialized Android project and output a _signed release APK_. This APK is what you will submit for publishing on the dApp Store.

In the same directory, run:

```bash
bubblewrap build
```

This command will

- If it asks to install additional tooling (e.g Android SDK, JDK, or build tools), you should allow it to install.

### 4\. Publish Digital Asset Links [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#4-publish-digital-asset-links "Direct link to 4. Publish Digital Asset Links")

The last step is to declare your app's [Digital Asset Links (DAL)](https://developers.google.com/digital-asset-links/v1/getting-started). DALs establish a secure connection between your website and the Android app.

tip

This step is **required** for the PWA to display in a full screen, native-like experience. If missing, the PWA will display
Chrome browser UI (e.g the URL bar).

Declare the connection by adding the SHA256 fingerprints of your app’s signing certificate at `https://your-domain.com/.well-known/assetlinks.json`.

1. Generate the SHA256 fingerprint from the Keystore:

```bash
keytool -list -v -keystore android.keystore
```

2. Add the fingerprint to your TWA manifest:

```bash
bubblewrap fingerprint add <SHA256_fingerprint>
```

3. Generate the DAL `assetlinks.json` file:

```bash
bubblewrap fingerprint generateAssetLinks
```

It should generate a file named `assetlinks.json` configured with the SHA256 fingerprint.

4. Publish the generated `assetlinks.json` file at:
`https://your-domain.com/.well-known/assetlinks.json`

Congrats! You have successfully converted your PWA into a working Android app.

## Testing Your App [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#testing-your-app "Direct link to Testing Your App")

If you have an emulator or testing device ready, you can install the APK with:

```bash
bubblewrap install app-release-signed.apk
```

Ensure the app is working as expected before submitting to the dApp Store.

tip

If you are seeing the browser navigation bar at the top of the app, your app's Digital Asset Links might not be configured
correctly.

Double check that you followed Step 4 and have correctly published your app's SHA256 fingerprint.

## Updating your TWA [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#updating-your-twa "Direct link to Updating your TWA")

If you want to release a new version of the app with changes to the TWA manifest (e.g Updating the icon), you can
make edits to `twa-manifest.json` and run the command:

```bash
bubblewrap update --manifest=./path/to/twa-manifest.json
```

This command regenerates the entire Android project from the `twa-manifest.json` and bumps the app version. The manifest is preserved, while any manual changes to the previous Android project are deleted or overwritten.

After this you can run `bubblewrap build` again to generate the signed release APK.

## Publishing to dApp Store [​](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa\#publishing-to-dapp-store "Direct link to Publishing to dApp Store")

Once you have a signed APK, you can proceed with publishing as if you were publishing a normal
Android app.

**Follow the step by step [dApp publishing guide](https://docs.solanamobile.com/dapp-publishing/submit-new-app) to submit your signed release APK.**

- [PWAs on the dApp Store](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#pwas-on-the-dapp-store)
- [Trusted Web Activities (TWAs)](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#trusted-web-activities-twas)
- [Tutorial: Converting a PWA to an Android App](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#tutorial-converting-a-pwa-to-an-android-app)
  - [Prerequisite](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#prerequisite)
  - [Template: Web Manifest](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#template-web-manifest)
  - [1\. Installing Bubblewrap CLI](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#1-installing-bubblewrap-cli)
  - [2\. Initializing Your Project](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#2-initializing-your-project)
  - [3\. Building the Android APK](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#3-building-the-android-apk)
  - [4\. Publish Digital Asset Links](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#4-publish-digital-asset-links)
- [Testing Your App](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#testing-your-app)
- [Updating your TWA](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#updating-your-twa)
- [Publishing to dApp Store](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa#publishing-to-dapp-store)

## Solana dApp Store Guide
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/intro#__docusaurus_skipToContent_fallback)

On this page

The Solana dApp Store is the crypto-friendly app store for Solana Mobile devices.

# Quickstart

Wherever you are in your publishing journey, you can find resources here to get started.

### What apps can be published to the dApp Store?

−

Both Android apps and web apps!

If you:

- Have an existing Android app, you're ready to start publishing now!
- Have a web app, you can convert a PWA into an Android app and generate an APK for app submission!

Before publishing, ensure your dApp complies with the Solana dApp Store [publisher policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy).

[_![](https://docs.solanamobile.com/img/rocket-icon2.png)_ **Publish your dApp**\\
\\
Follow the step-by-step guide to publish your app to the Solana dApp Store.](https://docs.solanamobile.com/dapp-publishing/submit-new-app)

[_![](https://docs.solanamobile.com/img/pwa-icon.png)_ **Convert a PWA to an APK**\\
\\
Learn how to convert a PWA to an Android app and publish on the dApp Store.](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa)

### Do I need a Solana Mobile device to build an app for the dApp Store?

+

### I've published my app! How can I promote it?

+

## More resources [​](https://docs.solanamobile.com/dapp-publishing/intro\#more-resources "Direct link to More resources")

[🚀\\
\\
**Publish a dApp**\\
\\
Follow the step-by-step guide to publish your app to the Solana dApp Store.](https://docs.solanamobile.com/dapp-publishing/submit-new-app)

[_![](https://docs.solanamobile.com/img/pwa-icon.png)_ **Progressive Web Apps (PWAs)**\\
\\
Learn how to convert a PWA to an Android app and publish on the dApp Store.](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa)

[❓\\
\\
**Frequently Asked Questions**\\
\\
See the list of frequently asked questions about the Solana dApp Store and its publishing process.](https://docs.solanamobile.com/dapp-publishing/qanda)

[📜\\
\\
**Publisher Policy**\\
\\
Learn about the dApp Store mission statement and publisher policy.](https://docs.solanamobile.com/dapp-publishing/publisher-policy)

- [More resources](https://docs.solanamobile.com/dapp-publishing/intro#more-resources)

## Android Device Testing
[Skip to main content](https://docs.solanamobile.com/react-native/test-with-any-android-device#__docusaurus_skipToContent_fallback)

On this page

Seeker is an Android phone at its core. For 99% of development and testing, you can use:

- Any Android device
- Android emulator from Android Studio
- Any standard Android API

Your app will behave the same way on Seeker as it does on any other Android device.

## Mock MWA Wallet [​](https://docs.solanamobile.com/react-native/test-with-any-android-device\#mock-mwa-wallet "Direct link to Mock MWA Wallet")

If your app uses Mobile Wallet Adapter, we recommend testing against the [Mock MWA Wallet](https://github.com/solana-mobile/mock-mwa-wallet) \- a testing wallet that simulates Seed Vault Wallet functionality.

Mock MWA Wallet features:

- Mobile Wallet Adapter support for `authorize`, `signIn`, `signAndSendTransactions`, and `signMessage`.
- Apple pay-like transaction signing (Bottom sheet approval, no app switch)
- Biometric authentication
- Configurable Ed25519 private key importing

For installation, view the [**Github repository**](https://github.com/solana-mobile/mock-mwa-wallet).

Mock MWA Wallet

- [Mock MWA Wallet](https://docs.solanamobile.com/react-native/test-with-any-android-device#mock-mwa-wallet)

## iOS Wallet Signing Insights
[Skip to main content](https://docs.solanamobile.com/blog#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## Solana Mobile Archive
[Skip to main content](https://docs.solanamobile.com/blog/archive#__docusaurus_skipToContent_fallback)

### 2025 [​](https://docs.solanamobile.com/blog/archive\#2025 "Direct link to 2025")

- [November 21 \- Wallet Signing on iOS](https://docs.solanamobile.com/blog/ios-wallet-signing)

## iOS Wallet Signing Insights
[Skip to main content](https://docs.solanamobile.com/blog/ios-wallet-signing#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/ios-wallet-signing\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

- [Mobile Wallet Adapter](https://docs.solanamobile.com/blog/ios-wallet-signing#mobile-wallet-adapter)
- [Issues with Deep Linking](https://docs.solanamobile.com/blog/ios-wallet-signing#issues-with-deep-linking)
  - [1\. Excessive Context Switching](https://docs.solanamobile.com/blog/ios-wallet-signing#1-excessive-context-switching)
  - [2\. Wallet Selection Issues](https://docs.solanamobile.com/blog/ios-wallet-signing#2-wallet-selection-issues)
  - [3\. Hacky response handling](https://docs.solanamobile.com/blog/ios-wallet-signing#3-hacky-response-handling)
- [Solutions](https://docs.solanamobile.com/blog/ios-wallet-signing#solutions)
  - [Solutions for dApp developers](https://docs.solanamobile.com/blog/ios-wallet-signing#solutions-for-dapp-developers)
  - [Solutions for Wallet apps](https://docs.solanamobile.com/blog/ios-wallet-signing#solutions-for-wallet-apps)
- [Conclusion](https://docs.solanamobile.com/blog/ios-wallet-signing#conclusion)

## Solana Mobile Tags
[Skip to main content](https://docs.solanamobile.com/blog/tags#__docusaurus_skipToContent_fallback)

# Tags

## C [​](https://docs.solanamobile.com/blog/tags\#C "Direct link to C")

- [custody1](https://docs.solanamobile.com/blog/tags/custody)

* * *

## I [​](https://docs.solanamobile.com/blog/tags\#I "Direct link to I")

- [iOS1](https://docs.solanamobile.com/blog/tags/i-os)

* * *

## M [​](https://docs.solanamobile.com/blog/tags\#M "Direct link to M")

- [mobile-wallet-adapter1](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter)
- [MWA1](https://docs.solanamobile.com/blog/tags/mwa)

* * *

## P [​](https://docs.solanamobile.com/blog/tags\#P "Direct link to P")

- [passkeys1](https://docs.solanamobile.com/blog/tags/passkeys)

* * *

## S [​](https://docs.solanamobile.com/blog/tags\#S "Direct link to S")

- [Safari Web Extension1](https://docs.solanamobile.com/blog/tags/safari-web-extension)
- [signing1](https://docs.solanamobile.com/blog/tags/signing)

* * *

## T [​](https://docs.solanamobile.com/blog/tags\#T "Direct link to T")

- [transaction1](https://docs.solanamobile.com/blog/tags/transaction)

* * *

## iOS Wallet Adapter Insights
[Skip to main content](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/mobile-wallet-adapter\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Signing Solutions
[Skip to main content](https://docs.solanamobile.com/blog/tags/mwa#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/mwa\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/mwa\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/mwa\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/mwa\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/mwa\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/mwa\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/mwa\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/mwa\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/mwa\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/mwa\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/mwa\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/mwa\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/mwa\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/mwa\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/mwa\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/mwa\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Signing Issues
[Skip to main content](https://docs.solanamobile.com/blog/tags/passkeys#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/passkeys\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/passkeys\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/passkeys\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/passkeys\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/passkeys\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/passkeys\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/passkeys\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/passkeys\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/passkeys\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/passkeys\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/passkeys\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/passkeys\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/passkeys\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/passkeys\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/passkeys\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/passkeys\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Signing Solutions
[Skip to main content](https://docs.solanamobile.com/blog/tags/safari-web-extension#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/safari-web-extension\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Signing Insights
[Skip to main content](https://docs.solanamobile.com/blog/tags/signing#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/signing\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/signing\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/signing\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/signing\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/signing\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/signing\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/signing\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/signing\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/signing\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/signing\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/signing\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/signing\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/signing\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/signing\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/signing\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/signing\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## iOS Wallet Signing Solutions
[Skip to main content](https://docs.solanamobile.com/blog/tags/transaction#__docusaurus_skipToContent_fallback)

This article aims to address questions around the state of **wallet signing** and **key custody** on iOS.

That is -- How can iOS mobile dApps enable native transaction signing?

We commonly see the same questions and ideas being raised across different social medias and platforms, so one goal of this article is to share all the insights from the Solana Mobile team's research into different iOS solutions.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/blog/tags/transaction\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

First, we need to understand why the current implementation of MWA (Mobile Wallet Adapter) is incompatible with iOS.

In the MWA Android SDKs, web socket servers are used to establish a persistent background connection between the dApp and the wallet app. This is an ongoing two-way channel that allows the dApp to seamlessly exchange messages with the wallet, asking for authorization, signing, etc.

On iOS, this type of persistent communication is not possible because of the strict limitations around iOS app background execution. When an iOS app is backgrounded, the operating system will suspend the app, thus disabling any on-going network communication from the app. This means the MWA implementation using local (or even remote) web sockets is not possible on iOS.

## Issues with Deep Linking [​](https://docs.solanamobile.com/blog/tags/transaction\#issues-with-deep-linking "Direct link to Issues with Deep Linking")

One potential solution that has been brought up is wallet communication through the use of _deep links_ (technically called [_Universal Links_](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content?language=objc) on iOS, but we'll refer to them as deep links throughout this document).

While deep links may sound like a viable solution, they fundamentally cannot provide the same functionality as an MWA persistent connection, nor can they deliver a good user experience.

These are the issues with deep linking as a replacement for MWA on iOS:

### 1\. Excessive Context Switching [​](https://docs.solanamobile.com/blog/tags/transaction\#1-excessive-context-switching "Direct link to 1. Excessive Context Switching")

A typical MWA session requires multiple back and forth message exchanges between a wallet and dApp. This is problematic with deep links because each message triggers a full app switch, which leads to excessive app switches within a full session.

To illustrate this let's look at signing flows, with a hypothetical idealized deep link implementation (In reality, a deep link request/response API would be more convoluted than a simple `deepLinkWalletToX` method, discussed later).

```ts
/** Signing a single transaction */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx = buildTx(walletAddress);
  // Round trip 2
  const signedTransaction = deeplinkWalletToSign(tx, authToken);
}
```

With every additional request, we have to do an additional context switch. This quickly can become jarring for users as the # of requests increases

```tsx
/** Signing two separate transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  const tx2 = buildAnotherTx(walletAddress);

  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx, authToken);

  // Round trip 3
  const signedTx2 = deeplinkWalletToSign(tx, authToken);
}
```

Maybe we can further improve this by batching transactions into a single deep link request.

```tsx
/** Signing batched transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const [tx1, tx2, tx3] = buildTxs(walletAddress);
  // Round trip 2
  const signedTxs = deeplinkWalletToSignAll([tx1, tx2, tx3], authToken);
}
```

That seems better...but what if a request depends on the outcome of a previous request?

Suddenly, we can no longer batch the transactions together and once again need to separate them:

```tsx
/** Signing dependent transactions */
// Round trip 1
const { walletAddress, authToken } = deeplinkWalletToConnect();

if (walletAddress) {
  const tx1 = buildTx(walletAddress);
  // Round trip 2
  const signedTx1 = deeplinkWalletToSign(tx1, authToken);

  // tx2 depends on outcome of tx1
  const tx2 = buildTx(walletAddress, signedTx);
  const signedTx2 = deepLinkWalletToSign(tx2, authToken);
}
```

Deeplinks do not provide the same flexibility as MWA especially for more complicated signing and sending operations. Deeplink UX _can_ be acceptable for simple one-off operations.

### 2\. Wallet Selection Issues [​](https://docs.solanamobile.com/blog/tags/transaction\#2-wallet-selection-issues "Direct link to 2. Wallet Selection Issues")

On Android, wallet apps all register to handle MWA intents with `solana-wallet://` scheme. When an MWA intent is sent out by a dApp, the Android OS displays a _Chooser dialog_ that displays all the installed wallet apps that can implement MWA. This is known as _Intent disambiguation_. Once chosen, the dApp knows which wallet to establish communication with.

This is good UX that allows users to be in control of how they interact with your app.

On iOS, there is no _disambiguation_ step when handling a particular deeplink/scheme. While multiple iOS apps can register to handle a standard link like `solana-wallet://`, the system does not provide a _Chooser dialog_ equivalent to Android's. Instead, it default opens the wallet app that was installed first.

This is bad UX that can be unexpected, confusing, and frustrating behavior for the user.

##### Master Wallet List Solution? [​](https://docs.solanamobile.com/blog/tags/transaction\#master-wallet-list-solution "Direct link to Master Wallet List Solution?")

A potential solution is for each wallet to designate their own custom deep link scheme to handle MWA requests on iOS (ie: `wallet-name://mwa/...`). Then the dApp would then fetch some _master list_ of all wallet links, check if they're available on the user's device, then show a UI that allows users to choose the wallet (essentially creating a _Chooser dialog_ UI for your dApp).

The master list should have 3 qualities:

1. Easily accessible to the dApp.
2. Easy for wallets to add themselves to the list.
3. Consistently up-to-date and include additions from new wallets.

**This solution seems promising at first, but runs into major pitfalls**.

The master wallet list solution introduces several issues:

**Inconsistent Selection UX**

If every app implements their own selection UI, then wallet selection UX will be inconsistent across the entire Solana mobile dApp ecosystem. Inconsistent UX will be confusing and frustrating to users, especially those unfamiliar and new to web3 patterns.

**Cluttered Selection UI**

Within this hypothetical selection UI, users would have to search through the entire master list of wallets to find their desired wallet. There isn't a way a dApp can narrow down the options to only installed wallets, while maintaining requirement 3. (\*\*See footnote 1, on why we can't narrow the selection). This is a bad user experience and this issue can be seen in the Ethereum ecosystem with the prevalent usage of WalletConnect.

**Manual Maintenance Burden**

There is a manual maintenance burden in keeping this master list of wallets up to date. In general, manually maintained lists of wallets is a pattern the Solana ecosystem is moving away from, exemplified by the deprecation of Wallet Adapter in favor of the generalized Wallet Standard on the web.

### 3\. Hacky response handling [​](https://docs.solanamobile.com/blog/tags/transaction\#3-hacky-response-handling "Direct link to 3. Hacky response handling")

Deep links are not designed for back and forth communication of messages. Thus, attempting to create a request and response protocol on top of deep links will lead to hacky patterns and architectures to request and receive responses.

For example, lets say you have a Swift function `sendWalletConnectRequest` that initiates a deep link connect request. Usually, this is executed in some connect button view.

```swift
// Called within some ConnectButtonView/Screen
func sendWalletConnectRequest() {
	if let url = URL(string: walletConnectDeepLink) {
		UIApplication.shared.open(url, options: [:], completionHandler: nil)
	}
}
```

**Unlike with Android intents, there is no callback mechanism to "receive" the response from the URL/app you've opened.**

The only way to "receive" the response, is to detect when your app has been opened with your specific connect response scheme (ie: `your-dapp-scheme://connect-response`)

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// How do you send this data back to the component/screen/UI you
		// initially sent the request from?
    }

    return true
}
```

Detecting a "response" happens within your `AppDelegate` or `SceneDelegate`, which is completely disconnected from the call site of the initial request (ie `ConnectButtonView`).

You'll need to build a (most likely hacky) implementation to post/publish the response back to the call site of the request.

```swift
func application(_ app: UIApplication, open url: URL, options:
				 [UIApplication.OpenURLOptionsKey : Any] = [:]) -> Bool {

	// Detect and handle connect response scheme.
    if url.scheme == "your-dapp-scheme" && url.host == "connect-response" {
		// Then parse the "response" from the url query params.
		let connectData = parseConnectResponse(url)

		// Post this response data back to the callee
		NotificationCenter.default.post(name: .didReceiveConnectResponse,
			bject: nil, userInfo: ["connectData": connectData])
    }

    return true
}
```

Using deep links as a communication protocol between two apps is **fundamentally going against what they were designed for**. Although possible, it leads to precarious implementations and can even expose a risk during the Apple app review process. Apple cares about user experience and may be inclined to reject apps that heavily rely on this improper usage of deep links.

## Solutions [​](https://docs.solanamobile.com/blog/tags/transaction\#solutions "Direct link to Solutions")

There is still a way forward to enable iOS transaction signing and custody while also delivering a good user experience.

As discussed above, iOS presents challenges in enabling inter-app communication. This is problematic for the _traditional model_ of key custody, where a wallet app stores the key pair. In the past year, we have seen dApps are exploring different models of key custody for product spaces where the traditional model have too much friction.

##### Traditional Key Custody Model [​](https://docs.solanamobile.com/blog/tags/transaction\#traditional-key-custody-model "Direct link to Traditional Key Custody Model")

- Keypair is stored in the wallet app
- dApp needs to request approval for each action
- Born out of DeFi and NFT related use cases

##### Alternative Key Custody Model [​](https://docs.solanamobile.com/blog/tags/transaction\#alternative-key-custody-model "Direct link to Alternative Key Custody Model")

- Keypair can be stored per app
- No inter-app communication required
- Enables newer use cases that need less friction (e.g: gaming)

For these alternative key custody solutions, there is a viable solution forward for iOS dApps. Let's approach the solutions from two perspectives: dApp developers and wallet apps.

### Solutions for dApp developers [​](https://docs.solanamobile.com/blog/tags/transaction\#solutions-for-dapp-developers "Direct link to Solutions for dApp developers")

#### Wallet-as-a-service [​](https://docs.solanamobile.com/blog/tags/transaction\#wallet-as-a-service "Direct link to Wallet-as-a-service")

A growing solution for native iOS apps is to use a _wallet-as-a-service_ provider.

In general, these services enable dApps to have a "per-app" wallet for each user, rather than relying on a user having a self-custody wallet app. The provider is involved managing/storing the keypair with their own implementation (ie: MPC-TSS, MPC-SSS).

The relevant advantages of this solution:

1. Users can onboard quicker, reducing the additional step of installing another app.
2. Uses patterns like Social and Email login that are familiar to Web2 users.
3. No inter-app communication required, so this model works on iOS.

There are many different provider services and each offer varying levels of security, decentralization, and UX. A dApp developer should research and evaluate the trade-offs of this solution and make the correct decision for their product space.

Further discussion about the technical implementation of wallet-as-a-service providers are out of scope for this blog post, but [this article from Particle Network](https://blog.particle.network/embedded-web3-wallets-how-to-choose-a-wallet-service) gives an in-depth comparison of the different providers, implementations, and tradeoffs.

#### Passkeys [​](https://docs.solanamobile.com/blog/tags/transaction\#passkeys "Direct link to Passkeys")

Passkeys are an emerging solution for key custody across mobile and desktop devices. Passkeys use public key cryptography to securely store secrets for apps and websites. A public key is stored on the server, while the private key is securely stored on the device. They are a generalized solution to store secrets like account passwords, but can be used in a roundabout manner for web3 purposes (ie: storing keypairs). For iOS, Apple provides a system level API for developers to integrate passkeys into an app.

The advantages of passkeys:

1. Users do not need to remember a _password_ to access their secrets. Instead they use biometrics like FaceID or fingerprint scanning to unlock their secrets, which is arguably both more convenient and secure for users.
2. Phishing resistant. Passkeys are intrinsically linked with the app or website they were created for, so people can never be tricked into using their passkey to sign in to a fraudulent app or website.

Passkeys are a relatively new and developing technology, so there are some challenges that affect usage on each platform:

1. Currently, passkey support is not consistent across platforms. In general, the web, specifically Safari, has the best passkey support. Android has a more limited API, and not all
browsers support the same features/API. Although, it's reasonable to expect that passkey API and support grow more standardized, aligned, and stable.

2. Passkeys do not support ed25519 signing/key storage directly. Instead, the ed25519 keypair itself is encrypted with another scheme, then placed into the passkey. This means when the passkey is retrieved for signing, the ed25519 keypair is exposed to the dApp.


For a more detailed understanding of how passkeys actually store and manage a secret on a device, read the official [Apple docs](https://developer.apple.com/documentation/authenticationservices/public-private_key_authentication/supporting_passkeys/) and [Android docs](https://developers.google.com/identity/passkeys).

### Solutions for Wallet apps [​](https://docs.solanamobile.com/blog/tags/transaction\#solutions-for-wallet-apps "Direct link to Solutions for Wallet apps")

As discussed previously, iOS presents challenges in establishing the inter-app communication necessary for a wallet app. With Safari Web Extensions, however, a wallet app can provide a good UX for their iOS users browsing on _Mobile Web._

#### iOS Safari Web Extension [​](https://docs.solanamobile.com/blog/tags/transaction\#ios-safari-web-extension "Direct link to iOS Safari Web Extension")

iOS users can request wallet signing in the iOS Safari browser through the use of a Solana wallet with a [_Safari Web Extension_](https://developer.apple.com/documentation/safariservices/safari_web_extensions). A Safari Web Extension allows a web page to communicate with an installed iOS wallet app and securely receive signing from that iOS wallet app. The wallet can present their own custom approval UI all within the Safari browser. An example of this is the [Glow iOS wallet](https://glow.app/). The Glow app is a native iOS wallet that also provides a Safari Web Extension for wallet signing while browsing Safari.

As a dApp, no additional implementation work needs to be done to be compatible with a Safari Web Extension. They work just like the typical desktop Chrome extension wallet and will be detected by the standard Solana wallet adapter libraries.

As a wallet, the implementation will be relatively light, if the wallet has an existing Chrome extension implementation. The wallet can make adjustments to convert their Chrome extension wallet into a Safari Web Extension.

To proliferate this UX in the ecosytem, Solana Mobile has provided an [open-source example](https://github.com/solana-mobile/SolanaSafariWalletExtension) of an iOS wallet app that implements a Safari Web Extension. The example includes a native iOS wallet app with basic keypair storage and a Javascript Safari Web Extension that implements a Solana Standard Wallet. Wallet teams can use this example as a reference on how to adapt their Chrome extension to a Safari Web Extension, and unlock iOS browser signing for their users.

## Conclusion [​](https://docs.solanamobile.com/blog/tags/transaction\#conclusion "Direct link to Conclusion")

As a dApp developer, research the different types of solutions presented and decide which creates the best UX for your product space. Evaluate each solution's tradeoff of convenience, trust, and security.

As a wallet developer, we urge you to implement a Safari Web Extension alongside your wallet app to unlock iOS signing on the mobile browser. As mentioned above, use the [open-source example wallet implementation](https://github.com/solana-mobile/SolanaSafariWalletExtension) as a reference and get in contact with the Solana Mobile team.

###### Footnotes [​](https://docs.solanamobile.com/blog/tags/transaction\#footnotes "Direct link to Footnotes")

1. Even when a dApp has the master list of wallet universal links, iOS doesn't provide a reliable way to _narrow_ down the list to only installed wallet apps. There exists [`canOpenUrl`](https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl#return_value), but to use it successfully you must declare the app's supported URL schemes within your Info.plist in advance. This means, if a new wallet is added to the global master list, the dApp can't use `canOpenUrl` to check for its existence until it builds and publishes a new version of the app with the new schemes declared!

## Solana Mobile Grants
## Solana Mobile

## Builder Grants

Supporting developers building the future of onchain mobile.

[Apply Now](https://airtable.com/appw7jfRXG6Joia2b/pagGNMPX6qleBYHNp/form)

[Explore RFPs](https://airtable.com/appw7jfRXG6Joia2b/shrsfJpcHYJZat9Uk)

![](https://framerusercontent.com/images/nTT5P6ZRJRxxJrzhhpyk5MB29sA.png?width=1002&height=753)

![](https://framerusercontent.com/images/A0YVC88bM8ZT3N70Ofxww8eeufU.svg?width=474&height=346)

#### Our Mission

We support developers building mobile-first crypto applications with funding, resources, and ecosystem access to expand what's possible on Solana.

We believe that in the future, most people will experience crypto on mobile. We're funding teams building for that reality: apps using sensors, location, cameras, and real-time payments to unlock what Solana can do in the real world.

![](https://framerusercontent.com/images/hqf6C5GCoQJo1FHWdk89vVl2k4.png?width=764&height=396)

##### Grant Application Guidelines

![](https://framerusercontent.com/images/6YBic2LL11j6RAgNFE2rZX005FQ.svg?width=32&height=32)

**Mobile-First Implementation**

The dApp must demonstrate a mobile-first UX on Android, leveraging native features where appropriate.

![](https://framerusercontent.com/images/DrEDz6jnYbxH8FNr1nOaCtVrJw.svg?width=32&height=32)

**Solana Mobile Stack Use**

Clear implementation of core Solana Mobile Stack (SMS) components, such as the Mobile Wallet Adapter (MWA) and Seed Vault, to enable a seamless, secure mobile crypto experience.

![](https://framerusercontent.com/images/EWdcmJsoaWiob4PK53iFZdpKbA.svg?width=32&height=32)

**Proposed Scope & Milestone Timeline**

A detailed project scope outlining your unique timeline, accompanied by well-structured, thoughtful milestones for phased delivery.

![](https://framerusercontent.com/images/f6pCDmpzQ1CJ8H6MVcFiMEE4Ys.svg?width=32&height=32)

**Team Ability to Execute**

Strong record of past open source contributions, technical expertise, and a clear ability to deliver the mobile application based on the proposed timeline and scope.

![](https://framerusercontent.com/images/J3SuVFX73wYNP2MfdMoOnYCGu0.svg?width=32&height=32)

**Clear Use of Funds**

A detailed budget showing exactly how the requested grant funds will be utilized to achieve the defined milestones and a successful mobile launch.

![](https://framerusercontent.com/images/DrEDz6jnYbxH8FNr1nOaCtVrJw.svg?width=32&height=32)

**Community & Open Source**

Ideally, includes some commitment to a Public Good for the mobile ecosystem (e.g., providing an open-source library, a free community feature)

### Why Build With Us

Whether you're launching your first mobile dApp or scaling to thousands of users, the Solana Mobile Builder Grants Program has resources that match your stage — and rewards you when real users benefit from your work.

[Apply Now](https://airtable.com/appw7jfRXG6Joia2b/pagGNMPX6qleBYHNp/form)

![](https://framerusercontent.com/images/IO2hkroOw3sHm3GiJck3zr4HE.svg?width=32&height=32)

Mobile-First Ecosystem

Build for the Solana Mobile Stack and dApp Store.

![](https://framerusercontent.com/images/IO2hkroOw3sHm3GiJck3zr4HE.svg?width=32&height=32)

Direct Support

Co-marketing, technical guidance, and funds to bootstrap your startup.

![](https://framerusercontent.com/images/IO2hkroOw3sHm3GiJck3zr4HE.svg?width=32&height=32)

Growing Network

Join a community of mobile builders and over 100k power users pushing Solana forward.

![](https://framerusercontent.com/images/pHb0IsCGnZxrLrMjSGUYIEI6UY.png?width=2028&height=1098)

![](https://framerusercontent.com/images/o9WQzPQPUynZhCcFo72XIqtTYsc.svg?width=24&height=24)

Coming Soon

#### ColosseumHackathon Grants

Historically we have offered a Solana Mobile Builder Grants Program running alongside Colosseum Solana Hackathons. With up to $10k for 10 teams that bring mobile into focus. Stay tuned for the next Colosseum Hackathon in Q1 2026.

Get Updates

![](https://framerusercontent.com/images/3jVDzkMVtBs4705oenQaND6EY.svg?width=25&height=25)

##### FAQs

##### Who can submit proposals?

##### Are all RFPs developer-based?

##### How many proposals are accepted?

##### How can I find the current Requests for Proposals (RFPs) and submit a grant application?

##### How long will it take to receive a decision?

##### How are proposals evaluated and selected?

##### Is there any financial or other support available for chosen proposals?

[![](https://framerusercontent.com/images/t1OGf2VmO4CHtCadVnQa72x86E.svg?width=286&height=24)](https://solanamobile.com/)

Resources

[Press Kit](https://solanamobile.com/press)

[Blog](https://blog.solanamobile.com/)

Customer Service

[Return Policy](https://solanamobile.com/return-policy-web)

[Warranty](https://solanamobile.com/seeker-warranty)

[Support](https://solanamobile.com/support)

Legal & Policies

[Terms of Service](https://solanamobile.com/tos-homepage-web)

[Cookie Policy](https://solanamobile.com/cookie-policy-web)

[Privacy Policy](https://solanamobile.com/privacy-policy-homepage-web)

[Deposit Agreement](https://solanamobile.com/deposit-waitlist-agreement-web)

[Terms of Sale](https://solanamobile.com/tos-web)

[MiCA Whitepaper](https://solanamobile.com/mica-whitepaper)

[Cookie Settings](https://solanamobile.com/grants#)

© 2026 Solana Mobile, Inc.

## Solana Mobile Hackathon
![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938bd08a4b850995073576d_Seeker%20Isolated%20White.svg)

[Solana Mobile](https://x.com/solanamobile) & [Radiants](https://x.com/RadiantsDAO) Present:

# MONOLITH

#### Hackathon

[Begin](https://solanamobile.radiant.nexus/#)

Notifications

[order a Seeker](https://store.solanamobile.com/)

![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a393de47e411ab743d5d_portal_neb2.avif)![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a3931cd1ca42401c3fee_portal_neb1.avif)![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a3933c847881594a1229_monolith_neb.avif)

![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a393de47e411ab743d5d_portal_neb2.avif)![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a3931cd1ca42401c3fee_portal_neb1.avif)![](https://cdn.prod.website-files.com/685357732354043b88fbf118/6938a3933c847881594a1229_monolith_neb.avif)

## Solana Mobile Documentation
[Skip to main content](https://docs.solanamobile.com/search#__docusaurus_skipToContent_fallback)

# Search the documentation

[Search by Algolia](https://www.algolia.com/)

## Solana Mobile Tags
[Skip to main content](https://docs.solanamobile.com/tags#__docusaurus_skipToContent_fallback)

# Tags

## C [​](https://docs.solanamobile.com/tags\#C "Direct link to C")

- [chapter-21](https://docs.solanamobile.com/tags/chapter-2)

* * *

## N [​](https://docs.solanamobile.com/tags\#N "Direct link to N")

- [NFT1](https://docs.solanamobile.com/tags/nft)

* * *

## S [​](https://docs.solanamobile.com/tags\#S "Direct link to S")

- [saga1](https://docs.solanamobile.com/tags/saga)

* * *

## Chapter 2 NFTs
[Skip to main content](https://docs.solanamobile.com/tags/chapter-2#__docusaurus_skipToContent_fallback)

[**Chapter 2 Preorder Token NFTs**](https://docs.solanamobile.com/getting-started/chapter2-preorder-token)

An article explaning the distribution and technical details of the Chapter 2 Preorder Token NFTs.

## NFT Resources Overview
[Skip to main content](https://docs.solanamobile.com/tags/nft#__docusaurus_skipToContent_fallback)

[**Chapter 2 Preorder Token NFTs**](https://docs.solanamobile.com/getting-started/chapter2-preorder-token)

An article explaning the distribution and technical details of the Chapter 2 Preorder Token NFTs.

## Preorder Token NFTs
[Skip to main content](https://docs.solanamobile.com/tags/saga#__docusaurus_skipToContent_fallback)

[**Chapter 2 Preorder Token NFTs**](https://docs.solanamobile.com/getting-started/chapter2-preorder-token)

An article explaning the distribution and technical details of the Chapter 2 Preorder Token NFTs.

## Solana dApp Store
[Skip to main content](https://docs.solanamobile.com/additional-sdks/dapp_store_intro#__docusaurus_skipToContent_fallback)

On this page

### Solana dApp Store [​](https://docs.solanamobile.com/additional-sdks/dapp_store_intro\#solana-dapp-store "Direct link to Solana dApp Store")

The Solana dApp Store is an alternate app distribution system, well suited to distributing apps developed by the Solana ecosystem. It will provide a distribution channel for apps that want to establish direct relationships with their customers, without other app stores’ rules restricting the relationship or seeking a large revenue share. The goal of the Solana dApp Store is to empower the Solana community to eventually play a key role in managing the contents of this app store.

For app developers, we will be updating this SDK to include publishing tools and instructions for preparing and submitting your apps for inclusion in the Solana dApp Store catalog. Watch this space for future developments!

- [Solana dApp Store](https://docs.solanamobile.com/additional-sdks/dapp_store_intro#solana-dapp-store)

## Seed Vault SDK
[Skip to main content](https://docs.solanamobile.com/additional-sdks/seedvault_intro#__docusaurus_skipToContent_fallback)

On this page

### [Seed Vault](https://github.com/solana-mobile/seed-vault-sdk) [​](https://docs.solanamobile.com/additional-sdks/seedvault_intro\#seed-vault "Direct link to seed-vault")

The Seed Vault is a system service providing secure key custody to Wallet apps. By integrating with secure execution environments available on mobile devices (such as secure operating modes of the processor and/or secure auxiliary coprocessors), Seed Vault helps to keep your secrets safe, by moving them to the highest privileged environment available on the device. Your keys, seeds, and secrets never leave the secure execution environment, while UI components built into Android handle interaction with the user to provide a secure transaction signing experience to users.

For Wallet apps, this SDK provides an API contract and support library for accessing the Seed Vault. It also includes a Seed Vault simulator, which can be installed on devices running Android 12.

Important note: this Seed Vault simulator does not provide secure transaction signing, and should not be used for any purposes other than development and testing of Wallet apps.

- [Seed Vault](https://docs.solanamobile.com/additional-sdks/seedvault_intro#seed-vault)

## Building Solana Transactions
[Skip to main content](https://docs.solanamobile.com/android-native/building_transactions#__docusaurus_skipToContent_fallback)

On this page

A client interacts with the Solana network by submitting a _transaction_ to the cluster. Transactions
allow a client to invoke instructions of on-chain [_Programs_](https://docs.solana.com/developing/intro/programs).

For a full explanation, see the core docs overview of a [_transaction_](https://docs.solana.com/developing/programming-model/transactions).

## Add dependencies [​](https://docs.solanamobile.com/android-native/building_transactions\#add-dependencies "Direct link to Add dependencies")

The [`web3-solana`](https://github.com/solana-mobile/web3-core) library provides the abstraction classes like `Transaction` and `AccountMeta` to simplify building Solana transactions.

- build.gradle.kts

```
dependencies {
  implementation("com.solanamobile:web3-solana:0.2.5")
}
```

## Example: Memo Program Transaction [​](https://docs.solanamobile.com/android-native/building_transactions\#example-memo-program-transaction "Direct link to Example: Memo Program Transaction")

In the following example, we are creating a `Transaction` that invokes the [Memo Program](https://spl.solana.com/memo) to publish the message "Hello Solana" on-chain.

### Create an instruction [​](https://docs.solanamobile.com/android-native/building_transactions\#create-an-instruction "Direct link to Create an instruction")

A transaction instruction is comprised of a program id, a list of accounts, and instruction data specific to the program.

To create an instruction, define a list of `AccountMeta` that represent the accounts required by the instruction.
Then pass the encoded message as `data` into the `TransactionInstruction` constructor.

```kotlin
import com.solana.publickey.*
import com.solana.transaction.*

// Solana Memo Program
val memoProgramId = "MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr"
val memoProgramIdKey = SolanaPublicKey.from(memoProgramId)

// Construct the instruction
val message = "Hello Solana!"
val memoInstruction = TransactionInstruction(
    memoProgramIdKey,
    // Define the accounts in instruction
    listOf(AccountMeta(address, true, true)),
    // Pass in the instruction data as ByteArray
    message.encodeToByteArray()
)
```

### Create the Memo transaction [​](https://docs.solanamobile.com/android-native/building_transactions\#create-the-memo-transaction "Direct link to Create the Memo transaction")

After creating the instructions, use `Message.Builder()` to assemble the instructions and a _blockhash_ to construct the a _Transaction message_. Then
pass the transaction message into the `Transaction` constructor.

See the previous _Making RPC Requests_ guide for an example of how to fetch a blockhash.

```kotlin
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

// Fetch blockhash from RPC
val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
val blockhasResponse = rpcClient.getLatestBlockhash()

if (response.error) {
    println("Failed to fetch latest blockhash: ${response.error.message}")
    return;
}

// Build transaction message
val memoTxMessage = Message.Builder()
    .addInstruction(memoInstruction) // Pass in instruction from previous step
    .setRecentBlockhash(blockhasResponse.result!!.blockhash)
    .build()

// Construct the Transaction object from the message
val unsignedTx = Transaction(memoTxMessage)
```

## Next steps [​](https://docs.solanamobile.com/android-native/building_transactions\#next-steps "Direct link to Next steps")

Read the following _Using Mobile Wallet Adapter_ guide to learn how to sign these transactions and submit them to the Solana network.

- [Add dependencies](https://docs.solanamobile.com/android-native/building_transactions#add-dependencies)
- [Example: Memo Program Transaction](https://docs.solanamobile.com/android-native/building_transactions#example-memo-program-transaction)
  - [Create an instruction](https://docs.solanamobile.com/android-native/building_transactions#create-an-instruction)
  - [Create the Memo transaction](https://docs.solanamobile.com/android-native/building_transactions#create-the-memo-transaction)
- [Next steps](https://docs.solanamobile.com/android-native/building_transactions#next-steps)

## Constructing JSON-RPC Requests
[Skip to main content](https://docs.solanamobile.com/android-native/building-json-rpc-requests#__docusaurus_skipToContent_fallback)

On this page

This deep dive explains how to use underlying primitives in the `rpc-core` library to construct RPC requests for any methods that aren't provided by `SolanaRpcClient`.

tip

If you only need to use the common RPC methods already supported by `SolanaRpcClient`, read the [_RPC Client usage guide_](https://docs.solanamobile.com/android-native/rpc-requests).

## Add dependencies [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#add-dependencies "Direct link to Add dependencies")

The [`rpc-core`](https://github.com/solana-mobile/rpc-core) library provides core classes and abstractions to build and submit requests according to the JSON-RPC 2.0 specification.

- build.gradle.kts

```
dependencies {
  implementation("com.solanamobile:rpc-core:0.2.7")
}
```

## Creating a JSON RPC Request [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#creating-a-json-rpc-request "Direct link to Creating a JSON RPC Request")

The `rpc-core` library defines a `JsonRpc20Request` constructor to conveniently construct a Solana JSON RPC request.

Populate the JSON object with the method name and JSON serialized parameters of a [Solana RPC method](https://docs.solana.com/api/http). The
constructor also includes a `requestId` parameter, as per JSON-RPC spec.

### Example: `getLatestBlockhash` RPC request [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#example-getlatestblockhash-rpc-request "Direct link to example-getlatestblockhash-rpc-request")

```kotlin
fun createBlockhashRequest(commitment: String = "confirmed", requestId: String = "1") =
    JsonRpc20Request(
        // JSON RPC Method (ie: `getLatestBlockhash`, `getSignatureForAddresses`)
        method = "getLatestBlockhash",
        // Populate with JSON parameters
        params = buildJsonArray {
            addJsonObject {
                put("commitment", commitment)
            }
        },
        requestId
    )
```

## Defining the JSON RPC Response [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#defining-the-json-rpc-response "Direct link to Defining the JSON RPC Response")

After creating the request, create [Kotlin serializable classes](https://kotlinlang.org/docs/serialization.html#libraries) that define the expected response payload for that request.

In the following example, we are defining the expected response of the `getLatestBlockhash` request using the `kotlinx.serialization` library.

### Example: `getLatestBlockhash` RPC response [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#example-getlatestblockhash-rpc-response "Direct link to example-getlatestblockhash-rpc-response")

```kotlin
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.*

@Serializable
class BlockhashResponse(val value: BlockhashInfo)

@Serializable
class BlockhashInfo(
    val blockhash: String,
    val lastValidBlockHeight: Long
)

// Additionally, define an exception in case of failure during request
class BlockhashException(message: String? = null, cause: Throwable? = null) : RuntimeException(message, cause)
```

## Implement `HttpNetworkDriver` [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#implement-httpnetworkdriver "Direct link to implement-httpnetworkdriver")

The `rpc-core` library defines a `HttpNetworkDriver` interface that is used to make network requests.

```kotlin
interface HttpRequest {
    val url: String
    val method: String
    val properties: Map<String, String>
    val body: String?
}

interface HttpNetworkDriver {
    suspend fun makeHttpRequest(request: HttpRequest): String
}
```

You can use a common networking package like the Ktor library to implement the `makeHttpRequest` method. The following
is an example from the [Kotlin Jetpack Compose Scaffold sample app](https://github.com/solana-mobile/solana-kotlin-compose-scaffold/blob/main/app/src/main/java/com/example/solanakotlincomposescaffold/networking/HttpDriver.kt).

```kotlin
import com.solana.networking.HttpNetworkDriver
import com.solana.networking.HttpRequest
import io.ktor.client.request.*
import io.ktor.client.HttpClient
import io.ktor.client.engine.android.Android
import io.ktor.client.statement.bodyAsText
import io.ktor.http.HttpMethod

class KtorHttpDriver : HttpNetworkDriver {
    override suspend fun makeHttpRequest(request: HttpRequest): String =
        HttpClient(Android).use { client ->
            client.request(request.url) {
                method = HttpMethod.parse(request.method)
                request.properties.forEach { (k, v) ->
                    header(k, v)
                }
                setBody(request.body)
            }.bodyAsText()
        }
}
```

## Sending RPC requests [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#sending-rpc-requests "Direct link to Sending RPC requests")

After putting these parts together, use the `Rpc20Driver` class to point to an RPC uri, send
the request, and receive a response.

```kotlin
// import com.example.solanakotlincomposescaffold.networking.KtorHttpDriver
import com.solana.networking.Rpc20Driver
import com.solana.rpccore.JsonRpc20Request
import com.solana.transaction.Blockhash
import java.util.UUID

fun getLatestBlockhash(): Blockhash {
    // Create the Rpc20Driver and specify the RPC uri and network driver
    val rpc = Rpc20Driver("https://api.devnet.solana.com", KtorHttpDriver())

    // Construct the RPC request
    val requestId = UUID.randomUUID().toString()
    val request = createBlockhashRequest(commitment, requestId)

    // Send the request and provide the serializer for the expected response
    val response = rpc.makeRequest(request, BlockhashResponse.serializer())

    response.error?.let { error ->
        throw BlockhashException("Could not fetch latest blockhash: ${error.code}, ${error.message}")
    }

    // Unwrap the response to receive the base58 blockhash string
    val base58Blockhash = response.result?.value?.blockhash

    // Return a `Blockhash` object from the web3-solana library
    Blockhash.from(base58Blockhash
        ?: throw BlockhashException("Could not fetch latest blockhash: UnknownError"))
}
```

## Next steps [​](https://docs.solanamobile.com/android-native/building-json-rpc-requests\#next-steps "Direct link to Next steps")

- Browse the [full list](https://docs.solana.com/api/http) of Solana RPC HTTP Methods

- [Add dependencies](https://docs.solanamobile.com/android-native/building-json-rpc-requests#add-dependencies)
- [Creating a JSON RPC Request](https://docs.solanamobile.com/android-native/building-json-rpc-requests#creating-a-json-rpc-request)
  - [Example: `getLatestBlockhash` RPC request](https://docs.solanamobile.com/android-native/building-json-rpc-requests#example-getlatestblockhash-rpc-request)
- [Defining the JSON RPC Response](https://docs.solanamobile.com/android-native/building-json-rpc-requests#defining-the-json-rpc-response)
  - [Example: `getLatestBlockhash` RPC response](https://docs.solanamobile.com/android-native/building-json-rpc-requests#example-getlatestblockhash-rpc-response)
- [Implement `HttpNetworkDriver`](https://docs.solanamobile.com/android-native/building-json-rpc-requests#implement-httpnetworkdriver)
- [Sending RPC requests](https://docs.solanamobile.com/android-native/building-json-rpc-requests#sending-rpc-requests)
- [Next steps](https://docs.solanamobile.com/android-native/building-json-rpc-requests#next-steps)

## Kotlin Android Guide
[Skip to main content](https://docs.solanamobile.com/android-native/overview#__docusaurus_skipToContent_fallback)

On this page

Kotlin is an [officially supported](https://developer.android.com/kotlin) programming language for Android development and is used to build native Android apps.

This section of the site provides a developer guide for building Kotlin Android apps for Solana.

## Quickstart [​](https://docs.solanamobile.com/android-native/overview\#quickstart "Direct link to Quickstart")

[_![](https://docs.solanamobile.com/img/android_icon.svg)_ **Project Setup**\\
\\
Setup your Android project with the core Kotlin SDKs for Solana development.](https://docs.solanamobile.com/android-native/setup)

[_![](https://docs.solanamobile.com/img/jetpack-compose-icon.png)_ **Jetpack Compose Starter App**\\
\\
Clone the Jetpack Compose Scaffold app to quickly start developing.](https://docs.solanamobile.com/android-native/quickstart)

## Core Kotlin SDKs [​](https://docs.solanamobile.com/android-native/overview\#core-kotlin-sdks "Direct link to Core Kotlin SDKs")

Read these guides for a collection of code snippets and examples for basic use cases commonly used in Solana Kotlin dApps.

[🌐\\
\\
**JSON RPC Requests**\\
\\
Learn the rpc-core library to create and send Solana RPC Requests.](https://docs.solanamobile.com/android-native/rpc-requests)

[🔧\\
\\
**Transaction building**\\
\\
Use the web3-core library to construct Solana transactions and Program instructions.](https://docs.solanamobile.com/android-native/building_transactions)

[📱\\
\\
**Mobile Wallet Adapter**\\
\\
Learn how to connect to mobile wallets and request signing services.](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter)

## Benefits of native Android development [​](https://docs.solanamobile.com/android-native/overview\#benefits-of-native-android-development "Direct link to Benefits of native Android development")

### Direct access to Android OS features [​](https://docs.solanamobile.com/android-native/overview\#direct-access-to-android-os-features "Direct link to Direct access to Android OS features")

Developing on Android enables convenient and full access to the Android platform's capabilities. Developers can access OS-specific functionalities like Camera SDK, ARKit, Touch ID, hardware sensors, etc without needing any bridging.

### Optimized performance [​](https://docs.solanamobile.com/android-native/overview\#optimized-performance "Direct link to Optimized performance")

Native Android apps, as a result of full utilization of the system capabilities, generally have better performance and efficiency. Native apps provide the highest attainable frame rates, computing power, graphics support, etc.

### Jetpack Compose [​](https://docs.solanamobile.com/android-native/overview\#jetpack-compose "Direct link to Jetpack Compose")

Kotlin enables the building of Android apps using [Jetpack Compose](https://developer.android.com/jetpack/compose/why-adopt), a modern toolkit for creating native Android UIs. The Kotlin sample apps
on this documentation site are all built with Jetpack Compose.

- [Quickstart](https://docs.solanamobile.com/android-native/overview#quickstart)
- [Core Kotlin SDKs](https://docs.solanamobile.com/android-native/overview#core-kotlin-sdks)
- [Benefits of native Android development](https://docs.solanamobile.com/android-native/overview#benefits-of-native-android-development)
  - [Direct access to Android OS features](https://docs.solanamobile.com/android-native/overview#direct-access-to-android-os-features)
  - [Optimized performance](https://docs.solanamobile.com/android-native/overview#optimized-performance)
  - [Jetpack Compose](https://docs.solanamobile.com/android-native/overview#jetpack-compose)

## Solana RPC Requests Guide
[Skip to main content](https://docs.solanamobile.com/android-native/rpc-requests#__docusaurus_skipToContent_fallback)

On this page

To interface with the Solana network, a client needs to construct and send [_JSON RPC requests_](https://docs.solana.com/api/http) to an [_RPC endpoint_](https://docs.solana.com/cluster/rpc-endpoints).

This guide will teach you how to use the `SolanaRpcClient` and send these RPC requests.

## Add dependencies [​](https://docs.solanamobile.com/android-native/rpc-requests\#add-dependencies "Direct link to Add dependencies")

The [`rpc-core`](https://github.com/solana-mobile/rpc-core) library provides a convenient `SolanaRpcClient` that implements an API to call these RPC methods and return responses.

- build.gradle.kts

```groovy
dependencies {
    implementation("com.solanamobile:rpc-core:0.2.6")
}
```

## Create an RPC Client [​](https://docs.solanamobile.com/android-native/rpc-requests\#create-an-rpc-client "Direct link to Create an RPC Client")

To create an instance of a `SolanaRpcClient`, pass in:

- an RPC `url` that the client will send requests.
- a `networkDriver` used to send HTTP requests.

In this example, we construct an RPC client pointed at devnet and Ktor as a network driver:

```kotlin
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
```

## Example: Fetching latest blockhash [​](https://docs.solanamobile.com/android-native/rpc-requests\#example-fetching-latest-blockhash "Direct link to Example: Fetching latest blockhash")

Calling the `getLatestBlockhash` method returns an [`RpcResponse`](https://github.com/solana-mobile/rpc-core/blob/a6ea1466fb1d79113ca77f2d073d33a85fb5ad5e/rpccore/src/commonMain/kotlin/com/solana/rpccore/RpcResponse.kt#L6).

- If successful, the response result will contain a [`BlockhashResult`](https://github.com/solana-mobile/rpc-core/blob/a6ea1466fb1d79113ca77f2d073d33a85fb5ad5e/solanaclient/src/commonMain/kotlin/com/solana/rpc/SolanaRpcClient.kt#L232).

- If an error occured, the response will contain an [`RpcError`](https://github.com/solana-mobile/rpc-core/blob/a6ea1466fb1d79113ca77f2d073d33a85fb5ad5e/rpccore/src/commonMain/kotlin/com/solana/rpccore/RpcResponse.kt#L16).


```kotlin
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())

val response = rpcClient.getLatestBlockhash()

if (response.result) {
    println("Latest blockhash: ${response.result.blockhash}")
} else if (response.error) {
    println("Failed to fetch latest blockhash: ${response.error.message}")
}
```

## Example: Sending a transaction [​](https://docs.solanamobile.com/android-native/rpc-requests\#example-sending-a-transaction "Direct link to Example: Sending a transaction")

To submit a transaction to the RPC, use the `sendTransaction` method.

- If successful, the response result will contain a transaction signature string.

- If an error occured, the response will contain an [`RpcError`](https://github.com/solana-mobile/rpc-core/blob/a6ea1466fb1d79113ca77f2d073d33a85fb5ad5e/rpccore/src/commonMain/kotlin/com/solana/rpccore/RpcResponse.kt#L16).


```kotlin
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())

val transaction = Transaction(/* ... */)

/* ...sign the transaction... */

val response = rpc.sendTransaction(transaction)

if (response.result) {
    println("Transaction signature: ${response.result}")
} else if (response.error) {
    println("Failed to send transaction: ${response.error.message}")
}
```

## Next steps [​](https://docs.solanamobile.com/android-native/rpc-requests\#next-steps "Direct link to Next steps")

These examples are just some of the methods supported by `SolanaRpcClient`. Here are suggestions to continue learning:

- Read the following guide to learn how to build Solana program instructions and transactions.
- For a complete reference of the RPC methods supported, view the `SolanaRpcClient` [source code](https://github.com/solana-mobile/rpc-core/blob/main/solanaclient/src/commonMain/kotlin/com/solana/rpc/SolanaRpcClient.kt) and [unit tests](https://github.com/solana-mobile/rpc-core/blob/main/solanaclient/src/commonTest/kotlin/com/solana/rpc/RpcClientTests.kt).
- Read the [_Building JSON RPC requests_ deep dive](https://docs.solanamobile.com/android-native/building-json-rpc-requests) to learn how to create requests for RPC methods that aren't immediately supported by `SolanaRpcClient`.

- [Add dependencies](https://docs.solanamobile.com/android-native/rpc-requests#add-dependencies)
- [Create an RPC Client](https://docs.solanamobile.com/android-native/rpc-requests#create-an-rpc-client)
- [Example: Fetching latest blockhash](https://docs.solanamobile.com/android-native/rpc-requests#example-fetching-latest-blockhash)
- [Example: Sending a transaction](https://docs.solanamobile.com/android-native/rpc-requests#example-sending-a-transaction)
- [Next steps](https://docs.solanamobile.com/android-native/rpc-requests#next-steps)

## Sending SOL Transactions
[Skip to main content](https://docs.solanamobile.com/android-native/sending-sol#__docusaurus_skipToContent_fallback)

On this page

This example will walkthrough the steps to build a transaction that sends SOL from a user's wallet to another wallet.

To achieve this, you will write code that:

1. Builds a transaction that invokes the System Program's `transfer` instruction
2. Connects to the user's wallet to retrieve their wallet address
3. Prompt the user to sign the transaction with Mobile Wallet Adapter

## Build a transfer transaction [​](https://docs.solanamobile.com/android-native/sending-sol\#build-a-transfer-transaction "Direct link to Build a transfer transaction")

Write a helper method `buildTransferTransaction` that handles creating the transfer instruction and assembling it into a `Transaction`.

You can use the `SystemProgram.transfer` util method provided by `web3-solana` to conveniently generate a serialized transfer instruction.

```kotlin
import com.solana.publickey.SolanaPublicKey
import com.solana.transaction.*

fun buildTransferTransaction(
    blockhash: String,
    fromPublicKey: SolanaPublicKey,
    toPublicKey: SolanaPublicKey,
    lamports: Long
): Transaction {
    val transferTxMessage = Message.Builder()
        .addInstruction(
            SystemProgram.transfer(
                fromPublicKey,
                toPublicKey,
                lamports
            )
        )
        .setRecentBlockhash(blockhash)
        .build()

    return Transaction(transferTxMessage)
}
```

tip

## Fetching the latest blockhash [​](https://docs.solanamobile.com/android-native/sending-sol\#fetching-the-latest-blockhash "Direct link to Fetching the latest blockhash")

In this method, we use a `blockhash` parameter. See this [RPC requests guide](https://docs.solanamobile.com/android-native/rpc-requests#example-fetching-latest-blockhash) for an example.

tip

## Instantiate Mobile Wallet Adapter client [​](https://docs.solanamobile.com/android-native/sending-sol\#instantiate-mobile-wallet-adapter-client "Direct link to Instantiate Mobile Wallet Adapter client")

In your app, instantiate a `MobileWalletAdapter` client instance, that will be used to establish a session with the user's mobile wallet app.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

// Define dApp's identity metadata
val solanaUri = Uri.parse("https://yourdapp.com")
val iconUri = Uri.parse("favicon.ico") // resolves to https://yourdapp.com/favicon.ico
val identityName = "Solana Kotlin Transfer Example"

// Construct the client
val walletAdapter = MobileWalletAdapter(connectionIdentity = ConnectionIdentity(
    identityUri = solanaUri,
    iconUri = iconUri,
    identityName = identityName
))
```

## Connect to the user's wallet [​](https://docs.solanamobile.com/android-native/sending-sol\#connect-to-the-users-wallet "Direct link to Connect to the user's wallet")

Assuming you do not currently have the user's wallet address available, you can use Mobile Wallet Adapter
to connect to their mobile wallet app, and learn what their wallet address is.

```kotlin
import com.funkatronics.encoders.Base58
import com.solana.publickey.SolanaPublicKey
import com.solana.mobilewalletadapter.clientlib.*
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val lamportAmount = 1000000
val result = walletAdapter.transact(sender) { authResult ->
    // Retrieve the user wallet address from the MWA authResult
    val userAccountAddress = SolanaPublicKey(authResult.accounts.first().publicKey)

    // Fetch latest blockhash
    val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
    val blockhashResponse = rpcClient.getLatestBlockhash()

    // Use the wallet address to build the transfer transaction
    val transferTx = buildTransferTransaction(
        blockhashResponse.result!!.blockhash,
        userAccountAddress,
        SolanaPublicKey("<address_of_recipient>"),
        lamportAmount
    );

    // ...
}
```

## Sign and send the transaction [​](https://docs.solanamobile.com/android-native/sending-sol\#sign-and-send-the-transaction "Direct link to Sign and send the transaction")

Finally, issue a `signAndSendTransactions` request, prompting the user to sign the transfer transaction
and submit it to the network.

```kotlin
import com.funkatronics.encoders.Base58
import com.solana.publickey.SolanaPublicKey
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val result = walletAdapter.transact(sender) { authResult ->
    // Build a transaction using web3-solana classes
    val userAccountAddress = SolanaPublicKey(authResult.accounts.first().publicKey)

    // Fetch latest blockhash
    val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
    val blockhashResponse = rpcClient.getLatestBlockhash()

    // Use the wallet address to build the transfer transaction
    val transferTx = buildTransferTransaction(
        blockhashResponse.result!!.blockhash,
        userAccountAddress,
        SolanaPublicKey("<address_of_recipient>"),
        lamportAmount
    );

    // Issue a 'signTransactions' request
    signAndSendTransactions(arrayOf(transferTx.serialize()));
}

// Read the results!
when (result) {
    is TransactionResult.Success -> {
        val txSignatureBytes = result.successPayload?.signatures?.first()
        txSignatureBytes?.let {
            println("Transaction signature: " + Base58.encodeToString(signedTxBytes))
        }
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error during signing and sending transactions: " + result.e.message)
    }
}
```

If signing is successful, you can check the returned `result` for the transaction signature, or handle failure cases.

## Next steps [​](https://docs.solanamobile.com/android-native/sending-sol\#next-steps "Direct link to Next steps")

Check out the [Kotlin Compose Scaffold](https://github.com/solana-mobile/solana-kotlin-compose-scaffold) for a code examples of what is discussed in this guide, and an easy launching point to getting started with Solana Kotlin development!

- [Build a transfer transaction](https://docs.solanamobile.com/android-native/sending-sol#build-a-transfer-transaction)
- [Fetching the latest blockhash](https://docs.solanamobile.com/android-native/sending-sol#fetching-the-latest-blockhash)
- [Instantiate Mobile Wallet Adapter client](https://docs.solanamobile.com/android-native/sending-sol#instantiate-mobile-wallet-adapter-client)
- [Connect to the user's wallet](https://docs.solanamobile.com/android-native/sending-sol#connect-to-the-users-wallet)
- [Sign and send the transaction](https://docs.solanamobile.com/android-native/sending-sol#sign-and-send-the-transaction)
- [Next steps](https://docs.solanamobile.com/android-native/sending-sol#next-steps)

## Solana Android Setup
[Skip to main content](https://docs.solanamobile.com/android-native/setup#__docusaurus_skipToContent_fallback)

On this page

### Prerequisites [​](https://docs.solanamobile.com/android-native/setup\#prerequisites "Direct link to Prerequisites")

- Download [Android Studio](https://developer.android.com/studio) for development and device management.

- Follow the [prerequisite setup](https://docs.solanamobile.com/developers/development-setup#prerequisite-setup) guide to set up your [Android Device/Emulator](https://docs.solanamobile.com/developers/development-setup#2-setup-deviceemulator) and install a MWA-compatible wallet, like [fakewallet](https://docs.solanamobile.com/developers/development-setup#3-install-a-wallet-app).


## Solana Mobile Kotlin Compose Scaffold [​](https://docs.solanamobile.com/android-native/setup\#solana-mobile-kotlin-compose-scaffold "Direct link to Solana Mobile Kotlin Compose Scaffold")

The quickest way to start developing on Kotlin is to build off of the [Solana Jetpack Compose Scaffold](https://github.com/solana-mobile/solana-kotlin-compose-scaffold) example.

The scaffold is a basic Solana Android app built with [Jetpack Compose](https://developer.android.com/jetpack/compose) and Material 3 components.

Follow the quickstart guide to install and run the scaffold app.

[Quickstart](https://docs.solanamobile.com/android-native/quickstart)

## Android Project Setup [​](https://docs.solanamobile.com/android-native/setup\#android-project-setup "Direct link to Android Project Setup")

### Setting up a fresh Android Project [​](https://docs.solanamobile.com/android-native/setup\#setting-up-a-fresh-android-project "Direct link to Setting up a fresh Android Project")

Follow these steps to setup a fresh Android project with the recommended libraries for Solana development.

#### Step 1: Navigate to your Android project's build.gradle file [​](https://docs.solanamobile.com/android-native/setup\#step-1-navigate-to-your-android-projects-buildgradle-file "Direct link to Step 1: Navigate to your Android project's build.gradle file")

In Android Studio, navigate to your Android project's module `build.gradle.kts` file.

#### Step 2. Add Solana dependencies [​](https://docs.solanamobile.com/android-native/setup\#step-2-add-solana-dependencies "Direct link to Step 2. Add Solana dependencies")

Include the following dependencies to your Android project's `build.gradle.kts` file. These
are the recommended core Kotlin libraries for Solana transaction building, RPC requests, and wallet signing.

- build.gradle.kts

```
dependencies {
  implementation("com.solanamobile:mobile-wallet-adapter-clientlib-ktx:2.0.3")
  implementation("com.solanamobile:web3-solana:0.2.5")
  implementation("com.solanamobile:rpc-core:0.2.7")
  implementation("io.github.funkatronics:multimult:0.2.3")
}
```

Overview of each dependency:

- `com.solanamobile:mobile-wallet-adapter-clientlib-ktx`: Mobile Wallet Adapter client library for interacting with MWA-compatible wallets.
- `com.solanamobile:web3-solana`: Solana Kotlin library providing core Solana primitives like transaction building and public key class.
- `com.solanamobile:rpc-core`: A Kotlin library providing a generic interface and abstractions for building Solana RPC requests.
- `io.github.funkatronics:multimult`: Lightweight utility library for Base58 conversions.

#### Step 3. Build and run your app [​](https://docs.solanamobile.com/android-native/setup\#step-3-build-and-run-your-app "Direct link to Step 3. Build and run your app")

Your project's dependencies should be set up and you can try building and run the app!

## Next Steps [​](https://docs.solanamobile.com/android-native/setup\#next-steps "Direct link to Next Steps")

Congrats! At this point, you have installed the necessary libraries for your project and are ready to start building an app that interacts with the Solana network.

Check out the other resources on this site like guides, SDK references, and sample apps to learn more about what you can do.

- [Prerequisites](https://docs.solanamobile.com/android-native/setup#prerequisites)
- [Solana Mobile Kotlin Compose Scaffold](https://docs.solanamobile.com/android-native/setup#solana-mobile-kotlin-compose-scaffold)
- [Android Project Setup](https://docs.solanamobile.com/android-native/setup#android-project-setup)
  - [Setting up a fresh Android Project](https://docs.solanamobile.com/android-native/setup#setting-up-a-fresh-android-project)
- [Next Steps](https://docs.solanamobile.com/android-native/setup#next-steps)

## Mobile Wallet Adapter
[Skip to main content](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#__docusaurus_skipToContent_fallback)

On this page

The Mobile Wallet Adapter protocol is a spec that enables a secure, communication exchange between a dApp and an MWA-compliant wallet app, installed on the device.

Mobile Wallet Adapter 2.0 is the newest and current version and the complete 2.0 spec is viewable [here](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html).

## Add dependencies [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#add-dependencies "Direct link to Add dependencies")

The `mobile-wallet-adapter-clientlib-ktx` library is Solana Mobile's implementation of the Mobile Wallet Adapter protocol.

It provides a convenient API to connect, issue signing requests to a locally installed wallet app, and receive responses.

- build.gradle.kts

```
dependencies {
  implementation("com.solanamobile:mobile-wallet-adapter-clientlib-ktx:2.0.3")
}
```

## Instantiate `MobileWalletAdapter` client [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#instantiate-mobilewalletadapter-client "Direct link to instantiate-mobilewalletadapter-client")

The `MobileWalletAdapter` object provides methods to connect to wallets and issue MWA requests.

Define the `ConnectionIdentity` of your dApp so that the wallet app can properly display your dApp info to the user.

Parameters:

- `identityName`: The name of your app.
- `identityUri`: The web URL associated with your app.
- `iconUri`: A path to your app icon relative to the app uri above.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

// Define dApp's identity metadata
val solanaUri = Uri.parse("https://yourdapp.com")
val iconUri = Uri.parse("favicon.ico") // resolves to https://yourdapp.com/favicon.ico
val identityName = "Solana Kotlin dApp"

// Construct the client
val walletAdapter = MobileWalletAdapter(connectionIdentity = ConnectionIdentity(
    identityUri = solanaUri,
    iconUri = iconUri,
    identityName = identityName
))
```

### Managing the `authToken` [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#managing-the-authtoken "Direct link to managing-the-authtoken")

The `MobileWalletAdapter` object exposes an `authToken` property that it manages throughout its lifetime.

If present, the `authToken` is automatically used by the MWA client when issuing MWA requests (like `connect`, `signMessages`, etc). And if valid,
the user is able to skip the connection approval dialog for subsequent requests.

The `authToken` is stored by the `MobileWalletAdapter` client whenever you connect to a wallet, but it can also be
provided manually:

```kotlin
// Retrieve and use a persisted authToken from a previous session of the app.
val previouslyStoredAuthToken = maybeGetStoredAuthToken()
walletAdapter.authToken = previouslyStoredAuthToken
```

This is especially useful when you want to persist connections after a user closes and re-opens the app.

## Establishing an MWA session [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#establishing-an-mwa-session "Direct link to Establishing an MWA session")

To establish a session, or 'connect', with an MWA wallet, use the `transact` method provided by the `MobileWalletAdapter` object.

Calling `transact` dispatches an assocication intent to a locally installed MWA wallet app and prompts the
user to approve or reject the connection request.

Once connected, the user can begin issuing MWA requests and receiving responses from the wallet app. The `MobileWalletAdapter`
object also stores, in memory, the `authToken` from successful connections to be used automatically subsequent sessions.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

// `transact` dispatches an association intent to MWA-compatible wallet apps.
val result = walletAdapter.transact(sender) { authResult ->
    /* Once connected, send requests to the wallet in this callback */
}
```

When the session is complete, `transact` returns a `TransactionResult` that can be unwrapped and conditioned upon to handle success and error cases.

### Connecting to a wallet [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#connecting-to-a-wallet "Direct link to Connecting to a wallet")

If you only need to connect to a wallet and do not need to send any additional MWA requests, use the `connect` method from the `MobileWalletAdapter` client.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

// `connect` dispatches an association intent to MWA-compatible wallet apps.
val result = walletAdapter.connect(sender)

when (result) {
    is TransactionResult.Success -> {
        // On success, an `AuthorizationResult` type is returned.
        val authResult = result.authResult
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error connecting to wallet: " + result.e.message)
    }
}
```

On successful connection, the `TransactionResult` will contain an `AuthorizationResult` that contains the user's wallet address, `authToken`, etc.

#### What's the difference with `transact` and `connect`? [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#whats-the-difference-with-transact-and-connect "Direct link to whats-the-difference-with-transact-and-connect")

Under the hood, the `connect` method just calls the `transact` function with an empty callback, immediately returning the `authResult`.

```kotlin
suspend fun connect(sender: ActivityResultSender) = transact(sender) { }
```

## Sign in with Solana [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#sign-in-with-solana "Direct link to Sign in with Solana")

To connect to a wallet and simultaneously verify the user's ownership of the wallet, use the [_Sign in with Solana_](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#introduction) feature.
_SIWS_ combines the `authorize` and `signMessage` step and returns a `SignInResult` that can be verified by the dApp.

To initiate _SIWS_, use the `signIn` method and pass in a `SignInPayload` parameter. If provided, the wallet
will display a dedicated _SIWS_ UI and prompt the user to sign in by signing the `statement` message.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

// `connect` dispatches an association intent to MWA-compatible wallet apps.
val result = walletAdapter.signIn(
    sender,
    SignInWithSolana.Payload("solana.com", "Sign in to Ktx Sample App")
)

when (result) {
    is TransactionResult.Success -> {
        // On success, an `AuthorizationResult` with a `signInResult` object is returned.
        val signInresult = result.authResult.signInResult
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error connecting to wallet: " + result.e.message)
    }
}
```

### Verifying the sign-in result [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#verifying-the-sign-in-result "Direct link to Verifying the sign-in result")

If successful, the wallet will respond with an `authResult` that includes a `SignInResult` object, which can be used
for verifying the sign-in process. The `SignInResult` object will contain the fields outlined in the [SIWS spec](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#sign-in-output-fields).

To verify the Sign-In output, use an Ed25519 library to verify that the message was correctly signed by the user's wallet. See `fakedapp` for an [example of message verification in Kotlin](https://github.com/solana-mobile/mobile-wallet-adapter/blob/761c3367e5ed4651fa2661767439abf25a178588/android/fakedapp/src/main/java/com/solana/mobilewalletadapter/fakedapp/MainViewModel.kt#L99C13-L108C18) or an [example with javascript on server-side](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#sign-in-output-verification-backend).

### Transact after signing in [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#transact-after-signing-in "Direct link to Transact after signing in")

Similarly to `connect`, the `signIn` method just wraps an empty `transact` call and includes the provided `signInPayload`.

If you want to sign in to the wallet and and continue issuing additional MWA requests, then you can use
the include the optional `signInPayload` parameter when using the `transact` method.

```kotlin
// Sign in to authorize the session, then continue issuing requests.
val result = walletAdapter.transact(sender,
             SignInWithSolana.Payload("solana.com", "Sign in to Ktx Sample App")) { authResult ->
    /* ..Send MWA requests.. */
}
```

## Disconnecting from a wallet [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#disconnecting-from-a-wallet "Direct link to Disconnecting from a wallet")

A dApp can revoke authorization or disconnect from a wallet by sending a disconnect request. The wallet will invalidate the `authToken` stored by the `MobileWalletAdapter`. This will require the user to approve the connection request once again, when connecting to that wallet.

```kotlin
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val result = walletAdapter.disconnect(sender)

when (result) {
    is TransactionResult.Success -> {
        // On success, the authToken has been successfully invalidated.
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error connecting to wallet: " + result.e.message)
    }
}
```

Alternatively, you can directly issue a `deauthorize` request to the wallet and provide a specific `authToken` to invalidate.

```kotlin
val result = walletAdapter.transact(sender) { authResult ->
    deauthorize(someAuthToken)
}
```

## Signing and sending transactions [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#signing-and-sending-transactions "Direct link to Signing and sending transactions")

To request a wallet to sign and then send a Solana transaction, use the `signAndSendTransactions` method. With this method,
the wallet will handle both signing the transactions then submitting them to the Solana network.

For an example of building a transaction, see the 'Building transactions' guide.

```kotlin
import com.funkatronics.encoders.Base58
import com.solana.publickey.SolanaPublicKey
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val result = walletAdapter.transact(sender) { authResult ->
    // Build a transaction using web3-solana classes
    val account = SolanaPublicKey(authResult.accounts.first().publicKey)
    val memoTx = buildMemoTransaction(account, "Hello Solana!");

    // Issue a 'signTransactions' request
    signAndSendTransactions(arrayOf(memoTx.serialize()));
}

when (result) {
    is TransactionResult.Success -> {
        val txSignatureBytes = result.successPayload?.signatures?.first()
        txSignatureBytes?.let {
            println("Transaction signature: " + Base58.encodeToString(signedTxBytes))
        }
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error during signing and sending transactions: " + result.e.message)
    }
}
```

If successful, the `TransactionResult` will contain a `successPayload` with an array (`signatures`), where each item is a transaction
signature serialized as `ByteArray`, in corresponding order to the input.

## Signing messages [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#signing-messages "Direct link to Signing messages")

To request a wallet to sign a message, use the `signMessagesDetached` method. In this case, a _message_ is any payload of bytes.

```kotlin
import com.funkatronics.encoders.Base58
import com.solana.publickey.SolanaPublicKey
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val message = "Sign this message please!"
val result = walletAdapter.transact(sender) { authResult ->
    signMessagesDetached(arrayOf(message.toByteArray()), arrayOf((authResult.accounts.first().publicKey)))
}

when (result) {
    is TransactionResult.Success -> {
        val signedMessageBytes = result.successPayload?.messages?.first()?.signatures?.first()
        signedMessageBytes?.let {
            println("Message signed: ${Base58.encodeToString(it)}")
        }
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error during transaction signing: " + result.e.message)
    }
}
```

If successful, the `TransactionResult` will contain a `successPayload` with an array (`messages`), where each item is a signed message
payload serialized as a `ByteArray`, in corresponding order to the input.

## Signing transactions (deprecated) [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#signing-transactions-deprecated "Direct link to Signing transactions (deprecated)")

caution

The `signTransactions` method is deprecated according to the Mobile Wallet Adapter 2.0 [specification](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html). Wallet apps
may still support this method for backwards compatibility, but it is recommended for dApps to use `signAndSendTransactions` instead.

To request a wallet to sign a Solana transaction, use the `signTransactions` method. For an example
of building a transaction, see the 'Building transactions' guide.

```kotlin
import com.funkatronics.encoders.Base58
import com.solana.publickey.SolanaPublicKey
import com.solana.mobilewalletadapter.clientlib.*

 // `this` is the current Android activity
val sender = ActivityResultSender(this)

// Instantiate the MWA client object
val walletAdapter = MobileWalletAdapter(/* ... */)

val result = walletAdapter.transact(sender) { authResult ->
    // Build a transaction using web3-solana classes
    val account = SolanaPublicKey(authResult.accounts.first().publicKey)
    val memoTx = buildMemoTransaction(account, "Hello Solana!");

    // Issue a 'signTransactions' request
    signTransactions(arrayOf(memoTx.serialize()));
}

when (result) {
    is TransactionResult.Success -> {
        val signedTxBytes = result.successPayload?.signedPayloads?.first()
        signedTxBytes?.let {
            println("Signed memo transaction: " + Base58.encodeToString(signedTxBytes))
        }
    }
    is TransactionResult.NoWalletFound -> {
        println("No MWA compatible wallet app found on device.")
    }
    is TransactionResult.Failure -> {
        println("Error during transaction signing: " + result.e.message)
    }
}
```

The `signTransactions` method accepts an array of serialized transactions and, on success, returns `signedPayloads` containing the corresponding
signed payloads serialized as `ByteArray`.

## Next Steps [​](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter\#next-steps "Direct link to Next Steps")

- Browse or clone the [MintyFresh repo](https://github.com/solana-mobile/Minty-fresh/tree/main) to reference best practices for a live, published Kotlin Solana dApp.

- [Add dependencies](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#add-dependencies)
- [Instantiate `MobileWalletAdapter` client](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#instantiate-mobilewalletadapter-client)
  - [Managing the `authToken`](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#managing-the-authtoken)
- [Establishing an MWA session](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#establishing-an-mwa-session)
  - [Connecting to a wallet](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#connecting-to-a-wallet)
- [Sign in with Solana](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#sign-in-with-solana)
  - [Verifying the sign-in result](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#verifying-the-sign-in-result)
  - [Transact after signing in](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#transact-after-signing-in)
- [Disconnecting from a wallet](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#disconnecting-from-a-wallet)
- [Signing and sending transactions](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#signing-and-sending-transactions)
- [Signing messages](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#signing-messages)
- [Signing transactions (deprecated)](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#signing-transactions-deprecated)
- [Next Steps](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#next-steps)

## Anchor Programs Guide
[Skip to main content](https://docs.solanamobile.com/android-native/using-anchor-programs#__docusaurus_skipToContent_fallback)

On this page

[Anchor](https://www.anchor-lang.com/) is a popular Solana development framework for writing on-chain programs. Programs and instructions created with Anchor, have a different data format than other programs like SPL and SystemProgram.

This guide will teach you how to build instructions and transactions that invoke Anchor programs in Kotlin.

## Add dependencies [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#add-dependencies "Direct link to Add dependencies")

Add the following dependencies to your project:

- [`web3-solana`](https://github.com/solana-mobile/web3-core) library provides the abstraction classes like `Transaction` and `AccountMeta` to simplify building Solana transactions.
- [`rpc-core`](https://github.com/solana-mobile/rpc-core) library provides a `SolanaRpcClient` class with convenient RPC methods.
- [`kborsh`](https://github.com/Funkatronics/kBorsh/tree/main) library for Borsh serialization of instruction data.

- build.gradle.kts

```
dependencies {
  implementation("com.solanamobile:web3-solana:0.2.5")
  implementation("com.solanamobile:rpc-core:0.2.7")
  implementation('io.github.funkatronics:kborsh:0.1.0')
}
```

## Example: Counter Program [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#example-counter-program "Direct link to Example: Counter Program")

As an example, we'll build a transaction using this devnet on-chain [Counter Program](https://github.com/solana-mobile/tutorial-apps/blob/main/AnchorCounterDapp/counter-program/programs/counter-program/src/lib.rs) that was created with Anchor.

Specifically, let's invoke the `Increment` instruction.

### Instruction Format [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#instruction-format "Direct link to Instruction Format")

Taking a look at the [source code](https://github.com/solana-mobile/tutorial-apps/blob/main/AnchorCounterDapp/counter-program/programs/counter-program/src/lib.rs#L43), observe that the `Increment` instruction format expects:

**Program ID**

- The Counter Program is deployed on devnet with the Program Id: `ADraQ2ENAbVoVZhvH5SPxWPsF2hH5YmFcgx61TafHuwu`.

**Account Addresses**

- The Counter account PDA as a non-signer. `"counter"` is the only seed used to derive the PDA.

**Instruction Data**

- An `amount: u64` parameter.
- An additional 8 bytes for the [Anchor discriminator](https://book.anchor-lang.com/anchor_bts/discriminator.html)

Now, let's create each of these required inputs.

### 1\. Find the Counter account PDA [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#1-find-the-counter-account-pda "Direct link to 1. Find the Counter account PDA")

To derive the Counter PDA, we'll use the `ProgramDerivedAddres` interface in the `web3-solana` module which provides a `find` method.

Call `ProgramDerivedAddres.find` and pass `"counter"` as a seed and the Counter program ID:

```kotlin
import com.solana.publickey.SolanaPublicKey
import com.solana.publickey.ProgramDerivedAddress

val programId = SolanaPublicKey.from("ADraQ2ENAbVoVZhvH5SPxWPsF2hH5YmFcgx61TafHuwu")

// Counter account has a single seed 'counter'
val seeds = listOf("counter".encodeToByteArray())

// Calculate the PDA
val result = ProgramDerivedAddress.find(seeds, programId)

// Unwrap the result
val counterAccountPDA = result.getOrNull()
```

### 2\. Serialize the instruction data [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#2-serialize-the-instruction-data "Direct link to 2. Serialize the instruction data")

The next step is to build and serialize the instruction data.

Using the `kotlinx` serialization library, define the expected increment arguments as a `@Serializable` class.

```kotlin
import kotlinx.serialization.Serializable

@Serializable
class Args_increment(val amount: UInt)
```

Now, use the `AnchorInstructionSerializer` to serialize the instruction arguments and lastly use the `kBorsh` library to Borsh encode the data.

```kotlin
val encodedInstructionData = Borsh.encodeToByteArray(
    AnchorInstructionSerializer("increment"),
    Args_increment(amount)
)
```

info

Anchor instruction data uses a unique [Anchor discriminator](https://book.anchor-lang.com/anchor_bts/discriminator.html) to determine which instruction is called.

The `AnchorInstructionSerializer` will handle this discriminator during serialization, as long as you pass the correct instruction name (e.g `increment`) into the constructor.

### 3\. Construct the instruction [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#3-construct-the-instruction "Direct link to 3. Construct the instruction")

Putting all the inputs together, you can build the full `TransactionInstruction`.

```kotlin
import com.solana.publickey.SolanaPublicKey
import com.solana.transaction.*

val incrementInstruction = TransactionInstruction(
    SolanaPublicKey.from("ADraQ2ENAbVoVZhvH5SPxWPsF2hH5YmFcgx61TafHuwu"),
    listOf(AccountMeta(counterAccountPDA!!, false, true)),
    encodedInstructionData
)
```

### 4\. Create the transaction [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#4-create-the-transaction "Direct link to 4. Create the transaction")

Then build a transaction message and construct the `Transaction` packed with the increment instruction.

```kotlin
import com.solana.transaction.*
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

// Fetch latest blockhash from RPC
val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
val blockhashResponse = rpcClient.getLatestBlockhash()

// Build transaction message
val incrementAmount = 5
val incrementCounterMessage =
    Message.Builder()
        .addInstruction(
            incrementInstruction
        )
        .setRecentBlockhash(blockhashResponse.result!!.blockhash)
        .build()

// Construct the Transaction object from the message
val unsignedIncrementTx = Transaction(incrementCounterMessage)
```

### 5\. Sign the transaction [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#5-sign-the-transaction "Direct link to 5. Sign the transaction")

At this point, you have successfully created an _unsigned_ Solana transaction for incrementing the counter account. Before submitting to the network, the transaction must be signed by the fee payer.

#### Signing with Mobile Wallet Adapter [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#signing-with-mobile-wallet-adapter "Direct link to Signing with Mobile Wallet Adapter")

If you want users to sign the transaction using their mobile wallet app (e.g Phantom, Solflare) you can use Mobile Wallet Adapter to request signing.

Read the [_Using Mobile Wallet Adapter_ guide](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter#signing-and-sending-transactions) to learn how to prompt users to sign these transactions and submit them to the Solana network.

#### Signing with a keypair [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#signing-with-a-keypair "Direct link to Signing with a keypair")

If you have direct access to a keypair, you can serialize the Transaction message, sign the bytes, and construct the signed transaction.

```kotlin
import com.solana.transaction.*
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

// Fetch latest blockhash from RPC
val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())
val blockhashResponse = rpcClient.getLatestBlockhash()

// Build transaction message
val incrementAmount = 5
val incrementCounterMessage =
    Message.Builder()
        .addInstruction(
            incrementInstruction
        )
        .setRecentBlockhash(blockhashResponse.result!!.blockhash)
        .build()

// Sign the transaction with some keypair signer
val signature = ed25519Signer.signBytes(incrementCounterMessage.serialize())

// Signed transaction ready to be submitted to the network
val signedTransaction = Transaction(listOf(signature), incrementCounterMessage)
```

### 6\. Sending the transaction [​](https://docs.solanamobile.com/android-native/using-anchor-programs\#6-sending-the-transaction "Direct link to 6. Sending the transaction")

After the transaction is signed, it can be submitted to an RPC using the `SolanaRpcClient` class.

```kotlin
import com.solana.rpc.SolanaRpcClient
import com.solana.networking.KtorNetworkDriver

val rpcClient = SolanaRpcClient("https://api.devnet.solana.com", KtorNetworkDriver())

val response = rpcClient.sendTransaction(signedTransaction)

if (response.result) {
    println("Transaction signature: ${response.result}")
} else if (response.error) {
    println("Failed to send transaction: ${response.error.message}")
}
```

- [Add dependencies](https://docs.solanamobile.com/android-native/using-anchor-programs#add-dependencies)
- [Example: Counter Program](https://docs.solanamobile.com/android-native/using-anchor-programs#example-counter-program)
  - [Instruction Format](https://docs.solanamobile.com/android-native/using-anchor-programs#instruction-format)
  - [1\. Find the Counter account PDA](https://docs.solanamobile.com/android-native/using-anchor-programs#1-find-the-counter-account-pda)
  - [2\. Serialize the instruction data](https://docs.solanamobile.com/android-native/using-anchor-programs#2-serialize-the-instruction-data)
  - [3\. Construct the instruction](https://docs.solanamobile.com/android-native/using-anchor-programs#3-construct-the-instruction)
  - [4\. Create the transaction](https://docs.solanamobile.com/android-native/using-anchor-programs#4-create-the-transaction)
  - [5\. Sign the transaction](https://docs.solanamobile.com/android-native/using-anchor-programs#5-sign-the-transaction)
  - [6\. Sending the transaction](https://docs.solanamobile.com/android-native/using-anchor-programs#6-sending-the-transaction)

## Mint App NFTs
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/app-nft#__docusaurus_skipToContent_fallback)

On this page

If this is your first time publishing an app on the dApp Store, then you will need to mint a an **App NFT**.

tip

If you are looking to publish an update version of an existing app, then skip to [this step](https://docs.solanamobile.com/dapp-publishing/publishing_releases).

An App NFT:

- Contains metadata that describes this specific app as a whole
- **Created only once per app**. Subsequent app updates will instead rely on the _Release NFT_.

## Create a Solana keypair for your dapp [​](https://docs.solanamobile.com/dapp-publishing/app-nft\#create-a-solana-keypair-for-your-dapp "Direct link to Create a Solana keypair for your dapp")

See the [File System Wallet](https://docs.anza.xyz/cli/wallets/file-system) instructions to create a new keypair for publishing your dApp. You'll need to fund your account with some SOL to mint the necessary publisher, dApp, and release NFTs. For testing purposes, you can use devnet or testnet, and airdrop some SOL to this wallet.

Keep Your Keypair Safe

This keypair is a critical secret for your dApp. Whomever possesses it is able to create new releases of your dApp and submit them to the Solana dApp Store. It should be safeguarded with appropriate technical measures.

## RPC endpoints [​](https://docs.solanamobile.com/dapp-publishing/app-nft\#rpc-endpoints "Direct link to RPC endpoints")

By default, the dApp store CLI interacts with **Devnet**. This facilitates experimentation and testing, before you are ready to publish your dApp on Mainnet Beta. To publish to Mainnet Beta, add the `-u <mainnet_beta_rpc_url>` parameter to all commands below.

tip

We **strongly** recommend you use a private RPC URL, as this will make the NFT minting process **much** more reliable as compared to the Solana public RPC.

## Validate your configuration [​](https://docs.solanamobile.com/dapp-publishing/app-nft\#validate-your-configuration "Direct link to Validate your configuration")

First, you should validate the details you have provided in your configuration file:

```shell
npx dapp-store validate -k <path_to_your_keypair> -b <path_to_your_android_sdk_build_tools>
```

On success, you should see output similar to:

```shell
App JSON valid!
Release JSON valid!
```

info

If you have `.mp4` video assets in your publishing, make sure you have `ffmpeg` utility library [installed](https://docs.solanamobile.com/dapp-publishing/setup#ffmpeg).

## Create your App NFT [​](https://docs.solanamobile.com/dapp-publishing/app-nft\#create-your-app-nft "Direct link to Create your App NFT")

tip

When using CLI version >= `0.8.0`, the following commands will submit a Solana transaction that includes a default priority fee of `500000` lamports.

To customize this value, use param `-p` or `--priority-fee-lamports <priority-fee-lamports>`

```shell
npx dapp-store create app -k <path_to_your_keypair> [-u <mainnet_beta_rpc_url>]
```

info

This is a **one-time** operation per app. Once you have created your dApp, the mint address is recorded in your configuration file.

- [Create a Solana keypair for your dapp](https://docs.solanamobile.com/dapp-publishing/app-nft#create-a-solana-keypair-for-your-dapp)
- [RPC endpoints](https://docs.solanamobile.com/dapp-publishing/app-nft#rpc-endpoints)
- [Validate your configuration](https://docs.solanamobile.com/dapp-publishing/app-nft#validate-your-configuration)
- [Create your App NFT](https://docs.solanamobile.com/dapp-publishing/app-nft#create-your-app-nft)

## Solana Mobile dApp Publishing
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/building-expo-apk#__docusaurus_skipToContent_fallback)

On this page

If you have a React Native app built with Expo, just a few steps are needed to publish it on the Solana Mobile dApp Store.

This guide assumes minimal experience with typical Android development tools.

## Step 1. Build an APK [​](https://docs.solanamobile.com/dapp-publishing/building-expo-apk\#step-1-build-an-apk "Direct link to Step 1. Build an APK")

By default, when building with EAS, the platform compiles an Android App Bundle (.aab) file. Solana Mobile dApp Store requires a different binary format, APK, so we'll create a new EAS profile by adding the following lines in `eas.json`:

```text
"dapp-store": {
    "channel": "production",
    "android": {
        "buildType": "apk"
    }
}
```

Then build:

```text
npx eas build -p android --profile dapp-store
```

Meanwhile, in your project directory, create a new folder `dapp-store-build` (if you're using Git you may want to add this folder to `.gitignore` to avoid uploading large binary files).

Once the EAS build has finished, download the APK file, and name it `myapp-v0.0.1-unsigned.apk`. Replace `myapp` and `0.0.1` with your app name and release version, but keep file naming consistent between updates.

## Step 2. Set up Java and Android tooling [​](https://docs.solanamobile.com/dapp-publishing/building-expo-apk\#step-2-set-up-java-and-android-tooling "Direct link to Step 2. Set up Java and Android tooling")

You will need to download and install:

- JDK: [https://www.oracle.com/java/technologies/downloads/](https://www.oracle.com/java/technologies/downloads/)
- Android Studio: [https://developer.android.com/studio](https://developer.android.com/studio)

Once Android Studio is installed, you need to create an empty project. Then, open Settings > Languages & Frameworks > Android SDK.

Switch to SDK Tools tab and check if you have Android SDK Command-line tools installed.

A tool named AAPT2 (Android Asset Packaging Tool) may be missing from Android Studio, and you may have to install it separately:

```text
sdkmanager "build-tools;build-tools-version"
```

`build-tools-version` should be replaced with the latest version from the release page: [https://developer.android.com/tools/releases/build-tools](https://developer.android.com/tools/releases/build-tools)

For example:

```text
sdkmanager "build-tools;34.0.0"
```

Alternatively, use a full path on Mac:

```text
~/Library/Android/sdk/cmdline-tools/latest/bin/sdkmanager "build-tools;34.0.0"
```

## Step 3. Sign the APK [​](https://docs.solanamobile.com/dapp-publishing/building-expo-apk\#step-3-sign-the-apk "Direct link to Step 3. Sign the APK")

In your project directory, create a new folder `dapp-store-signing-keys` (if you're using Git you may want to add this folder to `.gitignore` to avoid exposing signing keys).

Open the folder `dapp-store-signing-keys` and run the following command (edit as needed) to create a keystore used for signing the app.

```text
keytool -genkey -v -keystore release-key.keystore -alias myapp -keyalg RSA -keysize 2048 -validity 50000
```

In this command you need to change the values:

- `myapp`: unique name (alias) that identifies your app or project
- `50000`: key validity in days; you may want to reduce it

Open your project directory, and run the following command:

```text
~/Library/Android/sdk/build-tools/35.0.0/apksigner sign \
    --ks ./dapp-store-signing-keys/release-key.keystore \
    --ks-key-alias myapp \
    --out ./dapp-store-build/myapp-v0.0.1-signed.apk \
    ./dapp-store-build/myapp-v0.0.1-unsigned.apk
```

The signed binary will be at `dapp-store-build/myapp-v0.0.1-signed.apk`. This is the file you'll need to reference in `config.yaml` at the publishing stage.

## Publishing to dApp Store [​](https://docs.solanamobile.com/dapp-publishing/building-expo-apk\#publishing-to-dapp-store "Direct link to Publishing to dApp Store")

Now that you have signed APK, you are ready to follow the [dApp publishing guide](https://docs.solanamobile.com/dapp-publishing/submit-new-app) to submit your app to Solana Mobile dApp Store.

- [Step 1. Build an APK](https://docs.solanamobile.com/dapp-publishing/building-expo-apk#step-1-build-an-apk)
- [Step 2. Set up Java and Android tooling](https://docs.solanamobile.com/dapp-publishing/building-expo-apk#step-2-set-up-java-and-android-tooling)
- [Step 3. Sign the APK](https://docs.solanamobile.com/dapp-publishing/building-expo-apk#step-3-sign-the-apk)
- [Publishing to dApp Store](https://docs.solanamobile.com/dapp-publishing/building-expo-apk#publishing-to-dapp-store)

## Solana dApp Publishing
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/checklist#__docusaurus_skipToContent_fallback)

On this page

This checklist aims to provide you a high level overview of the dApp publishing process. You can get
an idea of the resources you'll need to prepare before submitting your app.

## Publishing Journey [​](https://docs.solanamobile.com/dapp-publishing/checklist\#publishing-journey "Direct link to Publishing Journey")

At a high level, the publishing process can be simplified into these steps:

![Publishing Flow Diagram](https://docs.solanamobile.com/diagrams/publishingflow.svg)

### Build an Android APK [​](https://docs.solanamobile.com/dapp-publishing/checklist\#build-an-android-apk "Direct link to Build an Android APK")

The dApp Publishing tool requires you to submit an Android APK of your app.

- If you already have an Android app (e.g Published to Google Play Store), you can generate a release build APK.
- If you have a web app, follow [this guide](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa) to convert it to an Android app and generate an APK for submission.

important

Ensure you are submitting a release build of your app that is [signed](https://developer.android.com/studio/publish/app-signing#opt-out). Debug builds will not be accepted.

### Test on an Android device [​](https://docs.solanamobile.com/dapp-publishing/checklist\#test-on-an-android-device "Direct link to Test on an Android device")

To ensure a great user experience, we recommend developers to thoroughly test their app to catch any bugs/crashes/issues.

You do not need a Solana Mobile device to test your app, you can just test against a comparable Android device or emulator.

- If using Mobile Wallet Adapter, test your app's connect and signing flows with popular MWA wallets like Phantom and Solflare.
- If your app content is gated (e.g beta access, NFT-gated), prepare a test account with full access for App Review.

### Prepare your App Listing Page [​](https://docs.solanamobile.com/dapp-publishing/checklist\#prepare-your-app-listing-page "Direct link to Prepare your App Listing Page")

Your app's listing page is what gives users the first impression of your app. You'll want to prepare ahead of time, assets like
your app icon, screenshots/videos, and text content.

See the [Listing Page guidelines](https://docs.solanamobile.com/dapp-publishing/listing-page-guidelines) to visualize your app's listing page and learn best practices.

### Proceed to App Submission! [​](https://docs.solanamobile.com/dapp-publishing/checklist\#proceed-to-app-submission "Direct link to Proceed to App Submission!")

Once you are ready for publishing, you can follow the step-by-step [App Submission guide](https://docs.solanamobile.com/dapp-publishing/submit-new-app) to submit your app. The publishing process
is completely self service, so it can be started whenever you are ready!

After finished, your app will be in queue for App Review and, using your provided contact details, we will reach out to you if any questions are needed.

### App Promotion [​](https://docs.solanamobile.com/dapp-publishing/checklist\#app-promotion "Direct link to App Promotion")

For questions regarding promoting your app after launching, see our [Marketing & Partnership documentation](https://docs.solanamobile.com/marketing/overview).

- [Publishing Journey](https://docs.solanamobile.com/dapp-publishing/checklist#publishing-journey)
  - [Build an Android APK](https://docs.solanamobile.com/dapp-publishing/checklist#build-an-android-apk)
  - [Test on an Android device](https://docs.solanamobile.com/dapp-publishing/checklist#test-on-an-android-device)
  - [Prepare your App Listing Page](https://docs.solanamobile.com/dapp-publishing/checklist#prepare-your-app-listing-page)
  - [Proceed to App Submission!](https://docs.solanamobile.com/dapp-publishing/checklist#proceed-to-app-submission)
  - [App Promotion](https://docs.solanamobile.com/dapp-publishing/checklist#app-promotion)

## Solana dApp Store FAQ
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/faq#__docusaurus_skipToContent_fallback)

### Do I need a Solana Mobile device to build an app for the dApp Store?

+

### How can I publish an app?

+

### Can I publish a PWA onto the dApp Store?

+

### Can I get a developer kit for testing?

+

### What does it mean for the dApp Store to be 'fee-free'?

+

### How can I see user statistics for my app in the dApp Store?

+

### I've published my app, now what?

+

## Deep Linking to dApp Store
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-page#__docusaurus_skipToContent_fallback)

On this page

The dApp Store provides a deep-linking scheme that you can use to directly link users to your app's listing page, where users can see the description, preview media, and more, and then install the app.

## Deep-link scheme [​](https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-page\#deep-link-scheme "Direct link to Deep-link scheme")

To create the link, you need to know the app's fully qualified _package name_, which is declared in the app's manifest file (e.g `com.solanamobile.mintyfresh`). For Expo apps, it can be found in the `android` field of your `app.json`.

```text
solanadappstore://details?id=<package_name>
```

An example:

```text
solanadappstore://details?id=com.solanamobile.mintyfresh
```

## Linking from an Android app [​](https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-page\#linking-from-an-android-app "Direct link to Linking from an Android app")

You can also link to your dApp Store listing page from an Android app.

This can be useful, for example, when your user's app is out-of-date and you want to link them to the listing page to update the app.

- React Native
- Kotlin

```ts
import { Linking } from "react-native";

// Use the React Native `Linking` library to open the URL
const linkToListing = () => {
  const url = "solanadappstore://details?id=com.solanamobile.mintyfresh";
  Linking.canOpenURL(url)
    .then((supported) => {
      if (supported) {
        Linking.openURL(url);
      } else {
        console.error("Unable to link to dApp Store");
      }
    })
    .catch((err) => console.error("An error occurred", err));
};
```

Update the `AndroidManifest.xml` to include `queries`.

```xml
<manifest
    <queries>
        <intent>
            <action android:name="android.intent.action.VIEW" />
            <category android:name="android.intent.category.BROWSABLE" />
            <data
                android:host="details"
                android:scheme="solanadappstore" />
        </intent>
    </queries>
...
</manifest>
```

```kotlin
// Create an Android intent to navigate to the listing page
val intent = Intent(Intent.ACTION_VIEW).apply {
    data = Uri.parse("solanadappstore://details?id=com.solanamobile.mintyfresh")
    // Make sure there's an activity that can handle this intent
    resolveActivity(packageManager)?.let {
        startActivity(this)
    }
}
```

- [Deep-link scheme](https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-page#deep-link-scheme)
- [Linking from an Android app](https://docs.solanamobile.com/dapp-publishing/link-to-dapp-listing-page#linking-from-an-android-app)

## Solana dApp Publishing
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/overview#__docusaurus_skipToContent_fallback)

On this page

## Overview [​](https://docs.solanamobile.com/dapp-publishing/overview\#overview "Direct link to Overview")

Publishing a dApp to the Solana dApp Store involves the following:

1. Create a set of NFTs describing the dApp, publisher, and release on-chain.
2. Submit a request to the Solana dApp Store publisher portal requesting that Solana Mobile team review the dApp's release NFT.

The publishing tool is designed for CI/CD usage - all steps, including submitting publish portal requests, can be integrated into your dApp release workflows. All files used during the NFT creation and publishing request submission steps can be committed to source control.

## Agreement & Policies [​](https://docs.solanamobile.com/dapp-publishing/overview\#agreement--policies "Direct link to Agreement & Policies")

Before you get started with the publishing process, you should read the following documents:

- [Publisher Policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy)
- [Developer Agreement](https://docs.solanamobile.com/dapp-publishing/agreement)

### Publisher Policy [​](https://docs.solanamobile.com/dapp-publishing/overview\#publisher-policy "Direct link to Publisher Policy")

We’ve created the Solana dApp Store to be the best home for Web3 and crypto apps. Our policies exist to protect users from illegal, harmful, and misleading content, without restricting the abilities of apps to use crypto features, like trading NFTs or other digital goods.

All apps submitted to the Solana dApp Store must comply with these policies. If you have concerns about an app in the Solana dApp Store catalog, please report it to [concerns@dappstore.solanamobile.com](mailto:concerns@dappstore.solanamobile.com).

### Solana dApp Store Developer Agreement [​](https://docs.solanamobile.com/dapp-publishing/overview\#solana-dapp-store-developer-agreement "Direct link to Solana dApp Store Developer Agreement")

Make sure to read and understand the Solana dApp Store Developer Agreement. These terms apply to all submissions made to the Solana dApp Store publisher portal.

## Next steps [​](https://docs.solanamobile.com/dapp-publishing/overview\#next-steps "Direct link to Next steps")

To get started with dApp publishing, you can begin following the [step-by-step guide](https://docs.solanamobile.com/dapp-publishing/setup) or watch this video tutorial:

- [Overview](https://docs.solanamobile.com/dapp-publishing/overview#overview)
- [Agreement & Policies](https://docs.solanamobile.com/dapp-publishing/overview#agreement--policies)
  - [Publisher Policy](https://docs.solanamobile.com/dapp-publishing/overview#publisher-policy)
  - [Solana dApp Store Developer Agreement](https://docs.solanamobile.com/dapp-publishing/overview#solana-dapp-store-developer-agreement)
- [Next steps](https://docs.solanamobile.com/dapp-publishing/overview#next-steps)

## Solana Mobile Privacy Policy
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/privacy-policy#__docusaurus_skipToContent_fallback)

On this page

Effective as of May 21, 2025

Please click [**here**](https://legal.solanamobile.com/privacy-policy-v1-web) to view the previous version of our Privacy Policy.

**California Notice at Collection/State Law Privacy Rights**: See the [State privacy rights notice](https://docs.solanamobile.com/dapp-publishing/privacy-policy#state-privacy-rights-notice) section below for important information about your rights under applicable state privacy laws.

This Privacy Policy describes how Solana Mobile Inc. (" **Solana Mobile**," " **we**," “ **us**,” or " **our**") processes personal information that we collect through our mobile devices (“ **Solana Mobile Devices**”), our decentralized application store (“ **dApp Store**”), and wherever this Privacy Policy is linked (the “ **Services**”).

Solana Mobile may provide additional or supplemental privacy policies to individuals for specific products or services that we offer at the time we collect personal information. For example, for information about how we process personal information that we collect through our website, please visit: [https://solanamobile.com/privacy-policy-homepage-web](https://legal.solanamobile.com/privacy-policy-homepage-web).

This Privacy Policy does **not** apply to third-party apps made available for download on the dApp Store. We do not control how third-party apps use your personal information. For more information on the privacy practices of third-party app providers, please see their privacy policies. See more in the Other Sites, Services, and Apps section below.

_NOTICE TO EUROPEAN USERS: Please see the [Notice to European Users](https://docs.solanamobile.com/dapp-publishing/privacy-policy#notice-to-european-users) section for additional information for individuals located in the European Economic Area, United Kingdom, or Switzerland (which we refer to as “ **Europe**”, and “ **European**” should be understood accordingly) below._

You can print a copy of this Privacy Policy.

### Index [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#index "Direct link to Index")

- [Privacy Policy](https://docs.solanamobile.com/dapp-publishing/privacy-policy)
- [Personal information we collect](https://docs.solanamobile.com/dapp-publishing/privacy-policy#personal-information-we-collect)
- [How we use your personal information](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-we-use-your-personal-information)
- [How we share your personal information](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-we-share-your-personal-information)
- [Your choices](https://docs.solanamobile.com/dapp-publishing/privacy-policy#your-choices)
- [Other sites, services, and apps](https://docs.solanamobile.com/dapp-publishing/privacy-policy#other-sites,-services,-and-apps)
- [Security](https://docs.solanamobile.com/dapp-publishing/privacy-policy#security)
- [International data transfer](https://docs.solanamobile.com/dapp-publishing/privacy-policy#international-data-transfer)
- [Children](https://docs.solanamobile.com/dapp-publishing/privacy-policy#children)
- [Changes to this Privacy Policy](https://docs.solanamobile.com/dapp-publishing/privacy-policy#changes-to-this-privacy-policy)
- [How to contact us](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-to-contact-us)
- [State privacy rights notice](https://docs.solanamobile.com/dapp-publishing/privacy-policy#state-privacy-rights-notice)
- [Notice to European users](https://docs.solanamobile.com/dapp-publishing/privacy-policy#notice-to-european-users)
  - [General](https://docs.solanamobile.com/dapp-publishing/privacy-policy#general)
  - [Our legal bases for processing](https://docs.solanamobile.com/dapp-publishing/privacy-policy#our-legal-bases-for-processing)
  - [Retention](https://docs.solanamobile.com/dapp-publishing/privacy-policy#retention)
  - [Other info](https://docs.solanamobile.com/dapp-publishing/privacy-policy#other-info)
  - [Your rights](https://docs.solanamobile.com/dapp-publishing/privacy-policy#your-rights)
  - [Data Processing outside Europe](https://docs.solanamobile.com/dapp-publishing/privacy-policy#data-processing-outside-europe)

## Personal information we collect [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#personal-information-we-collect "Direct link to Personal information we collect")

Information you provide to us. Personal information you may provide directly to us through the Service or otherwise includes:

- **Contact data**, such as your first and last name, email address, and phone number.

- **Demographic data**, such as your time zone and language when provided to us through the dApp Store.

- **Device information**, including the serial number of your Solana Mobile Device, device identifier (e.g., IMEI), and authentication tokens that are linked to your Solana Mobile Device.

- **Payment and transactional (including blockchain) data**, such as information relating to your orders through the dApp Store, your purchase history on the dApp Store, and your blockchain transaction history.

- **dApp Store interaction history data**, including reviews of apps and other information relating to what content and apps you search for, browse, view, download, and update through the dApp Store.

- **Cryptocurrency-related information**, including wallet information (such as public key, public wallet address, and wallet name (where applicable)) and of Solana Mobile Device non-fungible token (“ **NFT**”) holdings.

- **Communications data** based on our exchanges with you, including when you contact us through the Service, social media, or otherwise, including to troubleshoot issues with your Solana Mobile Device or dApp Store experience or to dispute a transaction on the dApp Store.

- **Marketing data**, such as your preferences for receiving our marketing communications and details about your engagement with them.

- **Promotion data**, including information or content (such as photos) you share when you enter a competition, promotion, or complete a survey. We may offer promotions for NFT or other giveaways.

- **Other data** not specifically listed here, which we will use as described in this Privacy Policy or as otherwise disclosed at the time of collection.


**Third-party sources.** We may combine personal information we receive from you with personal information we obtain from other sources, such as:

- **Public sources**, such as transaction history from public blockchain(s) and ledgers and other personal information from other publicly available sources.

- **Application Developers**, such as usage and earning data from apps you may download and use from the dApp Store.

- **Seed Vault wallet app providers** whose applications are included with Solana Mobile Devices, such as blockchain transaction history.

- **Operating system provider**, such as Google, which provides the Android operating system for the Solana Mobile Device.

- **Other third parties who you direct to share your personal information with us**, such as your mobile phone service provider who may share data about your mobile account to help us provide you with Solana Mobile Device -related services.


**Automatic data collection.** We, our service providers, or our business partners (including our hardware providers) may automatically log information about you, your Solana Mobile Device, and your interaction over time with the Service, our communications, and other online services, such as:

- **Device usage and activity data** about your interaction with and use of the Solana Mobile Device, when you grant us permission to collect this data. Such data may include information about apps you install and download; information about app launches and crashes; product interaction (e.g., touch interaction data and how long you use an app); Seed Vault events (but excluding seed usage events, your seed phrase, public keys and private keys); performance and other diagnostic data; and other Solana Mobile Device usage and activity data. For more information about how to opt out of our collection of certain Device Usage and Activity Data, please visit the [Your Choices section](https://docs.solanamobile.com/dapp-publishing/privacy-policy#your-choices) below.

- **dApp Store usage and activity data** about your interaction with and use of the dApp Store, including when you open and close the dApp Store, your interactions with dApp Store notifications and messages, and information about dApp Store launches and crashes; performance and other diagnostic data; and other usage and activity data.

- **Location data**, including information about nearby Wi-Fi access points and cell towers. If you permit third parties (such as app developers) to collect your location data via the Services, those third parties can process your information according to their privacy policies, see the [Other Sites, Services, and apps section](https://docs.solanamobile.com/dapp-publishing/privacy-policy#other-sites,-services,-and-apps) below.

- **Device information**, such as Solana Mobile Device operating system version, IP address, general location data, and unique device identifiers. Google provides the Android operating system for the Solana Mobile Device and may collect and process personal information related to the Services, as described in the Google Privacy Policy at [https://policies.google.com/privacy](https://policies.google.com/privacy).


## How we use your personal information [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#how-we-use-your-personal-information "Direct link to How we use your personal information")

We may use your personal information for the following purposes or as otherwise described at the time of collection:

**Service delivery and operations**. We may use your personal information to:

- provide, operate, and improve the Service and our business;

- provide you the content you purchase, download, or want to update in the dApp Store;

- process your transactions through or related to the Services (for example, we may use your personal information to facilitate payment for Solana Mobile Device or to process Solana Mobile Device refund requests);

- identify and authenticate your access to certain features of the Services (for example, we may use your personal information to authenticate your access to your Solana Mobile Device or transactions through the dApp Store);

- personalizing the service (for example, we may use personal information collected from the camera to dim the brightness of the screen display if you do not appear to be looking at your Solana Mobile Device);

- enable security features of the Service, such as by sending you security codes via email or SMS;

- communicate with you about the Service, including by sending Service-related announcements (such as messages about new content and offers on the dApp Store), updates, security alerts, and support and administrative messages;

- communicate with you about events or contests in which you participate;

- understand your needs and interests; and

- provide support for the Service, such as debugging and repairing errors, and respond to your requests, questions, and feedback.


**To create aggregated, de-identified, and/or anonymized data.** We may create aggregated, de-identified, and/or anonymized data from the personal information we collect. We make personal information into de-identified or anonymized data by removing information that makes the data personally identifiable to you. We may use this aggregated, de-identified, or otherwise anonymized data and share it with third parties, including app developers, for our lawful business purposes, including to analyze and improve the Service and promote our business. We will not attempt to reidentify any such data except as permitted by law.

**Marketing.** We and our service providers may collect and use your personal information for marketing purposes. For example, we may send you direct marketing communications and may personalize these messages based on your needs and interests. You may opt out of our marketing communications as described in the Communication choices subsection below.

**Events, promotions, and contests.** We may use your personal information to:

- administer promotions and contests

- communicate with you about promotions or contests in which you participate

- contact or market to you after collecting your personal information at an event


**Service improvement and analytics**. We may use your personal information to analyze your usage of the Service, improve the Service, improve the rest of our business, help us understand user activity on the Service, including which apps are most and least visited and how those apps perform, and develop new products and services.

**Compliance and protection**. We may use your personal information to:

- comply with applicable laws, lawful requests, and legal process, such as responding to subpoenas, investigations, or requests from government authorities;

- protect our, your or others’ rights, privacy, safety, or property (including by making and defending legal claims);

- audit our internal processes for compliance with legal and contractual requirements or our internal policies;

- enforce the terms and conditions that govern the Service; and

- prevent, identify, investigate, and deter fraudulent, harmful, unauthorized, unethical, or illegal activity, including cyberattacks and identity theft.


**With your consent**. In some cases, we may specifically ask for your consent to collect, use, or share your personal information, such as when required by law.

## How we share your personal information [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#how-we-share-your-personal-information "Direct link to How we share your personal information")

We may share your personal information with the following parties and as otherwise described in this Privacy Policy, in other applicable notices, or at the time of collection.

**Affiliates.** Our corporate parent, subsidiaries, and affiliates.

**Service providers.** Third parties that provide services on our behalf or help us operate the Service or our business (such as processing or hosting, including personal information, information technology, customer service and support, email delivery, marketing, consumer research, and analytics).

**Operating system provider**. For example, we may share information about what software is currently running on your Solana Mobile Device for the operating system provider to check if software updates are available.

**App developers**. Third-party app developers who make their app available in the dApp Store and who develop apps. For example, we may share your personal information (such as information to prove a dApp Store purchase) with app developers so they can provide your purchased content to you. As another example, we may also share your personal information about app crashes and errors, including Solana Mobile Device operating system version, Solana Mobile Device type, and crash logs, with app developers for the purpose of identifying and fixing technical issues within the app.

**Seed Vault wallet app providers**. Third parties whose wallet applications are included with Solana Mobile Devices.

**Business partners**. Third parties with whom we co-sponsor events or promotions and with whom we jointly offer products or services.

**Professional advisors**. Professional advisors, such as lawyers, auditors, bankers and insurers, where necessary in the course of the professional services that they render to us.

**Authorities and others**. Law enforcement, government authorities, and private parties, as we believe in good faith to be necessary or appropriate for the compliance and protection purposes described above.

**Business transferees**. We may disclose personal information in the context of actual or prospective business transactions (e.g., investments in Solana Mobile, financing of Solana Mobile, public stock offerings, or the sale, transfer, or merger of all or part of our business, assets, or shares), for example, we may need to share certain personal information with prospective counterparties and their advisers. We may also disclose your personal information to an acquirer, successor, or assignee of Solana Mobile as part of any merger, acquisition, sale of assets, or similar transaction, and/or in the event of an insolvency, bankruptcy, or receivership in which personal information is transferred to one or more third parties as one of our business assets.

**Other users and the public**. Certain of your personal information may be visible to other users of the Service and the public. For example, members of the public may have access to information published on the blockchain through the Service, such as when we issue you an NFT. As another example, other users of the dApp Store and the public can view your reviews of apps that you submit to the dApp Store. This information can be seen, collected, and used by others, including being cached, copied, screen captured, or stored elsewhere by others, and we are not responsible for any such use of this information.

**With your consent.** We may share your personal information with others at your direction or with your consent.

## Your choices [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#your-choices "Direct link to Your choices")

In this section, we describe the rights and choices available to all users. Users who are located in California and certain other US states and in Europe can find additional information about their rights below.

**Declining to provide information.** We need to collect personal information to provide certain services. If you do not provide the information we identify as required or mandatory, we may not be able to provide those services.

**Privacy settings.** We make available certain privacy settings on the Service, including options to control the collection of information we and/or our partners use to improve our Services. To access this setting on your Solana Mobile Device, go to Settings > Solana Mobile > Improve our services.

You can also control the collection of usage and diagnostic data by going to Settings >Solana Mobile. If you change your settings after we have initiated a data upload, your new settings will go into effect after that process has been completed. You cannot disable our use of anonymous, de-identified, or aggregated data about crashes and errors for Solana Mobile apps.

**Communication choices.** If you receive marketing emails from us, you may unsubscribe at any time by following the instructions contained within the email. You may also opt-out from receiving marketing emails from us, and any other promotional communications that we may send to you from time to time (e.g., by postal mail) by sending your request to us by email at [privacy@solanamobile.com](mailto:privacy@solanamobile.com) or by writing to us at the address given in the ‘How to contact us’ section of this Privacy Policy.

Please be aware that if you opt out of receiving marketing emails from us, it may take up to ten business days for us to process your opt-out request, and you may receive marketing emails from us during that period. Additionally, even after you opt out of receiving marketing messages from us, you will continue to receive security-related, administrative, and transactional messages from us regarding your use of the Services.

## Other sites, services, and apps [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#other-sites,-services,-and-apps "Direct link to Other sites, services, and apps")

The Service may contain links to websites, mobile applications, and other online services operated by third parties. For example, you can download apps from third-party app developers through the dApp Store. In addition, our content may be integrated into web pages or other online services that are not associated with us. These links and integrations are not an endorsement of, or representation that we are affiliated with, any third party. We do not control websites, mobile apps, or online services operated by third parties, and we are not responsible for their actions. We encourage you to read the privacy policies of the other websites, mobile apps, and online services you use.

## Security [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#security "Direct link to Security")

We employ technical, organizational, and physical safeguards designed to protect the personal information we collect. However, security risk is inherent in all internet and information technologies, and we cannot guarantee the security of your personal information.

## International data transfer [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#international-data-transfer "Direct link to International data transfer")

We are headquartered in the United States and may use service providers that operate in other countries. Your personal information may be transferred to the United States or other locations where privacy laws may not be as protective as those in your state, province, or country.

Users in Europe should read the important information provided below about the transfer of personal information outside of Europe.

## Children [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#children "Direct link to Children")

The Service is not intended for use by anyone under 18 years of age. If you are a parent or guardian of a child from whom you believe we have collected personal information in a manner prohibited by law, please contact us at [privacy@solanamobile.com](mailto:privacy@solanamobile.com). If we learn that we have collected personal information through the Service from a child without the consent of the child’s parent or guardian as required by law, we will comply with applicable legal requirements to delete the information.

## Changes to this Privacy Policy [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#changes-to-this-privacy-policy "Direct link to Changes to this Privacy Policy")

We reserve the right to modify this Privacy Policy at any time. If we make material changes to this Privacy Policy, we will notify you by updating the date of this Privacy Policy and posting it on the Service or by other appropriate means. Any modifications to this Privacy Policy will be effective upon our posting the modified version (or as otherwise indicated at the time of posting). In all cases, your use of the Service after the effective date of any modified Privacy Policy indicates your acknowledgement that the modified Privacy Policy applies to your interactions with the Service and our business.

## How to contact us [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#how-to-contact-us "Direct link to How to contact us")

● **Email:** [privacy@solanamobile.com](mailto:privacy@solanamobile.com)

● **Mail:** 530 Divisadero St. PMB 722 San Francisco, CA 94117

## State privacy rights notice [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#state-privacy-rights-notice "Direct link to State privacy rights notice")

Except as otherwise provided, this section applies to residents of California and other states to the extent they have privacy laws applicable to us that grant their residents the rights described below (collectively the “ **State Privacy Laws**”).

This section describes how we collect, use, and share Personal Information of residents of these states and the rights these users may have with respect to their Personal Information. Please note that not all rights listed below may be afforded to all users and that if you are not a resident of one of these states listed above, you may not be able to exercise these rights. In addition, **we may not be able to process your request if you do not provide us with sufficient detail to allow us to confirm your identity or understand and respond to it.**

For purposes of this section, the term “ **Personal Information**” has the meaning given to “personal data”, “personal information” or other similar terms and “ **Sensitive Personal Information**” has the meaning given to “sensitive personal information,” “sensitive data”, or other similar terms in the State Privacy Laws, except that in neither case does such term include information exempted from the scope of the State Privacy Laws. In some cases, we may provide a different privacy notice to certain categories of residents of these states, such as employees or job applicants, in which case that notice will apply instead of this section.

**Your privacy rights.** The State Privacy Laws may provide residents with some or all of the rights listed below. However, these rights are not absolute and some State Privacy Laws do not provide these rights to their residents. Therefore, we may decline your request in certain cases as permitted by law.

- **Information.** You can request the following information about how we have collected and used your Personal Information:
  - The categories of Personal Information that we have collected.

  - The categories of sources from which we collected Personal Information.

  - The business or commercial purpose for collecting and/or selling Personal Information.

  - The categories of third parties with which we share Personal Information.

  - The categories of Personal Information that we sold or disclosed for a business purpose.

  - The categories of third parties to whom the Personal Information was sold or disclosed for a business purpose.
- **Access**. You can request a copy of the Personal Information that we have collected about you.

- **Appeal.** You can appeal our denial of any request validly submitted.

- **Correction.** You can ask us to correct inaccurate Personal Information that we have collected about you.

- **Deletion.** You can ask us to delete the Personal Information that we have collected from you.

- **Opt-out.**
  - **Opt-out of certain processing for targeted advertising purposes.** We do not process your personal information for targeted advertising purposes.

  - **Opt-out of profiling/automated decision making.** We do not use your Personal Information to engage in profiling or to perform automated decision-making that results in significant financial impacts, significant impacts on housing, education, employment, health care, or criminal justice, or similarly significant impacts.

  - **Opt-out of other sales of personal data.**  We do not sell your Personal Information within the meaning of State Privacy Laws.
- **Consumers under 16**. We do not have actual knowledge that we collect, sell or share the personal information of consumers under 16 years of age.

- **Sensitive Personal Information**. While we process certain categories of Sensitive Personal Information as described in this Privacy Policy, we do not process Sensitive Personal Information for the purpose of inferring characteristics about consumers under the California Consumer Privacy Act (“CCPA”).

- **Nondiscrimination.** You are entitled to exercise the rights described above free from discrimination as prohibited by the State Privacy Laws.


**Exercising your right to information/know, access, appeal, correction, and deletion.** You may submit requests to exercise your right to information/know, access, appeal, correction, or deletion by calling us toll-free at 1 (888) 212-2019, or via email to [privacy@solanamobile.com](mailto:privacy@solanamobile.com).

**Verification of Identity; Authorized agents.** We may need to verify your identity in order to process your information/know, access, appeal, correction, or deletion requests and reserve the right to confirm your residency. To verify your identity, we may require government identification, a declaration under penalty of perjury, or other information, where permitted by law.

Under some State Privacy Laws, you many enable an authorized agent to make a request on your behalf. However, we may need to verify your authorized agent’s identity and authority to act on your behalf. We may require a copy of a valid power of attorney given to your authorized agent pursuant to applicable law. If you have not provided your agent with such a power of attorney, we may ask you to take additional steps permitted by law to verify that your request is authorized, such as by providing your agent with written and signed permission to exercise your State Privacy Laws rights on your behalf, the information we request to verify your identity, and confirmation that you have given the authorized agent permission to submit the request.

**Personal information that we collect, use and disclose.** We have summarized below the Personal Information and Sensitive Personal Information we collect, the purposes for which we collect it and the third parties to or with whom we may disclose, sell or share it by reference below to both the categories defined in the Personal information we collect section of this Privacy Policy above and the categories of Personal Information and Sensitive Personal Information specified in the CCPA (Cal. Civ. Code §1798.140). The categories of Personal Information and Sensitive Personal Information described below may be collected via any of the sources described in the [Personal information we collect](https://docs.solanamobile.com/dapp-publishing/privacy-policy#personal-information-we-collect) section of this Privacy Policy above. The summary below describes our practices currently and during the 12 months preceding the effective date of this Privacy Policy. Information you voluntarily provide to us, such as in free-form webforms, may contain other categories of personal information not described below.

- **Personal Information (“PI”) we collect:**
  - **Contact data**
    - CCPA statutory category: Identifiers
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Seed Vault wallet app providers; Business partners; Professional advisors; Authorities and others; Business transferees
  - **Demographic data**
    - CCPA statutory category: Identifiers
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Business partners; Professional advisors; Authorities and others; Business transferees
  - **Payment and transactional (including blockchain) data**
    - CCPA statutory category: Commercial information
    - Business/commercial purpose for SPI collection: Service delivery and operations; Research & development; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Seed Vault wallet app providers; Authorities and others
  - **Device information**
    - CCPA statutory category: Identifiers; Commercial information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; Operating system provider; App developers; Seed Vault wallet app providers; Authorities and others; Business transferees
  - **dApp Store interaction history data**
    - CCPA statutory category: Identifiers; Commercial information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Business partners; Authorities and others; Business transferees; Other users and the public
  - **Cryptocurrency-related information**
    - CCPA statutory category: Commercial information; financial information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Seed Vault wallet app providers; Authorities and others; Business transferees
  - **Communications data**
    - CCPA statutory category: Identifiers; Commercial information; Internet or Network Information
    - Business/commercial purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; Business partners; Professional advisors; Authorities and others; Business transferees; Seed Vault wallet app providers Other users and the public
  - **Marketing data**
    - CCPA statutory category: Identifiers; Commercial information; Internet or Network Information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; Business partners; Authorities and others; Business transferees
  - **Promotion data**
    - CCPA statutory category: Identifiers; Commercial information; Internet or Network Information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Business partners; Professional advisors; Authorities and others; Business transferees; Other users and the public
  - **Device usage and activity data**
    - CCPA statutory category: Identifiers (other); Internet or Network Information
    - Purpose for PI collection: Service delivery and operations; Marketing; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; App developers; Seed Vault wallet app providers; Professional advisors; Authorities and others; Business transferees
  - **dApp Store usage and activity data**
    - CCPA statutory category: Identifiers (other); Internet or Network Information
    - Purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; Professional advisors; Authorities and others; Business transferees
  - **Operating system information**
    - CCPA statutory category: Identifiers
    - Business/commercial purpose for PI collection: Service delivery and operations; Marketing; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Service providers; Operating system provider; App developers; Business partners; Professional advisors; Authorities and others; Business transferees
  - **Data derived from the above**
    - CCPA statutory category: Inferences
    - Business/commercial purpose for PI collection: Service delivery and operations; Marketing; Events, promotions, and contests; Service improvement and analytics; Compliance & protection
    - Categories of third parties to whom we “disclose” PI for a business purpose: Affiliates; Business partners; Professional advisors; Authorities and others; Business transferees

Your personal information, including your sensitive personal information, may also be disclosed to third parties at your request or with your consent, to third parties in connection with a business transaction, and/or to law enforcement, regulators and other third parties for legal reasons.

**Additional information for California residents.**

**Shine the light law.** Under California’s Shine the Light law (California Civil Code Section 1798.83), California residents may ask companies with whom they have formed a business relationship primarily for personal, family or household purposes to provide the names of third parties to which they have disclosed certain personal information (as defined under the Shine the Light law) during the preceding calendar year for their own direct marketing purposes, and the categories of personal information disclosed. You may send us requests for this information to [privacy@solanamobile.com](mailto:privacy@solanamobile.com). In your request, you must include the statement “Shine the Light Request," and provide your first and last name and mailing address and certify that you are a California resident. We reserve the right to require additional information to confirm your identity and California residency. Please note that we will not accept requests via telephone, mail, or facsimile, and we are not responsible for notices that are not labeled or sent properly, or that do not have complete information.

**Additional information for Nevada residents.** Nevada residents have the right to opt-out of the sale of certain personal information for monetary consideration. While we do not currently engage in such sales, if you are a Nevada resident and would like to make a request to opt out of any potential future sales, please email [privacy@solanamobile.com](mailto:privacy@solanamobile.com).

**Contact Us.** If you have questions or concerns about our privacy policies or information practices, please contact us at [privacy@solanamobile.com](mailto:privacy@solanamobile.com).

## Notice to European users [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#notice-to-european-users "Direct link to Notice to European users")

## General [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#general "Direct link to General")

**Where this Notice to European users applies.** The information provided in this “Notice to European users” section applies only to individuals in Europe.

**Personal information.** References to “personal information” in this Privacy Policy should be understood to include a reference to “personal data” governed by European data protection legislation, including the “GDPR” (i.e., the General Data Protection Regulation 2016/679 (“EU GDPR”), the EU GDPR as it forms part of UK law (“UK GDPR”), and the Swiss FADP – i.e., information about individuals from which they are either directly identified or can be identified.

**Controller.** For the purposes of European data protection legislation, Solana Mobile is the data controller (i.e., the company that is responsible for and controls the processing of your personal information).

**Our GDPR Representatives.**

- _If you are located in the European Union:_ we have appointed the European Data Protection Office (EDPO) as our GDPR Representative in the EU. You can contact the EDPO regarding matters pertaining to the GDPR by using the EDPO’s online request form: [https://edpo.com/gdpr-data-request/](https://edpo.com/gdpr-data-request/), or in writing to the EDPO Avenue Huart Hamoir 71, 1030 Brussels, Belgium.

- _If you are located in the UK:_ we have appointed EDPO UK Ltd as its UK GDPR representative. You can contact EDPO UK regarding matters pertaining to the UK GDPR by using EDPO’s online request form: [https://edpo.com/uk-gdpr-data-request/](https://edpo.com/uk-gdpr-data-request/), or in writing to the EDPO UK at 8 Northumberland Avenue, London WC2N 5BY, United Kingdom.


## Our legal bases for processing [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#our-legal-bases-for-processing "Direct link to Our legal bases for processing")

In respect of each of the purposes for which we use your personal information, the GDPR requires us to ensure that we have a “legal basis” for that use.

Our legal bases for processing your personal information described in this Privacy Policy are listed below.

- Where we need to perform a contract, we are about to enter into or have entered into with you (“ **Contractual Necessity**”).
- Where it is necessary for our legitimate interests and your interests and fundamental rights do not override those interests (“ **Legitimate Interests**”). More details about the specific legitimate interests pursued with respect to each purpose we use your personal information for are set out in the table below.
- Where we need to comply with a legal or regulatory obligation (“ **Compliance with Law**”).
- Where we have your specific consent to carry out the processing for the purpose in question (“ **Consent**”).

We have set out below the legal bases we rely on in respect of the relevant purposes for which we use your personal information – for more information on these purposes and the data types involved, see ‘How we use your personal information.’

| Categories of personal information | Legal basis |
| --- | --- |
| _**Service delivery and operations**_ |  |
| • Contact data <br> • Demographic data <br> • Device serial number data <br> • Payment and transactional (including blockchain) data <br> • Cryptocurrency-related information | **Contractual Necessity** |
| • Location data | **Consent** |
| • dApp Store interaction history data <br> • dApp Store usage data <br> • Communications data <br> • Solana Mobile Device usage data | • **Legitimate Interests**. We have a legitimate interest in understanding your use of the Services in order to maintain a reliable and secure service and ensure the correct operation of associated IT services, systems, and networks. <br> • **Consent** |
| _**To create aggregated, de-identified, and/or anonymized data**_ |  |
| • Any and all data types relevant to the circumstances | **Legitimate Interests**. We may aggregate, de-identify, or otherwise anonymize data for research and development purposes. We have a legitimate interest in analyzing the use of our Services on an aggregated, de-identified, or otherwise anonymized basis. |
| _**Marketing**_ |  |
| • Contact data <br> • Demographic data <br> • Registration data <br> • Payment and transactional (including blockchain) data <br> • Marketing data | • **Legitimate Interests**. We have a legitimate interest in marketing our Services, including sending marketing communications where you have agreed to receive them or where you had previously contacted us. <br> • **Consent**. In circumstances or in jurisdictions where consent is required under applicable data protection laws for sending marketing communications. |
| _**Events, promotions and contests**_ |  |
| • Contact data <br> • Demographic data <br> • Device serial number data <br> • Marketing data <br> • Promotion data <br> • dApp Store interaction history data <br> • dApp Store usage data <br> • Solana Mobile Device usage data | • **Contractual Necessity** to administer the promotions and contests in accordance with the terms or rules thereof (including communicating with you as and where necessary) <br> • In respect of promoting these promotions and contests: <br>   ◦ **Legitimate Interests** – we have a legitimate interest in promoting these promotions and contests, including associated publicizing of our business and operations. <br>   ◦ **Consent** – in circumstances or in jurisdictions where consent is required under applicable data protection laws for sending promotional communications. |
| _**Service improvement and analytics**_ |  |
| • Contact data <br> • Demographic data <br> • Device serial number data <br> • Cryptocurrency-related information <br> • Communications data <br> • Solana Mobile Device usage data <br> • dApp Store interaction history data <br> • Location data | • **Legitimate Interests**. We have a legitimate interest in understanding how you use the Services in order to develop and improve the Services <br> • **Consent**, where required under applicable laws |
| _**Compliance and protection**_ |  |
| • Any and all data types relevant in the circumstances | • **Compliance with Law**<br> • **Legitimate Interests**. Where Compliance with Law is not applicable, we and any relevant third parties have a legitimate interest in participating in, supporting, and following legal process and requests, including through cooperation with authorities. We and any relevant third parties may also have a legitimate interest in ensuring the protection, maintenance, and enforcement of our and their rights, property, and/or safety. |
| _**Further uses**_ |  |
| • Any and all data types relevant in the circumstances | • The original legal basis relied upon if the relevant further use is compatible with the initial purpose for which the Personal Information was collected. <br> • **Consent**, if the relevant further use is not compatible with the initial purpose for which the personal information was collected. |

## Retention [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#retention "Direct link to Retention")

We retain personal information for as long as necessary to fulfill the purposes for which we collected it, including for the purposes of satisfying any legal, accounting, or reporting requirements, to establish or defend legal claims, or for compliance and protection purposes.

To determine the appropriate retention period for personal information, we consider the amount, nature, and sensitivity of the personal information, the potential risk of harm from unauthorized use or disclosure of your personal information, the purposes for which we process your personal information, and whether we can achieve those purposes through other means, and the applicable legal requirements.

When we no longer require the personal information, we have collected about you, we will either delete or anonymize it or, if this is not possible (for example, because your personal information has been stored in backup archives), then we will securely store your personal information and isolate it from any further processing until deletion is possible. If we anonymize your personal information (so that it can no longer be associated with you), we may use this information indefinitely without further notice to you.

## Other info [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#other-info "Direct link to Other info")

**No sensitive personal information.** If you provide any sensitive personal information (e.g., information related to racial or ethnic origin, political opinions, religion or other beliefs, health, biometrics or genetic characteristics, criminal background, or trade union membership) to us when you use the Services, you must consent to our processing and use of such sensitive personal information in accordance with this Privacy Policy. If you do not consent to our processing and use of such sensitive personal information, you must not submit such sensitive personal information through our Services.

**No Automated Decision-Making and Profiling.** As part of the Service, we do not engage in automated decision-making and/or profiling, which produces legal or similarly significant effects.

## Your rights [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#your-rights "Direct link to Your rights")

General. European data protection laws give you certain rights regarding your personal information. If you are located in Europe, you may ask us to take the following actions in relation to your personal information that we hold:

- **Access.** Provide you with information about our processing of your personal information and give you access to your personal information.

- **Correct.** Update or correct inaccuracies in your personal information.

- **Delete.** Delete your personal information where there is no good reason for us continuing to process it - you also have the right to ask us to delete or remove your personal information where you have exercised your right to object to processing (see below).

- **Transfer.** Transfer a machine-readable copy of your personal information to you or a third party of your choice.

- **Restrict.** Restrict the processing of your personal information, for example, if you want us to establish its accuracy or the reason for processing it.

- **Object.** Object to our processing of your personal information where we are relying on Legitimate Interests – you also have the right to object where we are processing your personal information for direct marketing purposes.

- **Withdraw Consent.** When we use your personal information based on your consent, you have the right to withdraw that consent at any time.


**Exercising These Rights.** You may submit these requests by email to [privacy@solanamobile.com](mailto:privacy@solanamobile.com) or our postal address provided above. We may request specific information from you to help us confirm your identity and process your request. Whether or not we are required to fulfill any request you make will depend on a number of factors (e.g., why and how we are processing your personal information), if we reject any request you may make (whether in whole or in part), we will let you know our grounds for doing so at the time, subject to any legal restrictions.

**Your Right to Lodge a Complaint with your Supervisory Authority.** In addition to your rights outlined above, if you are not satisfied with our response to a request you make or how we process your personal information, you can file a complaint with the data protection regulator in your habitual place of residence.

- _For users in the European Economic Area_ – the contact information for the data protection regulator in your place of residence can be found here: [https://edpb.europa.eu/about-edpb/board/members\_en](https://edpb.europa.eu/about-edpb/board/members_en)
  - _For users in the UK_ – the contact information for the UK data protection regulator is below:

    The Information Commissioner’s Office

    Water Lane, Wycliffe House

    Wilmslow - Cheshire SK9 5AF

    Tel. +44 303 123 1113

    Website: [https://ico.org.uk/make-a-complaint/](https://ico.org.uk/make-a-complaint/)

## Data Processing outside Europe [​](https://docs.solanamobile.com/dapp-publishing/privacy-policy\#data-processing-outside-europe "Direct link to Data Processing outside Europe")

We may share your personal information with third parties who may be based outside of the EEA, Switzerland, and/or UK. In such circumstances, those parties’ processing of your personal information will involve a transfer of your personal information outside of the EEA, Switzerland, and/or UK, where privacy laws may not be as protective as those in your state, province, or country.

You can obtain further information or a copy of or access safeguards under which your personal information is transferred outside of the EEA, Switzerland, and/or UK by contacting us at [privacy@solanamobile.com](mailto:privacy@solanamobile.com).

- [Index](https://docs.solanamobile.com/dapp-publishing/privacy-policy#index)
- [Personal information we collect](https://docs.solanamobile.com/dapp-publishing/privacy-policy#personal-information-we-collect)
- [How we use your personal information](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-we-use-your-personal-information)
- [How we share your personal information](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-we-share-your-personal-information)
- [Your choices](https://docs.solanamobile.com/dapp-publishing/privacy-policy#your-choices)
- [Other sites, services, and apps](https://docs.solanamobile.com/dapp-publishing/privacy-policy#other-sites,-services,-and-apps)
- [Security](https://docs.solanamobile.com/dapp-publishing/privacy-policy#security)
- [International data transfer](https://docs.solanamobile.com/dapp-publishing/privacy-policy#international-data-transfer)
- [Children](https://docs.solanamobile.com/dapp-publishing/privacy-policy#children)
- [Changes to this Privacy Policy](https://docs.solanamobile.com/dapp-publishing/privacy-policy#changes-to-this-privacy-policy)
- [How to contact us](https://docs.solanamobile.com/dapp-publishing/privacy-policy#how-to-contact-us)
- [State privacy rights notice](https://docs.solanamobile.com/dapp-publishing/privacy-policy#state-privacy-rights-notice)
- [Notice to European users](https://docs.solanamobile.com/dapp-publishing/privacy-policy#notice-to-european-users)
- [General](https://docs.solanamobile.com/dapp-publishing/privacy-policy#general)
- [Our legal bases for processing](https://docs.solanamobile.com/dapp-publishing/privacy-policy#our-legal-bases-for-processing)
- [Retention](https://docs.solanamobile.com/dapp-publishing/privacy-policy#retention)
- [Other info](https://docs.solanamobile.com/dapp-publishing/privacy-policy#other-info)
- [Your rights](https://docs.solanamobile.com/dapp-publishing/privacy-policy#your-rights)
- [Data Processing outside Europe](https://docs.solanamobile.com/dapp-publishing/privacy-policy#data-processing-outside-europe)

## dApp Publishing Steps
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/publishing_releases#__docusaurus_skipToContent_fallback)

On this page

When you're ready to publish additional releases of your dApp, follow these steps.

## 1\. Create an updated APK file [​](https://docs.solanamobile.com/dapp-publishing/publishing_releases\#1-create-an-updated-apk-file "Direct link to 1. Create an updated APK file")

Each release of your dApp will require an updated release APK file, signed with the same signing key you used for your initial release.

It is **very** important that each new APK file include the following updates:

- The `versionName` value in `build.gradle` must be updated from the previous release. This field can be set to arbitrary values.
- The `versionCode` value in `build.gradle` must be incremented by one monotonically between each update.

tip

You can learn more about APK versioning in the [Android developer docs](https://developer.android.com/studio/publish/versioning).

## 2\. Update your configuration file [​](https://docs.solanamobile.com/dapp-publishing/publishing_releases\#2-update-your-configuration-file "Direct link to 2. Update your configuration file")

Edit the `release` and `solana_mobile_dapp_publisher_portal` sections of your configuration file to reflect any changes.

tip

Be sure to include `new_in_version` details so users can know what to expect with the update!

## 3\. Mint a new release NFT [​](https://docs.solanamobile.com/dapp-publishing/publishing_releases\#3-mint-a-new-release-nft "Direct link to 3. Mint a new release NFT")

The Solana dApp store requires each new release of your dApp to be minted as a release NFT with all the changes discussed in this section.

Run the same CLI command as the "Create the release NFT" step from the [Mint a release NFT](https://docs.solanamobile.com/dapp-publishing/submit#mint-a-release-nft) section in these docs.

## 4\. Submit an update to the Publisher Portal [​](https://docs.solanamobile.com/dapp-publishing/publishing_releases\#4-submit-an-update-to-the-publisher-portal "Direct link to 4. Submit an update to the Publisher Portal")

Submit the update to the Solana dApp Publisher Portal, where the new release will enter a review queue for inclusion in the dApp store catalog:

```text
npx dapp-store publish update -k <path_to_your_keypair> --requestor-is-authorized --complies-with-solana-dapp-store-policies
```

- [1\. Create an updated APK file](https://docs.solanamobile.com/dapp-publishing/publishing_releases#1-create-an-updated-apk-file)
- [2\. Update your configuration file](https://docs.solanamobile.com/dapp-publishing/publishing_releases#2-update-your-configuration-file)
- [3\. Mint a new release NFT](https://docs.solanamobile.com/dapp-publishing/publishing_releases#3-mint-a-new-release-nft)
- [4\. Submit an update to the Publisher Portal](https://docs.solanamobile.com/dapp-publishing/publishing_releases#4-submit-an-update-to-the-publisher-portal)

## Publish Google Play Apps
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#__docusaurus_skipToContent_fallback)

On this page

## Overview [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#overview "Direct link to Overview")

Publishing your existing Google Play app to the dApp Store requires:

1. A release APK file signed with a **new, unique signing key** (different from Google Play)
2. Following the standard dApp Store publishing workflow

Key differences from Google Play:

- **File Format**: dApp Store submission requires APK files (Google Play uses AAB)
- **Signing Key**: Must use a completely separate signing key from Google Play
- **In-App Purchases**: No 30% tax on in-app purchases or transactions

Critical Requirement

You cannot use the same signing key for both Google Play and the dApp Store.

## Build Your APK [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#build-your-apk "Direct link to Build Your APK")

### 1\. Create New Signing Key [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#1-create-new-signing-key "Direct link to 1. Create New Signing Key")

Generate a new signing key exclusively for the dApp Store:

```bash
keytool -genkey -v -keystore dappstore.keystore \
  -alias dappstore \
  -keyalg RSA \
  -keysize 2048 \
  -validity 10000
```

**Store the keystore file and passwords securely** \- losing them means you cannot update your app.

For reference, view the [Android app signing guide](https://developer.android.com/studio/publish/app-signing).

### 2\. Build Signed APK [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#2-build-signed-apk "Direct link to 2. Build Signed APK")

_![Native Android](https://docs.solanamobile.com/img/android_icon.svg)_ Native Android_![Expo](https://docs.solanamobile.com/img/expo-sdk-icon.svg)_ Expo

**1.** Configure dual-store setup in `app/build.gradle` using product flavors:

```gradle
android {
    signingConfigs {
        // Existing Google Play signing config
        googlePlay {
            storeFile file("keystores/googleplay.keystore")
            storePassword "your_googleplay_keystore_password"
            keyAlias "googleplay"
            keyPassword "your_googleplay_key_password"
        }

        // dApp Store signing config
        dappStore {
            storeFile file("keystores/dappstore.keystore")
            storePassword "your_dappstore_keystore_password"
            keyAlias "dappstore"
            keyPassword "your_dappstore_key_password"
        }
    }

    flavorDimensions = ['store']

    productFlavors {
        googlePlay {
            dimension 'store'
        }

        dappStore {
            dimension 'store'
        }
    }

    buildTypes {
        release {
            // Assign signing configs to each flavor
            productFlavors.googlePlay.signingConfig signingConfigs.googlePlay
            productFlavors.dappStore.signingConfig signingConfigs.dappStore
        }
    }
}
```

**2.** Build the dApp Store APK:

```bash
./gradlew assembleDappStoreRelease
```

**3.** Alternatively, build using Android Studio IDE: **Build** → **Select Build Variant** → **dappStoreRelease** → **Build APK**.

Your dApp Store APK will be at `app/build/outputs/apk/dappStore/release/app-dappStore-release.apk`

For reference, view the [Android signing documentation](https://developer.android.com/studio/publish/app-signing#gradle-sign).

### 3\. Verify APK [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#3-verify-apk "Direct link to 3. Verify APK")

Confirm your APK is properly signed before submission:

```bash
apksigner verify --print-certs app-release.apk
```

For reference, view the [apksigner documentation](https://developer.android.com/studio/command-line/apksigner#usage-verify).

## Next Steps [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#next-steps "Direct link to Next Steps")

With your signed APK ready, follow the standard dApp Store publishing process and [Submit your app](https://docs.solanamobile.com/dapp-publishing/submit-new-app)

## Additional Resources [​](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play\#additional-resources "Direct link to Additional Resources")

- [Publisher Policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy) \- Review dApp Store requirements
- [Support](https://docs.solanamobile.com/dapp-publishing/support) \- Get help with publishing issues

- [Overview](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#overview)
- [Build Your APK](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#build-your-apk)
  - [1\. Create New Signing Key](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#1-create-new-signing-key)
  - [2\. Build Signed APK](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#2-build-signed-apk)
  - [3\. Verify APK](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#3-verify-apk)
- [Next Steps](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#next-steps)
- [Additional Resources](https://docs.solanamobile.com/dapp-publishing/publishing-from-google-play#additional-resources)

## dApp Update Process
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/publishing-updates#__docusaurus_skipToContent_fallback)

On this page

When you're ready to publish an updated release of your dApp, follow these steps.

## 1\. Create an updated APK file [​](https://docs.solanamobile.com/dapp-publishing/publishing-updates\#1-create-an-updated-apk-file "Direct link to 1. Create an updated APK file")

Each release of your dApp will require an updated release APK file, signed with the same signing key you used for your initial release.

It is **very** important that each new APK file include the following updates:

- The `versionName` value in `build.gradle` must be updated from the previous release. This field can be set to arbitrary values.
- The `versionCode` value in `build.gradle` must be incremented by one monotonically between each update.

tip

You can learn more about APK versioning in the [Android developer docs](https://developer.android.com/studio/publish/versioning).

## 2\. Update your configuration file [​](https://docs.solanamobile.com/dapp-publishing/publishing-updates\#2-update-your-configuration-file "Direct link to 2. Update your configuration file")

Edit the `release` and `solana_mobile_dapp_publisher_portal` sections of your configuration file to reflect any changes.

tip

Be sure to include `new_in_version` details so users can know what to expect with the update!

## 3\. Mint a new release NFT [​](https://docs.solanamobile.com/dapp-publishing/publishing-updates\#3-mint-a-new-release-nft "Direct link to 3. Mint a new release NFT")

The Solana dApp store requires each new release of your dApp to be minted as a release NFT with all the changes discussed in this section.

Run the same CLI command as the "Create the release NFT" step from the [Mint a release NFT](https://docs.solanamobile.com/dapp-publishing/submit#mint-a-release-nft) section in these docs.

## 4\. Submit an update to the Publisher Portal [​](https://docs.solanamobile.com/dapp-publishing/publishing-updates\#4-submit-an-update-to-the-publisher-portal "Direct link to 4. Submit an update to the Publisher Portal")

Submit the update to the Solana dApp Publisher Portal, where the new release will enter a review queue for inclusion in the dApp store catalog:

```text
npx dapp-store publish update -k <path_to_your_keypair> -u <mainnet_beta_rpc_url> --requestor-is-authorized --complies-with-solana-dapp-store-policies
```

By submitting this command you agree to, and represent that you have read, (i) the [Solana Mobile dApp Store Developer Agreement](https://docs.solanamobile.com/dapp-publishing/agreement), including the arbitration clause linked [here](https://docs.solanamobile.com/dapp-publishing/agreement#disputes), meaning that, where enforceable, any dispute related to the dApp Store will be resolved through BINDING ARBITRATION on an individual, non-class basis, and (ii) the [Solana Mobile Publisher Policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy).

- [1\. Create an updated APK file](https://docs.solanamobile.com/dapp-publishing/publishing-updates#1-create-an-updated-apk-file)
- [2\. Update your configuration file](https://docs.solanamobile.com/dapp-publishing/publishing-updates#2-update-your-configuration-file)
- [3\. Mint a new release NFT](https://docs.solanamobile.com/dapp-publishing/publishing-updates#3-mint-a-new-release-nft)
- [4\. Submit an update to the Publisher Portal](https://docs.solanamobile.com/dapp-publishing/publishing-updates#4-submit-an-update-to-the-publisher-portal)

## Solana dApp Store Q&A
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/qanda#__docusaurus_skipToContent_fallback)

What does it mean for the Solana dApp Store to be “fee-free”?

Solana Mobile Inc. does not collect any fees on in-app purchases, app purchases, or subscriptions, nor are any fees collected on its behalf by apps in the catalog. Users may incur fees from usage of apps contained within the catalog, such as network transaction fees.

Can I charge for my app?

Absolutely! We’re exploring the addition of purchasing apps using token-gating directly within the Solana dApp Store. In the meantime, however, you are free to establish a direct economic relationship with your customers, on-chain or off.

When will you start taking submissions for the Solana dApp Store?

We’re accepting submissions starting now!

How do I build a Solana-compatible dApp?

We recommend you review the [Solana Mobile Stack](https://github.com/solana-mobile/solana-mobile-stack-sdk) Github and integrate it with the SDK that corresponds to your use case, in order to transact with wallets and dApps seamlessly.

Where can I go to ask questions?

Come ask us on [Discord](https://discord.gg/solanamobile) in the `#dapp-store` channel.

Do I need to use the dapp-store CLI tooling to mint my publishing NFTs?

The `dapp-store` CLI handles all the tasks necessary for creating and minting NFTs compatible with the Solana Mobile dApp store. However, it is by no means the only way to create these NFTs and the packages have been designed to be portable to other client contexts besides the CLI.

You can find the NFT spec documentation [here](https://github.com/solana-mobile/dapp-publishing/tree/main/publishing-spec)

## Solana DApp Setup
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/setup#__docusaurus_skipToContent_fallback)

On this page

## Prerequisites [​](https://docs.solanamobile.com/dapp-publishing/setup\#prerequisites "Direct link to Prerequisites")

### Node.js [​](https://docs.solanamobile.com/dapp-publishing/setup\#nodejs "Direct link to Node.js")

Please run all CLI tooling with Node version 18 to 21. Latest known compatibility is Node `v21.7.3`.

```shell
corepack enable
corepack prepare pnpm@`npm info pnpm --json | jq -r .version` --activate
```

If you don't have [jq](https://stedolan.github.io/jq/) installed, you can [install it](https://formulae.brew.sh/formula/jq), or manually get the current version of pnpm with `npm info pnpm` and use like this:

```shell
corepack prepare pnpm@7.13.4 --activate
```

### Android SDK Tools [​](https://docs.solanamobile.com/dapp-publishing/setup\#android-sdk-tools "Direct link to Android SDK Tools")

You must have the Android SDK build tools available for use by the `dapp-store` CLI. If you have Android Studio, these tools are available as part of that installation (for e.g., on MacOS, they can be found in ~/Library/Android/sdk/build-tools/{version}). If you do not have Android Studio installed, or wish to use a standalone version of the Android SDK build tools, please follow the instructions [here](https://developer.android.com/studio/intro/update#sdk-manager).

The path to the SDK build tools can be provided either directly to subcommands that require it with the `-b` option, or indirectly via a `.env` file. Please provide a path to a specific, recent version of the SDK tools (e.g., `~/Library/Android/sdk/build-tools/33.0.0`) as older versions do not have the requisite dependency:

```shell
echo "ANDROID_TOOLS_DIR=\"<path_to_android_sdk_version_build_tools_dir>\"" > .env
```

### Java Environment Variable [​](https://docs.solanamobile.com/dapp-publishing/setup\#java-environment-variable "Direct link to Java Environment Variable")

Some utilities in the Android tools directory require you to configure and make a `JAVA_HOME` environment variable available to your terminal app. This variable points to the root directory of your installed Java Development Kit, or JDK. If you have Android studio installed, there is already a JDK included (in recent versions of Android Studio this is called the "JBR").

To find the location of the JDK/JBR installed with Android Studio, follow [these instructions in the Android Studio documentation.](https://developer.android.com/build/jdks#set-jdk-in-studio). While discussing the mthod for _setting_ the JDK location, it also provides the correct method for obtaining the current installation directory.

If you do not have Android Studio installed, you can download a copy of the the OpenJDK [here](https://openjdk.org/projects/jdk/17/). We recommend OpenJDK 17.

Once you have downloaded and installed the JDK, you will need to set the `JAVA_HOME` environment variable per the appropriate method for your operating system. [This page](https://www3.ntu.edu.sg/home/ehchua/programming/howto/Environment_Variables.html) has a good overview for all major operating systems.

### ffmpeg [​](https://docs.solanamobile.com/dapp-publishing/setup\#ffmpeg "Direct link to ffmpeg")

If you plan on uploading video preview assets, make sure you have the [ffmpeg](https://www.ffmpeg.org/download.html) utility library installed.

Follow this [guide](https://support.audacityteam.org/basics/installing-ffmpeg) to install `ffmpeg` for your operating system.

## Getting Started [​](https://docs.solanamobile.com/dapp-publishing/setup\#getting-started "Direct link to Getting Started")

In your application folder (e.g., `android-app`):

caution

If you're seeing an error, ensure that your `node -v` is returning a version `>= 18` and `<= 21`.
Latest tested compatibile version is Node `v21.7.3`.

```shell
mkdir publishing
cd publishing

pnpm init
pnpm install --save-dev @solana-mobile/dapp-store-cli
npx dapp-store init
npx dapp-store --help
```

## CLI Updates [​](https://docs.solanamobile.com/dapp-publishing/setup\#cli-updates "Direct link to CLI Updates")

The CLI will automatically check for updated versions on npm and restrict operations on a periodic basis. If your CI/CD deployments fail, be sure to check if there is a required update.

To update the CLI run:

```bash
pnpm install --save-dev @solana-mobile/dapp-store-cli@latest
```

- [Prerequisites](https://docs.solanamobile.com/dapp-publishing/setup#prerequisites)
  - [Node.js](https://docs.solanamobile.com/dapp-publishing/setup#nodejs)
  - [Android SDK Tools](https://docs.solanamobile.com/dapp-publishing/setup#android-sdk-tools)
  - [Java Environment Variable](https://docs.solanamobile.com/dapp-publishing/setup#java-environment-variable)
  - [ffmpeg](https://docs.solanamobile.com/dapp-publishing/setup#ffmpeg)
- [Getting Started](https://docs.solanamobile.com/dapp-publishing/setup#getting-started)
- [CLI Updates](https://docs.solanamobile.com/dapp-publishing/setup#cli-updates)

## Release NFT Submission Guide
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/submit#__docusaurus_skipToContent_fallback)

On this page

After minting an App NFT, you will need to mint a **Release NFT** in order to submit for app review.

A Release NFT:

- Contains metadata that represents a specific release version of an app.
- Should be newly created each time an updated app version is submitted.

## Mint a release NFT [​](https://docs.solanamobile.com/dapp-publishing/submit\#mint-a-release-nft "Direct link to Mint a release NFT")

Using the same wallet that contains your App NFT, run this command.

```shell
npx dapp-store create release -k <path_to_your_keypair> -b <path_to_your_android_sdk_build_tools> [-u <mainnet_beta_rpc_url>]
```

**You will repeat this step for each new version of your dApp you want to release**. The mint address of the latest release is recorded in your configuration file.

tip

When using CLI version >= `0.8.0`, the following commands will submit a Solana transaction that includes a default priority fee of `500000` lamports.

To customize this value, use param `-p` or `--priority-fee-lamports <priority-fee-lamports>`

caution

Please make sure your network connection is reliable and has a minimum upload speed of 0.25 megabytes per second.

## Submit your app [​](https://docs.solanamobile.com/dapp-publishing/submit\#submit-your-app "Direct link to Submit your app")

After minting a complete set of on-chain NFTs (App NFT and Release NFT), you may choose to submit them to the Solana dApp Publisher Portal, as a candidate for inclusion in the Solana dApp Store catalog:

```shell
npx dapp-store publish submit -k <path_to_your_keypair> -u <mainnet_beta_rpc_url> --requestor-is-authorized --complies-with-solana-dapp-store-policies
```

The two flags for this command (`--requestor-is-authorized` and `--complies-with-solana-dapp-store-policies`) are attestations from the requestor that this dApp is compliant with Solana dApp Store policies, and that they are authorized to submit this request to the Solana dApp Publisher Portal.

By submitting this command you agree to, and represent that you have read, (i) the [Solana Mobile dApp Store Developer Agreement](https://docs.solanamobile.com/dapp-publishing/agreement), including the arbitration clause linked [here](https://docs.solanamobile.com/dapp-publishing/agreement#:~:text=force%20and%20effect.-,16.6.%20Arbitration.,-The%20parties%20agree), meaning that, where enforceable, any dispute related to the dApp Store will be resolved through BINDING ARBITRATION on an individual, non-class basis, and (ii) the [Solana Mobile Publisher Policy](https://docs.solanamobile.com/dapp-publishing/publisher-policy).

## Get in contact for App Review [​](https://docs.solanamobile.com/dapp-publishing/submit\#get-in-contact-for-app-review "Direct link to Get in contact for App Review")

Congrats! You've successfully submitted your app. Now, we'll review your app based on our policies.

1. Join the Solana Mobile Discord.
2. In the `#developer` channel, get the developer role.
3. Leave a message in the `#dapp-store` channel that you've completed app review.
4. We'll be in contact through the channel shortly after.

- [Mint a release NFT](https://docs.solanamobile.com/dapp-publishing/submit#mint-a-release-nft)
- [Submit your app](https://docs.solanamobile.com/dapp-publishing/submit#submit-your-app)
- [Get in contact for App Review](https://docs.solanamobile.com/dapp-publishing/submit#get-in-contact-for-app-review)

## dApp Update Submission
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/submit-an-update#__docusaurus_skipToContent_fallback)

On this page

When you're ready to publish an updated release of your dApp, follow these steps.

## 1\. Navigate to the Publisher Portal [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#1-navigate-to-the-publisher-portal "Direct link to 1. Navigate to the Publisher Portal")

Log into the [Solana dApp Publisher Portal](https://publish.solanamobile.com/) and find your published app in the sidebar.

## 2\. Update your app details [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#2-update-your-app-details "Direct link to 2. Update your app details")

If needed, you can make changes to your app details (e.g Name, Descriptions, Preview Assets, etc) in the "Details" page.

**Note: These changes will only reflect in the dApp Store after a new release version is approved**

![dApp details screenshot](https://docs.solanamobile.com/assets/images/update-dapp-details-7ff2f0b0d3981bc06b5ca806933c864a.png)

## 3\. Submit an updated release version [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#3-submit-an-updated-release-version "Direct link to 3. Submit an updated release version")

Navigate to your app's "Home" screen and press the "New Version" button.

### Submit an existing APK [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#submit-an-existing-apk "Direct link to Submit an existing APK")

If you only want to make a change to your app details and do not want to submit a new APK build, then select
the **"use existing APK"** option.

### Submit an updated APK [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#submit-an-updated-apk "Direct link to Submit an updated APK")

If you want to submit a new APK, ensure:

- The APK is signed with the same Android signing key you used for your initial release.
- The `versionName` and `versionCode` value is properly incremented between each update.
- The "What's new" section is filled out. This section will be displayed to users in your dApp Store listing page.

After you've completed the upload, press "Submit" and you'll be prompted to sign messages and transactions for uploading to Arweave and minting your Release NFT.

![dApp Update Upload](https://docs.solanamobile.com/assets/images/dapp-update-upload-634ea669508230de107a7bacd99e829a.png)

Congratulations on submitting an app update! 🎉

## After submission [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#after-submission "Direct link to After submission")

Once submitted, the new release automatically enters the app review queue and will immediately go live once approved.

### App Review [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#app-review "Direct link to App Review")

- It typically takes 2-5 business days for app review, so please be patient as we go through the review queue.
- You'll be notified via your developer email when the app is approved or if changes are needed.

### Get in contact [​](https://docs.solanamobile.com/dapp-publishing/submit-an-update\#get-in-contact "Direct link to Get in contact")

To get in contact for any questions regarding publishing, app review, or launching on the dApp Store, please see
join the [Solana Mobile Discord](http://discord.gg/solanamobile) and see the `#dapp-store` channel for instructions to get in touch.

- [1\. Navigate to the Publisher Portal](https://docs.solanamobile.com/dapp-publishing/submit-an-update#1-navigate-to-the-publisher-portal)
- [2\. Update your app details](https://docs.solanamobile.com/dapp-publishing/submit-an-update#2-update-your-app-details)
- [3\. Submit an updated release version](https://docs.solanamobile.com/dapp-publishing/submit-an-update#3-submit-an-updated-release-version)
  - [Submit an existing APK](https://docs.solanamobile.com/dapp-publishing/submit-an-update#submit-an-existing-apk)
  - [Submit an updated APK](https://docs.solanamobile.com/dapp-publishing/submit-an-update#submit-an-updated-apk)
- [After submission](https://docs.solanamobile.com/dapp-publishing/submit-an-update#after-submission)
  - [App Review](https://docs.solanamobile.com/dapp-publishing/submit-an-update#app-review)
  - [Get in contact](https://docs.solanamobile.com/dapp-publishing/submit-an-update#get-in-contact)

## DApp Support Discord
[Skip to main content](https://docs.solanamobile.com/dapp-publishing/support#__docusaurus_skipToContent_fallback)

On this page

## Discord [​](https://docs.solanamobile.com/dapp-publishing/support\#discord "Direct link to Discord")

Come chat with us on our [Discord](https://discord.gg/solanamobile) in the `#dapp-store` channel.

- [Discord](https://docs.solanamobile.com/dapp-publishing/support#discord)

## Solana Mobile Community
[Skip to main content](https://docs.solanamobile.com/developers/community#__docusaurus_skipToContent_fallback)

On this page

## Discord [​](https://docs.solanamobile.com/developers/community\#discord "Direct link to Discord")

Currently, most technical discussion around the Solana Mobile Stack happens in our offical [Solana Mobile Discord](https://discord.gg/solanamobile).
If you have any questions, are interested in contributing, or want to get in touch with the development community, come join and send a message!

## Twitter [​](https://docs.solanamobile.com/developers/community\#twitter "Direct link to Twitter")

On Twitter, you can follow [@SolanaMobile](https://twitter.com/solanamobile).

- [Discord](https://docs.solanamobile.com/developers/community#discord)
- [Twitter](https://docs.solanamobile.com/developers/community#twitter)

## Android Development Setup
[Skip to main content](https://docs.solanamobile.com/developers/development-setup#__docusaurus_skipToContent_fallback)

On this page

This section covers the steps to:

- Set up your local environment for Android development.
- Configure a device or emulator for building apps for the dApp Store.
- Install an MWA-compliant wallet app for development purposes.

## Set up Android development environment [​](https://docs.solanamobile.com/developers/development-setup\#set-up-android-development-environment "Direct link to Set up Android development environment")

To build apps for the dApp Store, you need to setup your environment for Android development.

Supported Frameworks

- Expo / React Native
- Kotlin (Native)
- Flutter

For both Expo or React Native Android development:

- View the Expo [**setup documentation**](https://docs.expo.dev/get-started/set-up-your-environment/?platform=android&device=physical&mode=development-build&buildEnv=local) (Choose custom development build instead of Expo Go).

For Kotlin Android development:

- Install [Android Studio](https://developer.android.com/studio/install).

For Flutter Android development:

- View the official Flutter [**setup documentation**](https://docs.flutter.dev/get-started/install/macos/mobile-android#configure-android-development).

## Setup Device/Emulator [​](https://docs.solanamobile.com/developers/development-setup\#setup-deviceemulator "Direct link to Setup Device/Emulator")

You can test your app during development on any Android device or emulator. A Solana Mobile device is **not** required for dApp Store development—testing on a standard Android device is typically sufficient.

For detailed device setup instructions, refer to Android's official documentation:

- [Setting up a physical device](https://developer.android.com/studio/run/device)
- [Configuring the Android Emulator](https://developer.android.com/studio/run/emulator)

## Install a development wallet app [​](https://docs.solanamobile.com/developers/development-setup\#install-a-development-wallet-app "Direct link to Install a development wallet app")

The [Mobile Wallet Adapter](https://docs.solanamobile.com/mobile-wallet-adapter/overview) (MWA) library allows your app to connect and interact with compatible wallet apps on your device.

Install an MWA-compatible wallet app to test your app's Mobile Wallet Adapter integration.

### Mock MWA Wallet [​](https://docs.solanamobile.com/developers/development-setup\#mock-mwa-wallet "Direct link to Mock MWA Wallet")

Solana Mobile provides a mock development wallet for you to test your app with and get a feel of what Seed Vault Wallet interactions on the Seeker will look like.

The mock wallet features:

- Mobile Wallet Adapter support
- Simulate connection or signing errors
- QR Code Scanning for MWA Remote Connections

It is intended for development purposes only, so it does not store a persistent keypair and the wallet is reset each time the app is exited.

Installation:

1. Clone the Mock MWA Wallet repo from the [github repository](https://github.com/solana-mobile/mock-mwa-wallet)

```text
git clone https://github.com/solana-mobile/mock-mwa-wallet.git
```

2. In Android Studio, `Open project > Navigate to the directory > Select mock-mwa-wallet/android/build.gradle`

3. After Android Studio finishes loading the project, select `fakewallet` in the build/run configuration dropdown in the top right


![Mock MWA Wallet build](https://docs.solanamobile.com/assets/images/mock-mwa-wallet-install-f375288b6df24c4ee13a916612c79223.png)

4. After it builds successfully, you should see the app on your connected Android device or emulator.

### Other MWA-compliant wallet apps [​](https://docs.solanamobile.com/developers/development-setup\#other-mwa-compliant-wallet-apps "Direct link to Other MWA-compliant wallet apps")

You can also install and test with these popular MWA-compatible wallet apps:

- [Phantom](https://phantom.com/)
- [Solflare](https://www.solflare.com/)

## Next steps [​](https://docs.solanamobile.com/developers/development-setup\#next-steps "Direct link to Next steps")

You have a development environment and testing device, and are now ready to start developing.

Check out these links to quickly get an app running:

- [Quickstart](https://docs.solanamobile.com/react-native/quickstart)
- [Sample Apps](https://docs.solanamobile.com/sample-apps/sample_app_overview)

- [Set up Android development environment](https://docs.solanamobile.com/developers/development-setup#set-up-android-development-environment)
- [Setup Device/Emulator](https://docs.solanamobile.com/developers/development-setup#setup-deviceemulator)
- [Install a development wallet app](https://docs.solanamobile.com/developers/development-setup#install-a-development-wallet-app)
  - [Mock MWA Wallet](https://docs.solanamobile.com/developers/development-setup#mock-mwa-wallet)
  - [Other MWA-compliant wallet apps](https://docs.solanamobile.com/developers/development-setup#other-mwa-compliant-wallet-apps)
- [Next steps](https://docs.solanamobile.com/developers/development-setup#next-steps)

## Solana Mobile Frameworks
[Skip to main content](https://docs.solanamobile.com/developers/mobile-development-frameworks#__docusaurus_skipToContent_fallback)

On this page

## Choose a development framework [​](https://docs.solanamobile.com/developers/mobile-development-frameworks\#choose-a-development-framework "Direct link to Choose a development framework")

Although, the Solana Mobile Stack is primarily written in native Android, we also have support for popular mobile
development frameworks.

### SDKs [​](https://docs.solanamobile.com/developers/mobile-development-frameworks\#sdks "Direct link to SDKs")

These are SDKs that are maintained by the Solana Mobile team.

[_![](https://docs.solanamobile.com/img/react-native-96.svg)_ **React Native**\\
\\
Quickly start building your mobile dApp with React Native, with access to a selection of familiar web libraries.](https://docs.solanamobile.com/react-native/overview)

[_![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)_ **Kotlin**\\
\\
Develop a Kotlin Android app to utilize the full capabilities of the Android OS and build a performant native experience.](https://docs.solanamobile.com/android-native/overview)

### Community SDKs [​](https://docs.solanamobile.com/developers/mobile-development-frameworks\#community-sdks "Direct link to Community SDKs")

These SDKs are actively maintained, supported, and used by members and developers of our community. Click to learn more about
the capabilities supported by each, the state of development, and how to get started.

[_![](https://docs.solanamobile.com/img/flutter-icon.svg)_ **Flutter**\\
\\
An actively maintained SDK for building Solana mobile dApps with Flutter.](https://docs.solanamobile.com/flutter/overview)

[_![](https://docs.solanamobile.com/img/unity-logo.png)_ **Unity**\\
\\
Integrate the Solana Mobile stack into your Unity mobile game.](https://docs.solanamobile.com/unity/unity_sdk)

[_![](https://docs.solanamobile.com/img/unreal-logo.png)_ **Unreal Engine**\\
\\
An early stage SDK for integrating Solana Mobile into an Unreal Engine mobile game.](https://docs.solanamobile.com/unreal/unreal_sdk)

- [Choose a development framework](https://docs.solanamobile.com/developers/mobile-development-frameworks#choose-a-development-framework)
  - [SDKs](https://docs.solanamobile.com/developers/mobile-development-frameworks#sdks)
  - [Community SDKs](https://docs.solanamobile.com/developers/mobile-development-frameworks#community-sdks)

## Solana Mobile Scaffolds
[Skip to main content](https://docs.solanamobile.com/developers/mobile-scaffold-apps#__docusaurus_skipToContent_fallback)

## Mobile dApp Wallet Guide
[Skip to main content](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#__docusaurus_skipToContent_fallback)

On this page

This reference aims to give a conceptual overview of the architecture of a mobile dApp using the Solana Mobile Stack.

## High Level [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#high-level "Direct link to High Level")

The following diagram shows a bird's eye view of a mobile dApp's interactions with mobile wallets and the Solana network.

![Full Architecture Diagram](https://docs.solanamobile.com/diagrams/dapp_architecture_full.svg)

## Mobile Wallet Adapter Protocol [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#mobile-wallet-adapter-protocol "Direct link to Mobile Wallet Adapter Protocol")

The \*\*Mobile Wallet Adapter (MWA) \*\* protocol is what defines the communication exchange between a dApp and a mobile wallet.
In the protocol, the dApp sends requests (i.e: authorization or signing), while the wallet is responsible for displaying
these requests to the user and responding back to the dApp if approved.

For an extensive, deep dive into the specifics of the protocol and MWA methods, refer to the [MWA spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html).

### Session Establishment [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#session-establishment "Direct link to Session Establishment")

To begin the protocol, a dApp initiates first contact with a mobile wallet and establishes an **MWA session**.
With the current SDKs, the MWA session is initiated through Android intents, with the dApp broadcasting an intent
with the `solana-wallet://` scheme.

![Session Establishment Diagram](https://docs.solanamobile.com/diagrams/session_establishment.svg)

A wallet then receives the intent and starts a websocket connection, thus establishing a channel for commmunication.

### Example: Authorize and Sign Transaction [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#example-authorize-and-sign-transaction "Direct link to Example: Authorize and Sign Transaction")

Once a session is established, the dApp can now begin sending MWA Requests to receive signed transactions from the wallet.
This example case outlines an MWA session where the dApp:

1. Establishes a session with a wallet.
2. Requests authorization, elevating the session to an "authorized state" and receiving a list of authorized accounts and an authToken.
3. Requests transaction signing, receiving a transaction signed by the authorized accounts.

![Authorize and Sign Diagram](https://docs.solanamobile.com/diagrams/authorize_and_sign.svg)

In future sessions, the dApp can initiate with the valid authToken to immediately elevate to an "authorizd state", skipping the "connect" step.

While the protocol technically supports multiple accounts, most wallet apps only implement a single account authorization per session.

For a more detailed diagram that shows the full communication exchange, refer to this [section in the spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#authorize-and-sign-transaction).

## Submitting to the Solana network [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#submitting-to-the-solana-network "Direct link to Submitting to the Solana network")

Just like web dApps, the process for a mobile dApp submitting transactions to the blockchain network is the same. The dApp specifies
a cluster and an RPC endpoint then sends the transaction payload, following the [JSON RPC API](https://docs.solana.com/api).

For certain usecases, the dApp may choose to communicate with the RPC through the [Websocket API](https://docs.solana.com/api/websocket)

![Submit to RPC Diagram](https://docs.solanamobile.com/diagrams/submit_rpc.svg)

### Sign and Send Transaction [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive\#sign-and-send-transaction "Direct link to Sign and Send Transaction")

For submitting transactions, it is encouraged for the dApp to send a `sign_and_send_transaction` MWA request to the wallet. This request
type sends a unsigned transaction to the wallet. If authorized, the wallet will then sign the transaction and send it to the network with its
own implementation. Depending on the wallet app, this can include applying its own priority fee.

Relying on the wallet reduces the risk of replay attacks with [durable nonce based transactions](https://docs.solana.com/implemented-proposals/durable-tx-nonces), which can be abused with `sign_transactions`.

![Sign and Send Diagram](https://docs.solanamobile.com/diagrams/sign_and_send.svg)

- [High Level](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#high-level)
- [Mobile Wallet Adapter Protocol](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#mobile-wallet-adapter-protocol)
  - [Session Establishment](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#session-establishment)
  - [Example: Authorize and Sign Transaction](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#example-authorize-and-sign-transaction)
- [Submitting to the Solana network](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#submitting-to-the-solana-network)
  - [Sign and Send Transaction](https://docs.solanamobile.com/developers/mobile-wallet-adapter-deep-dive#sign-and-send-transaction)

## Mobile Wallet Adapter Guide
[Skip to main content](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#__docusaurus_skipToContent_fallback)

On this page

The Solana Mobile Stack was designed to be compatible on the mobile web. This document will
explain how to ensure a mobile web app can be integrated with Solana Mobile libraries.

## Android Web [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#android-web "Direct link to Android Web")

Mobile Wallet Adapter library is built to also support functionality on the Android Chrome browser.

In particular, [`@solana-mobile/wallet-adapter-mobile`](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/js/packages/wallet-adapter-mobile) is a plugin developed for use with `@solana/wallet-adapter` to enable MWA for web apps on Android.

### Usage [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#usage "Direct link to Usage")

Users of these libraries do not need to take any extra steps:

- `@solana/wallet-adapter-react@">=0.15.21"`

Those libraries automatically bundle the Mobile Wallet Adapter plugin, and enable it when running in a compatible mobile environment.

### Customization [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#customization "Direct link to Customization")

Developers might wish to customize the behavior of this plugin for their app. Specifying the app's name and icon, deciding which address to select in the event the wallet authorizes the app to use more than one, specifying which network cluster to communicate with, and more are made possible by creating an instance of the mobile wallet adapter like this.

tip

It is highly recommended to provide a custom `appIdentity` with your app name and an identifable icon to help
users understand what app they are interacting with.

If left to default, the user will see an _"Unknown app_" label displayed and a missing icon.

```ts
new SolanaMobileWalletAdapter({
  addressSelector: createDefaultAddressSelector(),
  appIdentity: {
    name: "My app",
    uri: "https://myapp.io",
    icon: "relative/path/to/icon.png", // resolves to https://myapp.io/relative/path/to/icon.png
  },
  authorizationResultCache: createDefaultAuthorizationResultCache(),
  cluster: WalletAdapterNetwork.Devnet,
  onWalletNotFound: createDefaultWalletNotFoundHandler(),
});
```

Developers who use `@solana/wallet-adapter-react@">=0.15.21"` can supply this custom instance to `WalletProvider` which will use it to override the default one.

```ts
const wallets = useMemo(
  () => [\
    new SolanaMobileWalletAdapter({\
      addressSelector: createDefaultAddressSelector(),\
      appIdentity: {\
        name: "My app",\
        uri: "https://myapp.io",\
        icon: "relative/path/to/icon.png",\
      },\
      authorizationResultCache: createDefaultAuthorizationResultCache(),\
      cluster: WalletAdapterNetwork.Devnet,\
      onWalletNotFound: createDefaultWalletNotFoundHandler(),\
    }),\
  ],
  []
);

return (
  <ConnectionProvider endpoint={clusterApiUrl(WalletAdapterNetwork.Devnet)}>
    <WalletProvider wallets={wallets}>
      <MyApp />
    </WalletProvider>
  </ConnectionProvider>
);
```

### Browser Compatibility [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#browser-compatibility "Direct link to Browser Compatibility")

Currently, the Mobile Wallet Adapter plugin is tested for compatibility with the Android Chrome browser. Other Android browsers, like the Brave browser on Android, might run into issues when trying to use Mobile Wallet Adapter.

This inconsistency can be due to differences in browser configurations for required permissions like local web socket connections.

## iOS Web [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#ios-web "Direct link to iOS Web")

Mobile Wallet Adapter is not supported on iOS Safari. This is the same with iOS native apps, and is a limitation of the operating system explained more in-depth in this [blog article](https://docs.solanamobile.com/blog/ios-wallet-signing#mobile-wallet-adapter).

### Workarounds [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#workarounds "Direct link to Workarounds")

Besides Mobile Wallet Adapter, there are alternative ways to enable wallet signing for your website directly within an iOS browser.

#### Wallet In App Browser [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#wallet-in-app-browser "Direct link to Wallet In App Browser")

Websites that use `@solana/wallet-adapter` can receive wallet signing if the user is viewing their site within a wallet app's in-app-browser.

#### Safari Web Extension Wallet [​](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web\#safari-web-extension-wallet "Direct link to Safari Web Extension Wallet")

If the user's wallet app supports a Safari Web Extension for signing, they can receive signing directly within the iOS Safari browser. See
this [proof-of-concept repo](https://github.com/solana-mobile/SolanaSafariWalletExtension) for a demo of what this experience looks like.

_Glow Wallet_ and _Nightly Wallet_ have iOS apps that support this Safari Web Extension signing experience.

- [Android Web](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#android-web)
  - [Usage](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#usage)
  - [Customization](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#customization)
  - [Browser Compatibility](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#browser-compatibility)
- [iOS Web](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#ios-web)
  - [Workarounds](https://docs.solanamobile.com/developers/mobile-wallet-adapter-web#workarounds)

## Seed Vault Overview
[Skip to main content](https://docs.solanamobile.com/developers/seed-vault#__docusaurus_skipToContent_fallback)

On this page

The [**Seed Vault**](https://github.com/solana-mobile/seed-vault-sdk) is a system service providing secure key custody to _Wallet apps_. By integrating with secure execution environments available on mobile devices (such as secure operating modes of the processor and/or secure auxiliary coprocessors), Seed Vault helps to keep your secrets safe, by moving them to the highest privileged environment available on the device. Your keys, seeds, and secrets never leave the secure execution environment, while UI components built into Android handle interaction with the user to provide a secure transaction signing experience to users.

### Using the SDK [​](https://docs.solanamobile.com/developers/seed-vault\#using-the-sdk "Direct link to Using the SDK")

#### For dApps [​](https://docs.solanamobile.com/developers/seed-vault\#for-dapps "Direct link to For dApps")

The Seed Vault SDK is designed for usage by _wallet_ apps. If you are building a mobile dApp, you should just use Mobile Wallet Adapter for your usecase.

#### For Wallet Apps [​](https://docs.solanamobile.com/developers/seed-vault\#for-wallet-apps "Direct link to For Wallet Apps")

To integrate and provide Seed Vault custody in a wallet app, follow this [integration guide](https://github.com/solana-mobile/seed-vault-sdk/blob/main/docs/integration_guide.md) for a deep dive into the SDK. The repo includes a Seed vault simulator, which can be used to simulate and test for Seed Vault integration on emulators.

- [Using the SDK](https://docs.solanamobile.com/developers/seed-vault#using-the-sdk)

## Solana Mobile SDK
[Skip to main content](https://docs.solanamobile.com/flutter/overview#__docusaurus_skipToContent_fallback)

On this page

Flutter is an open source mobile app development framework created by Google. It uses the Dart programming language and allows developers to create cross-platform applications for Android and iOS using a single codebase.

## Solana Mobile Flutter SDK [​](https://docs.solanamobile.com/flutter/overview\#solana-mobile-flutter-sdk "Direct link to Solana Mobile Flutter SDK")

The Solana Mobile Flutter SDK is an open source collection of Flutter plugins that brings the core SMS technologies like **Mobile Wallet Adapter** onto Flutter.
It is actively maintained by the [Espresso Cash](https://www.espressocash.com/) team.

[View on GitHub](https://github.com/espresso-cash/espresso-cash-public/tree/master)

note

The Solana Flutter SDK is a community-developed and maintained project and **it is not an official library**.
Please be understanding if certain areas are still under development. Your
contributions are always welcome to help address any issues you may encounter.

Thank you to the [Espresso Cash](https://github.com/espresso-cash/espresso-cash-public/tree/master) team for your
active maintanence of this library!

### [Solana Dart Library](https://pub.dev/packages/solana) [​](https://docs.solanamobile.com/flutter/overview\#solana-dart-library "Direct link to solana-dart-library")

Dart implementation of Solana JSON RPC API client. Provides convenient interface for the RPC methods.

### [Flutter Mobile Wallet Adapter](https://pub.dev/packages/solana_mobile_client) [​](https://docs.solanamobile.com/flutter/overview\#flutter-mobile-wallet-adapter "Direct link to flutter-mobile-wallet-adapter")

Reference implementation of the Mobile Wallet Adapter (Client) specification for Flutter, providing the MWA API (authorization, signing, etc)

## Resources [​](https://docs.solanamobile.com/flutter/overview\#resources "Direct link to Resources")

### [Flutter Example dApp](https://github.com/espresso-cash/espresso-cash-public/tree/master/packages/solana_mobile_client/example) [​](https://docs.solanamobile.com/flutter/overview\#flutter-example-dapp "Direct link to flutter-example-dapp")

An example Flutter app showing how to integrate Mobile Wallet Adapter and connect to wallets, enabling transaction signing and sending.

### [Basic Flutter dApp Tutorial](https://medium.com/@ronak01.raj/a-comphrensive-tutotial-building-dapps-with-flutter-and-solana-mobile-stack-sms-e452356a0adb) [​](https://docs.solanamobile.com/flutter/overview\#basic-flutter-dapp-tutorial "Direct link to basic-flutter-dapp-tutorial")

A community tutorial showing how to use the Solana Dart libraries to build a simple Flutter dApp.

### Community [​](https://docs.solanamobile.com/flutter/overview\#community "Direct link to Community")

Join the community led [Solana Dart Discord](https://discord.gg/Q9aFs3Ydmd) to participate in discussion, ask technical questions, and stay tuned for developments.

- [Solana Mobile Flutter SDK](https://docs.solanamobile.com/flutter/overview#solana-mobile-flutter-sdk)
  - [Solana Dart Library](https://docs.solanamobile.com/flutter/overview#solana-dart-library)
  - [Flutter Mobile Wallet Adapter](https://docs.solanamobile.com/flutter/overview#flutter-mobile-wallet-adapter)
- [Resources](https://docs.solanamobile.com/flutter/overview#resources)
  - [Flutter Example dApp](https://docs.solanamobile.com/flutter/overview#flutter-example-dapp)
  - [Basic Flutter dApp Tutorial](https://docs.solanamobile.com/flutter/overview#basic-flutter-dapp-tutorial)
  - [Community](https://docs.solanamobile.com/flutter/overview#community)

## Chapter 2 Preorder Tokens
[Skip to main content](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#__docusaurus_skipToContent_fallback)

On this page

![Preorder Token](https://docs.solanamobile.com/blog_imgs/chapter2-preorder-token.jpeg)

## Introduction [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#introduction "Direct link to Introduction")

This article provides information about the Solana Mobile Chapter 2 Preorder Tokens NFTs.The non-transferrable Chapter 2 Preorder Tokens allow for the identification of wallets that have participated in supporting Chapter 2.

Solana Mobile does not currently have a rewards program in connection with the Chapter 2 Preorder Token. Ecosystem teams are entirely free to decide if (and if so, how) they wish to interact with the holders of these non-transferable tokens.

## Chapter 2 Preorder Token holders [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#chapter-2-preorder-token-holders "Direct link to Chapter 2 Preorder Token holders")

The Chapter 2 Preorder Token NFT is a non-transferable NFT distributed to the wallets of anyone who has preordered Chapter 2.

As of the time this article was written, there are 140,000+ holders of the Preorder Token. The preorder phase is still active and any new Tokens will be issued in waves.

## NFT Details [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#nft-details "Direct link to NFT Details")

The Chapter 2 Preorder Tokens are non-transferable NFTs enabled by the _[NonTransferable](https://solana.com/developers/guides/token-extensions/non-transferable)_ extension.

### Mint Address [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#mint-address "Direct link to Mint Address")

The Chapter 2 Preorder Token mint address is:

- `2DMMamkkxQ6zDMBtkFp8KH7FoWzBMBA1CGTYwom4QH6Z`

This mint address is shared by all token accounts of the Chapter 2 Preorder Token.

### Metadata [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#metadata "Direct link to Metadata")

Each Chapter 2 Preorder Token NFT utilizes the [Metadata and Metadata Pointer](https://solana.com/developers/guides/token-extensions/metadata-pointer) extension to define
its NFT metadata.

```text
Metadata
    Uri: https://arweave.net/WHyy5Fo8vUC7FqFfzqkuYAmDi-BfOMBjZSXIwwO7P6g
    Mint: 2DMMamkkxQ6zDMBtkFp8KH7FoWzBMBA1CGTYwom4QH6Z
    Name: Chapter 2 Preorder Token
    Symbol: CHAPTER2
    Update Authority: GRR6BquJZYWgUqWpNJekBZHDHgxVQ56iZ2P2nWjDFRSn
    Additional Metadata
Metadata Pointer
    Authority: GRR6BquJZYWgUqWpNJekBZHDHgxVQ56iZ2P2nWjDFRSn
    Metadata Address: 2DMMamkkxQ6zDMBtkFp8KH7FoWzBMBA1CGTYwom4QH6Z
```

## Querying for Chapter 2 Preorder Token holders manually [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#querying-for-chapter-2-preorder-token-holders-manually "Direct link to Querying for Chapter 2 Preorder Token holders manually")

tip

This script can return duplicates of the same owner's wallet address.
This is because it is possible for a single wallet address to own more than one Preorder Token, if they preordered multiple Chapter 2 products.

You can follow these steps to manually query the Chapter 2 Preorder Token list and save it into a JSON file:

### 1\. Access your RPC provider. [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#1-access-your-rpc-provider "Direct link to 1. Access your RPC provider.")

Any RPC provider with the [DAS (Digital Asset Standard)](https://github.com/metaplex-foundation/digital-asset-standard-api) APIs should work. If you don't have one, the Helius Free plan (helius.dev/pricing) should be sufficient for this query.

### 2\. Add your API Key to the following query: [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#2-add-your-api-key-to-the-following-query "Direct link to 2. Add your API Key to the following query:")

```js
import { writeFileSync } from "fs";

const DAS_API_URL = "https://mainnet.helius-rpc.com/?api-key=<API_KEY>";
const TOKEN_MINT_ADDRESS = "2DMMamkkxQ6zDMBtkFp8KH7FoWzBMBA1CGTYwom4QH6Z";
const OUTPUT_FILE = `out.json`;

let tokens = [];

let page = 0;
while (true) {
  page++;
  console.log(`Fetching page ${page}`);
  const response = await fetch(DAS_API_URL, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "my-id",
      method: "getTokenAccounts",
      params: {
        mint: `${TOKEN_MINT_ADDRESS}`,
        page: page, // Starts at 1
        limit: 1000,
      },
    }),
  });
  const { result } = await response.json();
  if (result.total === 0) {
    console.log("Done!");
    break;
  }
  for (const item of result.token_accounts) {
    tokens.push({ owner: item.owner, count: item.amount });
  }
}

console.log(`Writing to ${OUTPUT_FILE}`);
writeFileSync(OUTPUT_FILE, JSON.stringify(tokens, null, 2));
```

### 3\. Perform the Query [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#3-perform-the-query "Direct link to 3. Perform the Query")

Run the script to perform the query and you can find the results in the output file `out.json`.

### 4\. Further querying (optional) [​](https://docs.solanamobile.com/getting-started/chapter2-preorder-token\#4-further-querying-optional "Direct link to 4. Further querying (optional)")

In order to query a subset of the Preorder Token Holders, you may write a script to fetch wallet activity data using blockchain explorers and analytics tools based on the subset criteria. You can use their APIs to retrieve transaction history, token balances, and other relevant information, such as:

- Length of their engagement with the applicable protocol (i.e. The date of the first transaction)
- Participation in applications within the ecosystem that are adjacent or complementary to your project

- [Introduction](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#introduction)
- [Chapter 2 Preorder Token holders](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#chapter-2-preorder-token-holders)
- [NFT Details](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#nft-details)
  - [Mint Address](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#mint-address)
  - [Metadata](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#metadata)
- [Querying for Chapter 2 Preorder Token holders manually](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#querying-for-chapter-2-preorder-token-holders-manually)
  - [1\. Access your RPC provider.](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#1-access-your-rpc-provider)
  - [2\. Add your API Key to the following query:](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#2-add-your-api-key-to-the-following-query)
  - [3\. Perform the Query](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#3-perform-the-query)
  - [4\. Further querying (optional)](https://docs.solanamobile.com/getting-started/chapter2-preorder-token#4-further-querying-optional)

## Solana Mobile Documentation
[Skip to main content](https://docs.solanamobile.com/getting-started/intro#__docusaurus_skipToContent_fallback)

On this page

Welcome to the **Solana Mobile Documentation** site!

The documentation site serves as a comprehensive knowledge center for developers that want to build with the **Solana Mobile Stack (SMS)**.

Here, you can find an excellent collection of guides, tutorials, and references aimed at assisting developers as they build Web3 mobile dApps.
In addition, there are also resources for developers wanting to publish on the [Solana dApp Store](https://docs.solanamobile.com/dapp-publishing/intro).

These resources are actively maintained by the [Solana Mobile](https://github.com/solana-mobile) team, but welcomes [contributions from the community](https://github.com/solana-mobile/solana-mobile-doc-site)!

note

You don't need a Solana Mobile device or physical device to start developing. The stack is compatible with any Android device. See [**prerequisite setup**](https://docs.solanamobile.com/getting-started/development-setup) to set up your development environment and start building!

## Quickstart [​](https://docs.solanamobile.com/getting-started/intro\#quickstart "Direct link to Quickstart")

Learn how to develop Solana Mobile dApps in your preferred programming language.

[_![](https://docs.solanamobile.com/img/react-native-96.svg)_ **React Native**\\
\\
Learn about the React Native SDKs and how to quickly start building on Solana Mobile.](https://docs.solanamobile.com/react-native/overview)

[_![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)_ **Kotlin**\\
\\
Learn how to build a native Android app using the core Solana Kotlin SDKs.](https://docs.solanamobile.com/android-native/overview)

[_![](https://docs.solanamobile.com/img/pwa-icon.png)_ **Progressive Web Apps (PWAs)**\\
\\
Learn how to convert a PWA to an Android app and publish on the dApp Store.](https://docs.solanamobile.com/dapp-publishing/publishing-a-pwa)

[_![](https://docs.solanamobile.com/img/bookshelf-circle-icon.png)_ **Sample Apps**\\
\\
Reference our collection of sample apps that use the Solana Mobile Stack.](https://docs.solanamobile.com/sample-apps/sample_app_overview)

## Learn about Solana Mobile [​](https://docs.solanamobile.com/getting-started/intro\#learn-about-solana-mobile "Direct link to Learn about Solana Mobile")

Learn about the Solana dApp Store or explore the libraries within the Solana Mobile SDK.

[📱\\
\\
**dApp Store**\\
\\
Learn about the dApp Store and how to publish your app.](https://docs.solanamobile.com/dapp-publishing/intro)

[_![](https://docs.solanamobile.com/img/solana-mobile-stack-logo.png)_ **SDK Overview**\\
\\
Learn about the different libraries and tools provided by the Solana Mobile Stack.](https://docs.solanamobile.com/getting-started/overview)

- [Quickstart](https://docs.solanamobile.com/getting-started/intro#quickstart)
- [Learn about Solana Mobile](https://docs.solanamobile.com/getting-started/intro#learn-about-solana-mobile)

## Overview of Solana
[Skip to main content](https://docs.solanamobile.com/getting-started/introduction-to-solana#__docusaurus_skipToContent_fallback)

On this page

## What is Solana? [​](https://docs.solanamobile.com/getting-started/introduction-to-solana\#what-is-solana "Direct link to What is Solana?")

Solana is a blockchain built for mass adoption. It's a high performance network that is utilized for a range of use cases,
including finance, NFTs, payments, and gaming. Solana operates as a single global state machine, and is open, interoperable and decentralized.

The Solana Mobile Documentation Site provides resources for the development of the **mobile ecosystem** of Solana.

## Learning resources [​](https://docs.solanamobile.com/getting-started/introduction-to-solana\#learning-resources "Direct link to Learning resources")

### Core concepts [​](https://docs.solanamobile.com/getting-started/introduction-to-solana\#core-concepts "Direct link to Core concepts")

To learn more about Solana's core concepts see the [Solana Docs](https://docs.solana.com/). These are official docs
about fundmental concepts about Solana like network architecture, Solana _accounts_, _transactions_, and on-chain programs.

### Solana Development Resources [​](https://docs.solanamobile.com/getting-started/introduction-to-solana\#solana-development-resources "Direct link to Solana Development Resources")

**[Solana Developer Docs](https://docs.solana.com/developers)**: High level documentation geared towards general Solana development.

**[Solana Cookbook](https://solanacookbook.com/#contributing)**: A developer resource for essential concepts, code snippets, and references for Solana dApps.

**[Solana Playground](https://beta.solpg.io/)**: An online Solana On-chain program editor with integrated beginner tutorials.

**[SolDev](https://www.soldev.app/course)**: High quality tutorials explaining Solana On-chain and Web programming from scratch.

- [What is Solana?](https://docs.solanamobile.com/getting-started/introduction-to-solana#what-is-solana)
- [Learning resources](https://docs.solanamobile.com/getting-started/introduction-to-solana#learning-resources)
  - [Core concepts](https://docs.solanamobile.com/getting-started/introduction-to-solana#core-concepts)
  - [Solana Development Resources](https://docs.solanamobile.com/getting-started/introduction-to-solana#solana-development-resources)

## Mobile dApp Architecture
[Skip to main content](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#__docusaurus_skipToContent_fallback)

On this page

This reference aims to give a conceptual overview of the architecture of a mobile dApp using the Solana Mobile Stack.

## High Level [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#high-level "Direct link to High Level")

The following diagram shows a bird's eye view of a mobile dApp's interactions with mobile wallets and the Solana network.

![Full Architecture Diagram](https://docs.solanamobile.com/diagrams/dapp_architecture_full.svg)

## Mobile Wallet Adapter Protocol [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#mobile-wallet-adapter-protocol "Direct link to Mobile Wallet Adapter Protocol")

The \*\*Mobile Wallet Adapter (MWA) \*\* protocol is what defines the communication exchange between a dApp and a mobile wallet.
In the protocol, the dApp sends requests (i.e: authorization or signing), while the wallet is responsible for displaying
these requests to the user and responding back to the dApp if approved.

For an extensive, deep dive into the specifics of the protocol and MWA methods, refer to the [MWA spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html).

### Session Establishment [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#session-establishment "Direct link to Session Establishment")

To begin the protocol, a dApp initiates first contact with a mobile wallet and establishes an **MWA session**.
With the current SDKs, the MWA session is initiated through Android intents, with the dApp broadcasting an intent
with the `solana-wallet://` scheme.

![Session Establishment Diagram](https://docs.solanamobile.com/diagrams/session_establishment.svg)

A wallet then receives the intent and starts a websocket connection, thus establishing a channel for commmunication.

### Example: Authorize and Sign Transaction [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#example-authorize-and-sign-transaction "Direct link to Example: Authorize and Sign Transaction")

Once a session is established, the dApp can now begin sending MWA Requests to receive signed transactions from the wallet.
This example case outlines an MWA session where the dApp:

1. Establishes a session with a wallet.
2. Requests authorization, elevating the session to an "authorized state" and receiving a list of authorized accounts and an authToken.
3. Requests transaction signing, receiving a transaction signed by the authorized accounts.

![Authorize and Sign Diagram](https://docs.solanamobile.com/diagrams/authorize_and_sign.svg)

In future sessions, the dApp can initiate with the valid authToken to immediately elevate to an "authorizd state", skipping the "connect" step.

While the protocol technically supports multiple accounts, most wallet apps only implement a single account authorization per session.

For a more detailed diagram that shows the full communication exchange, refer to this [section in the spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#authorize-and-sign-transaction).

## Submitting to the Solana network [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#submitting-to-the-solana-network "Direct link to Submitting to the Solana network")

Just like web dApps, the process for a mobile dApp submitting transactions to the blockchain network is the same. The dApp specifies
a cluster and an RPC endpoint then sends the transaction payload, following the [JSON RPC API](https://docs.solana.com/api).

For certain usecases, the dApp may choose to communicate with the RPC through the [Websocket API](https://docs.solana.com/api/websocket)

![Submit to RPC Diagram](https://docs.solanamobile.com/diagrams/submit_rpc.svg)

### Sign and Send Transaction [​](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture\#sign-and-send-transaction "Direct link to Sign and Send Transaction")

For submitting transactions, it is encouraged for the dApp to send a `sign_and_send_transaction` MWA request to the wallet. This request
type sends a unsigned transaction to the wallet. If authorized, the wallet will then sign the transaction and send it to the network with its
own implementation. Depending on the wallet app, this can include applying its own priority fee.

Relying on the wallet reduces the risk of replay attacks with [durable nonce based transactions](https://docs.solana.com/implemented-proposals/durable-tx-nonces), which can be abused with `sign_transactions`.

![Sign and Send Diagram](https://docs.solanamobile.com/diagrams/sign_and_send.svg)

- [High Level](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#high-level)
- [Mobile Wallet Adapter Protocol](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#mobile-wallet-adapter-protocol)
  - [Session Establishment](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#session-establishment)
  - [Example: Authorize and Sign Transaction](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#example-authorize-and-sign-transaction)
- [Submitting to the Solana network](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#submitting-to-the-solana-network)
  - [Sign and Send Transaction](https://docs.solanamobile.com/getting-started/mobile-dapp-architecture#sign-and-send-transaction)

## Solana Mobile Overview
[Skip to main content](https://docs.solanamobile.com/getting-started/overview#__docusaurus_skipToContent_fallback)

On this page

## What's in the Solana Mobile Stack? [​](https://docs.solanamobile.com/getting-started/overview\#whats-in-the-solana-mobile-stack "Direct link to What's in the Solana Mobile Stack?")

The **Solana Mobile Stack (SMS)** is a collection of key technologies for building mobile applications that can interact with the Solana blockchain.

Read on to learn about the core technologies of the stack and how each fit into the web3 mobile landscape.

## Mobile Wallet Adapter [​](https://docs.solanamobile.com/getting-started/overview\#mobile-wallet-adapter "Direct link to Mobile Wallet Adapter")

[**Mobile Wallet Adapter (MWA)**](https://github.com/solana-mobile/mobile-wallet-adapter) is a protocol specification for connecting mobile dApps to mobile Wallet Apps,
enabling communication for Solana transaction and message signing.

dApps that implement MWA are able to connect to [any compatible MWA Wallet App](https://solanamobile.com/wallets) and request authorization, signing, and sending for transactions/messges.

**Why this is important**: Developers no longer need to build in support for each individual wallet, and instead can just integrate once and use a single unified API to be compatible with every compliant Solana wallet!

### Supported Platforms [​](https://docs.solanamobile.com/getting-started/overview\#supported-platforms "Direct link to Supported Platforms")

| Mobile Platform | Is MWA Supported? | Notes |
| --- | --- | --- |
| Android | ✅ | Full support for dApps and Wallet apps. |
| Mobile Web - Chrome (Android) | ✅ | Automatic integration if using `@solana/wallet-adapter-react`. |
| iOS | ❌ | MWA is not currently available for any iOS platform (app or browser). |
| Mobile Web - Safari, Firefox, Opera, Brave | ❌ | These browsers currently do not support MWA on Android (or iOS). |

### Using the SDK [​](https://docs.solanamobile.com/getting-started/overview\#using-the-sdk "Direct link to Using the SDK")

Solana Mobile maintains an official [Mobile Wallet Adapter SDK](https://github.com/solana-mobile/mobile-wallet-adapter) that implements the protocol, originally written as a Android Kotlin/Java library.

The SDK is also ported other frameworks and is available for:

- React Native
- Flutter
- Unity
- Unreal Engine

Explore the _Development_ section of the site to learn how to integrate the MWA SDK into the framework of your choice.

### Deep dive learning [​](https://docs.solanamobile.com/getting-started/overview\#deep-dive-learning "Direct link to Deep dive learning")

Fundamentally, MWA is a generic protocol specification for connecting dApps to Wallets. The protocol is not limited to Android devices either; it envisions similar support for iOS devices, as well as the capability of Wallet apps to provide signing services to applications running remotely, such as on other mobile devices, and on desktop or laptop computers.

If interested, you can deep dive into the protocol [specification](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html).

### Wallet Apps [​](https://docs.solanamobile.com/getting-started/overview\#wallet-apps "Direct link to Wallet Apps")

If you're developing a MWA-compatible wallet app, see the [`walletlib`](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/android/walletlib) Android Library that implements the wallet side of the MWA protocol. Most of the resources on this website are geared towards dApp developers, rather than Wallet developers, so if you have more questions, get in touch with the team directly for support on [Discord](https://discord.com/invite/solanamobile).

### Migrating to MWA 2.0 [​](https://docs.solanamobile.com/getting-started/overview\#migrating-to-mwa-20 "Direct link to Migrating to MWA 2.0")

Check out the [2.0 migration guide](https://docs.solanamobile.com/mwa/migration/overview) to migrate from 1.x vresion of Mobile Wallet Adapter to the latest version.

## Seed Vault [​](https://docs.solanamobile.com/getting-started/overview\#seed-vault "Direct link to Seed Vault")

The [**Seed Vault**](https://github.com/solana-mobile/seed-vault-sdk) is a system service providing secure key custody to _Wallet apps_. By integrating with secure execution environments available on mobile devices (such as secure operating modes of the processor and/or secure auxiliary coprocessors), Seed Vault helps to keep your secrets safe, by moving them to the highest privileged environment available on the device. Your keys, seeds, and secrets never leave the secure execution environment, while UI components built into Android handle interaction with the user to provide a secure transaction signing experience to users.

### Using the SDK [​](https://docs.solanamobile.com/getting-started/overview\#using-the-sdk-1 "Direct link to Using the SDK")

#### For dApps [​](https://docs.solanamobile.com/getting-started/overview\#for-dapps "Direct link to For dApps")

The Seed Vault SDK is designed for usage by _wallet_ apps. If you are building a mobile dApp, you should just use Mobile Wallet Adapter for your usecase.

#### For Wallet Apps [​](https://docs.solanamobile.com/getting-started/overview\#for-wallet-apps "Direct link to For Wallet Apps")

To integrate and provide Seed Vault custody in a wallet app, follow this [integration guide](https://github.com/solana-mobile/seed-vault-sdk/blob/main/docs/integration_guide.md) for a deep dive into the SDK. The repo includes a Seed vault simulator, which can be used to simulate and test for Seed Vault integration on emulators.

## Solana dApp Store [​](https://docs.solanamobile.com/getting-started/overview\#solana-dapp-store "Direct link to Solana dApp Store")

The [**Solana dApp Store**](https://github.com/solana-mobile/dapp-publishing#welcome-publishers) is an alternate app distribution system, well suited to distributing apps developed by the Solana ecosystem.

It will provide a distribution channel for apps that want to establish direct relationships with their customers, without other app stores’ rules restricting the relationship or seeking a large revenue share. The goal of the Solana dApp Store is to empower the Solana community to eventually play a key role in managing the contents of this app store.

If you are interested in submitting your app to the Solana dApp Store, follow our [publishing guide](https://github.com/solana-mobile/dapp-publishing/blob/main/README.md#welcome-publishers) to learn about our publishing process.

## Other SDKs [​](https://docs.solanamobile.com/getting-started/overview\#other-sdks "Direct link to Other SDKs")

### Solana Pay for Android [​](https://docs.solanamobile.com/getting-started/overview\#solana-pay-for-android "Direct link to Solana Pay for Android")

The [**Solana Pay protocol**](https://docs.solanapay.com/) was developed independently of the Solana Mobile Stack, but combining payments with a mobile device is a natural fit for Solana Pay.

To assist developers in integrating Solana Pay, we’ve developed a [**reference implementation**](https://github.com/solana-mobile/solana-pay-android-sample) demonstrating how Wallet apps can use the system features of Android devices to capture Solana Pay URLs via QR codes, NFC taps, messages, and web browser interactions to launch Solana Pay requests.

## Development community [​](https://docs.solanamobile.com/getting-started/overview\#development-community "Direct link to Development community")

#### Discord [​](https://docs.solanamobile.com/getting-started/overview\#discord "Direct link to Discord")

Currently, most technical discussion around the Solana Mobile Stack happens in our offical [Solana Mobile Discord](https://discord.gg/solanamobile).
If you have any questions, are interested in contributing, or want to get in touch with the development community, come join and send a message!

#### Twitter [​](https://docs.solanamobile.com/getting-started/overview\#twitter "Direct link to Twitter")

On Twitter, you can follow [@SolanaMobile](https://twitter.com/solanamobile).

- [What's in the Solana Mobile Stack?](https://docs.solanamobile.com/getting-started/overview#whats-in-the-solana-mobile-stack)
- [Mobile Wallet Adapter](https://docs.solanamobile.com/getting-started/overview#mobile-wallet-adapter)
  - [Supported Platforms](https://docs.solanamobile.com/getting-started/overview#supported-platforms)
  - [Using the SDK](https://docs.solanamobile.com/getting-started/overview#using-the-sdk)
  - [Deep dive learning](https://docs.solanamobile.com/getting-started/overview#deep-dive-learning)
  - [Wallet Apps](https://docs.solanamobile.com/getting-started/overview#wallet-apps)
  - [Migrating to MWA 2.0](https://docs.solanamobile.com/getting-started/overview#migrating-to-mwa-20)
- [Seed Vault](https://docs.solanamobile.com/getting-started/overview#seed-vault)
  - [Using the SDK](https://docs.solanamobile.com/getting-started/overview#using-the-sdk-1)
- [Solana dApp Store](https://docs.solanamobile.com/getting-started/overview#solana-dapp-store)
- [Other SDKs](https://docs.solanamobile.com/getting-started/overview#other-sdks)
  - [Solana Pay for Android](https://docs.solanamobile.com/getting-started/overview#solana-pay-for-android)
- [Development community](https://docs.solanamobile.com/getting-started/overview#development-community)

## Saga Genesis Token Overview
[Skip to main content](https://docs.solanamobile.com/getting-started/saga-genesis-token#__docusaurus_skipToContent_fallback)

On this page

## Introduction [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#introduction "Direct link to Introduction")

The Saga Genesis Token is a unique, non-transferable NFT that represents a verified owner of a Saga device.
It is minted only once per device through the dApp Store after initial device setup.

## NFT Details [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#nft-details "Direct link to NFT Details")

The Saga Genesis Token NFT adheres to the Metaplex [Token Standard](https://developers.metaplex.com/token-metadata/token-standard) and is part of a [Verified Collection](https://developers.metaplex.com/token-metadata/collections).

### Soulbound NFT [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#soulbound-nft "Direct link to Soulbound NFT")

Every Saga Genesis Token is a Soulbound NFT that is non-transferable from the wallet that it was minted to.

Although likely, this does not mean that every Genesis Token user is interacting from a Saga device. This is because the user's wallet (more specifically, secret key) can be exported/imported from/into the device.

### Collection NFT address [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#collection-nft-address "Direct link to Collection NFT address")

The Saga Genesis Token Collection NFT address is `46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC`. Each Saga Genesis Token NFT metadata will
have a `collection` field with this address, along with the `verified` flag set to `true`.

To better understand how Collection NFTs verify a normal NFT, read the official Metaplex [documentation](https://docs.metaplex.com/programs/token-metadata/certified-collections#collection-nfts).

### View on an explorer [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#view-on-an-explorer "Direct link to View on an explorer")

You can view a real Saga Genesis Token on-chain with an explorer by querying an [individual NFT mint address](https://solscan.io/token/DMcJLbYGT9UAiYXMoHMjsoLCW1MRJ12YDnU967pAvByg) or filtering by
[collection NFT address](https://solscan.io/collection/4a2d96b22ab0c8f01cb5ce5bc960b627c2a8271529ae5132d5352b7c86b3b54d).

## Verify a Saga Genesis Token holder [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#verify-a-saga-genesis-token-holder "Direct link to Verify a Saga Genesis Token holder")

For certain use cases, like rewards claiming or token gated content for Saga users, you will need to verify ownership of the Saga Genesis Token NFT.

### Verifying individual ownership [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#verifying-individual-ownership "Direct link to Verifying individual ownership")

For token gated content and rewards, the user can explicitly claim their Saga Genesis Token reward. The user should prove
ownership of a Saga Genesis Token and only then should they receive the rewards/content.

#### Sign in with Solana [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#sign-in-with-solana "Direct link to Sign in with Solana")

To receive token gated content and rewards, a user first needs to prove that they own a Saga Genesis Token.
You should use _Sign in with Solana_ to verify that the connecting user truly owns the wallet that contains the Saga Genesis Token.

If you are implementing this flow on web, you can use the standard Solana web libraries like `wallet-adapter-react`, following
this [integration guide](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#dapp-integration).

If you are implementing this flow within a mobile app, you will need to manually implement SIWS using [Mobile Wallet\\
Adapter](https://docs.solanamobile.com/react-native/quickstart#signing-messages) (`authorize` \+ `signMessage`).

#### Verify the Saga Genesis Token [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#verify-the-saga-genesis-token "Direct link to Verify the Saga Genesis Token")

After proving that the user owns the wallet, you need to verify that the user's wallet actually contains a Saga Genesis Token. There are different ways to do this, but the simplest is to query an RPC provider that supports the [_DAS (Digital Asset Standards)_ API](https://github.com/metaplex-foundation/digital-asset-standard-api).

Given the user's wallet address you can use the _searchAssets_ DAS API method to check ownership of a Saga Genesis Token NFT.

- Javascript

```javascript
const url = `https://your.rpc.com/?api-key=<api_key>`;

const searchAssets = async () => {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "my-id",
      method: "searchAssets",
      params: {
        ownerAddress: "<user-wallet-address>", // user's wallet address
        grouping: [\
          "collection",\
          "46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC", // Genesis Token Collection NFT Address\
        ],
        page: 1, // Starts at 1
        limit: 1000,
      },
    }),
  });
  const { result } = await response.json();
  if (result?.total === 1) {
    console.log("Wallet contains a Saga Genesis Token!");
  } else {
    console.log("Wallet does not contain a Saga Genesis Token.");
  }
};
searchAssets();
```

The above is a modification of the example from the [Helius DAS API documentation](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api/search-assets).

## Fetching a mint list of holders [​](https://docs.solanamobile.com/getting-started/saga-genesis-token\#fetching-a-mint-list-of-holders "Direct link to Fetching a mint list of holders")

For use cases like snapshots and airdropping, you can query for the entire list of current holders.

To fetch the entire collection list of Saga Genesis Token holders, you can use the `getAssetsByGroup` DAS API method. In the following example,
the paginated response is a list of Saga Genesis Token Assets and metadata.

- Javascript

```javascript
const url = "https://your.rpc.com/?api-key=<api-key>";

const getAssetsByGroup = async () => {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "my-id",
      method: "getAssetsByGroup",
      params: {
        groupKey: "collection",
        groupValue: "46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC", // Genesis Token Collection NFT Address
        page: 1, // Starts at 1
        limit: 1000,
      },
    }),
  });
  const { result } = await response.json();
  console.log("Page 1 of Saga Genesis Token Assets: ", result.items);
};
getAssetsByGroup();
```

The above is a modification of the example from the [Helius DAS API documentation](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api/get-assets-by-group).

Alternatively, there are many [third-party/community created tools](https://docs.metaplex.com/guides/mint-lists) to generate a mint list.

- [Introduction](https://docs.solanamobile.com/getting-started/saga-genesis-token#introduction)
- [NFT Details](https://docs.solanamobile.com/getting-started/saga-genesis-token#nft-details)
  - [Soulbound NFT](https://docs.solanamobile.com/getting-started/saga-genesis-token#soulbound-nft)
  - [Collection NFT address](https://docs.solanamobile.com/getting-started/saga-genesis-token#collection-nft-address)
  - [View on an explorer](https://docs.solanamobile.com/getting-started/saga-genesis-token#view-on-an-explorer)
- [Verify a Saga Genesis Token holder](https://docs.solanamobile.com/getting-started/saga-genesis-token#verify-a-saga-genesis-token-holder)
  - [Verifying individual ownership](https://docs.solanamobile.com/getting-started/saga-genesis-token#verifying-individual-ownership)
- [Fetching a mint list of holders](https://docs.solanamobile.com/getting-started/saga-genesis-token#fetching-a-mint-list-of-holders)

## Web3 Mobile Development
[Skip to main content](https://docs.solanamobile.com/getting-started/web3-and-mobile#__docusaurus_skipToContent_fallback)

On this page

Before development, its important to understand the current landscape of Web3 mobile development to foresee potential blockers and opportunities.

## Mobile Platforms 📱 [​](https://docs.solanamobile.com/getting-started/web3-and-mobile\#mobile-platforms- "Direct link to Mobile Platforms 📱")

**Android** 🤖

Android is currently the best supported platform for Solana Mobile development. The Solana Mobile SDKs (namely Mobile Wallet Adapter) are all natively implemented and available in Android. The majority of the resources in this website are for Android development.

In addition to this, the Google Play Store has less restrictive policies with regards to Crypto/Web3 dApps compared to the Apple App Store.

For Android development, Solana Mobile SDKs available for **Kotlin, React Native, and Flutter**. See our _SDK_ section for more details on each.

**iOS** 🍎

There are several blockers for developing Solana mobile apps on iOS. First, the Mobile Wallet Adapter protocol is not supported on iOS due to technical limitations of the operating system. In addition to this, the Apple App Store has a more restrictive policy against web3/crypto apps.

For now, the current recommendation for iOS is to create a mobile web app, that is — a web app designed/optimized for mobile browsers. More on this below.

## **Mobile Web** 🌐 [​](https://docs.solanamobile.com/getting-started/web3-and-mobile\#mobile-web- "Direct link to mobile-web-")

Although our recommendation is to always create a native mobile app for the best user experience, this is not always possible like on iOS. An alternative option to developing a native mobile app is to create a web app optimized for a mobile browser experience.

**Browser Compatibility**

- Android Chrome ✅
  - Supports MWA automatically if using the [`wallet-adapter-react`](https://github.com/solana-labs/wallet-adapter) library.
- iOS Safari 🟨
  - Does not support MWA due to iOS limitations.
  - Wallet signing only possible if user has a Safari Extension wallet, like [Glow Wallet](https://glow.app/).
- Firefox, Opera, Brave, Other ❌
  - Does not support MWA on either iOS or Android.
- Wallet In-App-Browsers
  - Mobile wallets like Phantom, Solflare, and Ultimate, also provide an option to load a web dApp through an in-app-browser.
  - In-App-Browsers have wallet signing capabilities at the cost of being restricted within the wallet app.

- [Mobile Platforms 📱](https://docs.solanamobile.com/getting-started/web3-and-mobile#mobile-platforms-)
- [**Mobile Web** 🌐](https://docs.solanamobile.com/getting-started/web3-and-mobile#mobile-web-)

## Solana Mobile Co-marketing
[Skip to main content](https://docs.solanamobile.com/marketing/comarketing-guidelines#__docusaurus_skipToContent_fallback)

On this page

Solana Mobile may provide co-marketing support to dApp publishers or ecosystem teams that are looking to engage with the Solana Mobile community. Typically, this support is provided through engagement on social media.

## Types of Marketing Content [​](https://docs.solanamobile.com/marketing/comarketing-guidelines\#types-of-marketing-content "Direct link to Types of Marketing Content")

These are examples of the different types of content we have engaged with from the Solana Mobile X account:

- dApp Store announcements and listing teases.
- Community activations for Saga/Seeker holders (e.g. game nights, Solana Mobile community specific events).
- Exclusive programs for Saga/Seeker holders like rewards, discounts and incentives.

If you are interested in reaching the Solana Mobile community with similar content, here are some best practices for the co-marketing process.

## Best Practices for Co-marketing [​](https://docs.solanamobile.com/marketing/comarketing-guidelines\#best-practices-for-co-marketing "Direct link to Best Practices for Co-marketing")

These are the best practices to plan out a co-marketing campaign for the Solana Mobile community.

### 1\. Understand Solana Mobile's Goals [​](https://docs.solanamobile.com/marketing/comarketing-guidelines\#1-understand-solana-mobiles-goals "Direct link to 1. Understand Solana Mobile's Goals")

Solana Mobile's goal is to engage with content from ecosystem partners that is focused on decentralized Apps and exclusive programs and activations for the Solana Mobile community. Extraneous marketing, such as a focus on non-product related economics, is not aligned with Solana Mobile's goals. For best practices, it is encouraged to have ecosystem partners/collaborators share their copy for review before posting.

### 2\. Prepare and share your content copy [​](https://docs.solanamobile.com/marketing/comarketing-guidelines\#2-prepare-and-share-your-content-copy "Direct link to 2. Prepare and share your content copy")

It is encouraged that ecosystem partners/collaborators share copy for review before posting.
After you have drafted and prepared your content, we strongly encourage every team to share their announcement copy/draft with us before posting on X or other socials. This will allow our team to review and ensure timely engagement from the Solana Mobile X account.

### 3\. Coordinate engagement [​](https://docs.solanamobile.com/marketing/comarketing-guidelines\#3-coordinate-engagement "Direct link to 3. Coordinate engagement")

After content approval, you can request times to commence the announcement and engagement from the Solana Mobile X account.

If you are launching a dApp or releasing a new update, you can request a specific time for your app to go live, to align with marketing efforts.

- [Types of Marketing Content](https://docs.solanamobile.com/marketing/comarketing-guidelines#types-of-marketing-content)
- [Best Practices for Co-marketing](https://docs.solanamobile.com/marketing/comarketing-guidelines#best-practices-for-co-marketing)
  - [1\. Understand Solana Mobile's Goals](https://docs.solanamobile.com/marketing/comarketing-guidelines#1-understand-solana-mobiles-goals)
  - [2\. Prepare and share your content copy](https://docs.solanamobile.com/marketing/comarketing-guidelines#2-prepare-and-share-your-content-copy)
  - [3\. Coordinate engagement](https://docs.solanamobile.com/marketing/comarketing-guidelines#3-coordinate-engagement)

## Engaging Saga Users
[Skip to main content](https://docs.solanamobile.com/marketing/engaging-saga-users#__docusaurus_skipToContent_fallback)

On this page

## Introduction [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#introduction "Direct link to Introduction")

The Saga Genesis Token is a unique, non-transferable NFT that represents a verified owner of a Saga device.
It is minted only once per device through the dApp Store after initial device setup.

## NFT Details [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#nft-details "Direct link to NFT Details")

The Saga Genesis Token NFT adheres to the Metaplex [Token Standard](https://developers.metaplex.com/token-metadata/token-standard) and is part of a [Verified Collection](https://developers.metaplex.com/token-metadata/collections).

### Soulbound NFT [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#soulbound-nft "Direct link to Soulbound NFT")

Every Saga Genesis Token is a Soulbound NFT that is non-transferable from the wallet that it was minted to.

Although likely, this does not mean that every Genesis Token user is interacting from a Saga device. This is because the user's wallet (more specifically, secret key) can be exported/imported from/into the device.

### Collection NFT address [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#collection-nft-address "Direct link to Collection NFT address")

The Saga Genesis Token Collection NFT address is `46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC`. Each Saga Genesis Token NFT metadata will
have a `collection` field with this address, along with the `verified` flag set to `true`.

To better understand how Collection NFTs verify a normal NFT, read the official Metaplex [documentation](https://docs.metaplex.com/programs/token-metadata/certified-collections#collection-nfts).

### View on an explorer [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#view-on-an-explorer "Direct link to View on an explorer")

You can view a real Saga Genesis Token on-chain with an explorer by querying an [individual NFT mint address](https://solscan.io/token/DMcJLbYGT9UAiYXMoHMjsoLCW1MRJ12YDnU967pAvByg) or filtering by
[collection NFT address](https://solscan.io/collection/4a2d96b22ab0c8f01cb5ce5bc960b627c2a8271529ae5132d5352b7c86b3b54d).

## Verify a Saga Genesis Token holder [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#verify-a-saga-genesis-token-holder "Direct link to Verify a Saga Genesis Token holder")

For certain use cases, like rewards claiming or token gated content for Saga users, you will need to verify ownership of the Saga Genesis Token NFT.

### Verifying individual ownership [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#verifying-individual-ownership "Direct link to Verifying individual ownership")

For token gated content and rewards, the user can explicitly claim their Saga Genesis Token reward. The user should prove
ownership of a Saga Genesis Token and only then should they receive the rewards/content.

#### Sign in with Solana [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#sign-in-with-solana "Direct link to Sign in with Solana")

To receive token gated content and rewards, a user first needs to prove that they own a Saga Genesis Token.
You should use _Sign in with Solana_ to verify that the connecting user truly owns the wallet that contains the Saga Genesis Token.

If you are implementing this flow on web, you can use the standard Solana web libraries like `wallet-adapter-react`, following
this [integration guide](https://github.com/phantom/sign-in-with-solana?tab=readme-ov-file#dapp-integration).

If you are implementing this flow within a mobile app, you will need to manually implement SIWS using [Mobile Wallet\\
Adapter](https://docs.solanamobile.com/react-native/quickstart#signing-messages) (`authorize` \+ `signMessage`).

#### Verify the Saga Genesis Token [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#verify-the-saga-genesis-token "Direct link to Verify the Saga Genesis Token")

After proving that the user owns the wallet, you need to verify that the user's wallet actually contains a Saga Genesis Token. There are different ways to do this, but the simplest is to query an RPC provider that supports the [_DAS (Digital Asset Standards)_ API](https://github.com/metaplex-foundation/digital-asset-standard-api).

Given the user's wallet address you can use the _searchAssets_ DAS API method to check ownership of a Saga Genesis Token NFT.

- Javascript

```javascript
const url = `https://your.rpc.com/?api-key=<api_key>`;

const searchAssets = async () => {
  const response = await fetch(url, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      jsonrpc: "2.0",
      id: "my-id",
      method: "searchAssets",
      params: {
        ownerAddress: "<user-wallet-address>", // user's wallet address
        grouping: [\
          "collection",\
          "46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC", // Genesis Token Collection NFT Address\
        ],
        page: 1, // Starts at 1
        limit: 1000,
      },
    }),
  });
  const { result } = await response.json();
  if (result?.total === 1) {
    console.log("Wallet contains a Saga Genesis Token!");
  } else {
    console.log("Wallet does not contain a Saga Genesis Token.");
  }
};
searchAssets();
```

The above is a modification of the example from the [Helius DAS API documentation](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api/search-assets).

## Fetching a mint list of holders [​](https://docs.solanamobile.com/marketing/engaging-saga-users\#fetching-a-mint-list-of-holders "Direct link to Fetching a mint list of holders")

For use cases like snapshots and airdropping, you can query for the entire list of current holders.

To fetch the entire collection list of Saga Genesis Token holders, you can use the `getAssetsByGroup` DAS API method. In the following example,
the paginated response is a list of Saga Genesis Token Assets and metadata.

- Javascript

```javascript
const fs = require('fs');
const DAS_API_URL = "https://your.rpc.com/?api-key=<api-key>";
const OUTPUT_FILE = `out.json`;

const getAssetsByGroup = async () => {
  let output = []
  let page = 0;

  while (true) {
    page++;
    const response = await fetch(DAS_API_URL, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        jsonrpc: "2.0",
        id: "my-id",
        method: "getAssetsByGroup",
        params: {
          groupKey: "collection",
          groupValue: "46pcSL5gmjBrPqGKFaLbbCmR6iVuLJbnQy13hAe7s6CC", // Genesis Token Collection NFT Address
          page: page, // Starts at 1
          limit: 1000,
        },
      }),
    });
    const { result } = await response.json();
    console.log(`Page ${page} of Saga Genesis Token Assets`);
    if (result.total === 0) {
      console.log("Done!");
      break;
    }
    for (const item of result.items) {
      output.push({owner: item.ownership.owner})
    }
  }

  console.log(`Writing to ${OUTPUT_FILE}`);
  fs.writeFileSync(OUTPUT_FILE, JSON.stringify(output, null, 2));
};
getAssetsByGroup();
```

The above is a modification of the example from the [Helius DAS API documentation](https://docs.helius.dev/compression-and-das-api/digital-asset-standard-das-api/get-assets-by-group).

Alternatively, there are many [third-party/community created tools](https://docs.metaplex.com/guides/mint-lists) to generate a mint list.

- [Introduction](https://docs.solanamobile.com/marketing/engaging-saga-users#introduction)
- [NFT Details](https://docs.solanamobile.com/marketing/engaging-saga-users#nft-details)
  - [Soulbound NFT](https://docs.solanamobile.com/marketing/engaging-saga-users#soulbound-nft)
  - [Collection NFT address](https://docs.solanamobile.com/marketing/engaging-saga-users#collection-nft-address)
  - [View on an explorer](https://docs.solanamobile.com/marketing/engaging-saga-users#view-on-an-explorer)
- [Verify a Saga Genesis Token holder](https://docs.solanamobile.com/marketing/engaging-saga-users#verify-a-saga-genesis-token-holder)
  - [Verifying individual ownership](https://docs.solanamobile.com/marketing/engaging-saga-users#verifying-individual-ownership)
- [Fetching a mint list of holders](https://docs.solanamobile.com/marketing/engaging-saga-users#fetching-a-mint-list-of-holders)

## Solana Mobile Partnerships FAQ
[Skip to main content](https://docs.solanamobile.com/marketing/faq#__docusaurus_skipToContent_fallback)

- Partnerships
- Marketing

### How can we partner with Solana Mobile?

+

### Can we have our app preinstalled on the phone?

+

### How can I engage with Seeker users?

+

### Can we have discounted Seekers for development or marketing purposes?

+

### How can we get marketing support from Solana Mobile?

+

### How can I engage with Seeker users?

+

### How can I see user statistics for my app in the dApp Store?

+

## Solana Mobile Marketing Hub
[Skip to main content](https://docs.solanamobile.com/marketing/overview#__docusaurus_skipToContent_fallback)

This section of the site serves as a resource hub for all things related to marketing your app to the Solana Mobile community.

# Quickstart

Whether you're just beginning your publishing journey or about to publish an app, read through the resources
here to ensure a successful launch.

[📣\\
\\
**Co-marketing with Solana Mobile**\\
\\
Learn how you can co-market with Solana Mobile and reach the Solana Mobile community.](https://docs.solanamobile.com/marketing/comarketing-guidelines)

[_![](https://docs.solanamobile.com/img/seeker-genesis-token.png)_ **Engaging Seeker users**\\
\\
Run a campaign targeting Seekers using the Seeker Genesis Token.](https://docs.solanamobile.com/marketing/engaging-seeker-users)

[❓\\
\\
**Partnership Inquiries**\\
\\
Common questions and requests about collaboration with Solana Mobile.](https://docs.solanamobile.com/marketing/faq)

[_![](https://docs.solanamobile.com/img/dappstore-logo.png)_ **Solana dApp Store**\\
\\
Learn about the Solana dApp Store and how to publish mobile and web apps.](https://docs.solanamobile.com/dapp-publishing/intro)

## Mobile Wallet Architecture
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#__docusaurus_skipToContent_fallback)

On this page

This reference aims to give a conceptual overview of the architecture of the **Mobile Wallet Adapter (MWA) protocol**.

## Mobile Wallet Adapter Protocol [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#mobile-wallet-adapter-protocol "Direct link to Mobile Wallet Adapter Protocol")

The Mobile Wallet Adapter protocol is what defines the communication exchange between a dApp and a mobile wallet app.

In the protocol, the dApp sends requests (e.g. `authorize`, `sign_transactions`), while the wallet is responsible for displaying
these requests to the user and responding back to the dApp if approved.

For an extensive, deep dive into the specifics of the protocol and MWA methods, refer to the [MWA spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html).

### High Level [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#high-level "Direct link to High Level")

The following diagram shows a bird's eye view of a mobile dApp's interactions with mobile wallets and the Solana network.

![Full Architecture Diagram](https://docs.solanamobile.com/diagrams/dapp_architecture_full.svg)

### Session Establishment [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#session-establishment "Direct link to Session Establishment")

To begin the protocol, a dApp initiates first contact with a mobile wallet and establishes an **MWA session**.
With the current SDKs, the MWA session is initiated through Android intents, with the dApp broadcasting an intent
with the `solana-wallet://` scheme.

![Session Establishment Diagram](https://docs.solanamobile.com/diagrams/session_establishment.svg)

A wallet then receives the intent and starts a websocket connection, thus establishing a channel for commmunication.

### Example: Authorize and Sign Transaction [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#example-authorize-and-sign-transaction "Direct link to Example: Authorize and Sign Transaction")

Once a session is established, the dApp can now begin sending MWA Requests to receive signed transactions from the wallet.
This example case outlines an MWA session where the dApp:

1. Establishes a session with a wallet.
2. Requests authorization, elevating the session to an "authorized state" and receiving a list of authorized accounts and an authToken.
3. Requests transaction signing, receiving a transaction signed by the authorized accounts.

![Authorize and Sign Diagram](https://docs.solanamobile.com/diagrams/authorize_and_sign.svg)

In future sessions, the dApp can initiate with the valid authToken to immediately elevate to an "authorizd state", skipping the "connect" step.

While the protocol technically supports multiple accounts, most wallet apps only implement a single account authorization per session.

For a more detailed diagram that shows the full communication exchange, refer to this [section in the spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#authorize-and-sign-transaction).

## Submitting to the Solana network [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#submitting-to-the-solana-network "Direct link to Submitting to the Solana network")

Just like web dApps, the process for a mobile dApp submitting transactions to the blockchain network is the same. The dApp specifies
a cluster and an RPC endpoint then sends the transaction payload, following the [JSON RPC API](https://docs.solana.com/api).

For certain usecases, the dApp may choose to communicate with the RPC through the [Websocket API](https://docs.solana.com/api/websocket)

![Submit to RPC Diagram](https://docs.solanamobile.com/diagrams/submit_rpc.svg)

### Sign and Send Transaction [​](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams\#sign-and-send-transaction "Direct link to Sign and Send Transaction")

For submitting transactions, it is encouraged for the dApp to send a `sign_and_send_transaction` MWA request to the wallet. This request
type sends a unsigned transaction to the wallet. If authorized, the wallet will then sign the transaction and send it to the network with its
own implementation. Depending on the wallet app, this can include applying its own priority fee.

Relying on the wallet reduces the risk of replay attacks with [durable nonce based transactions](https://docs.solana.com/implemented-proposals/durable-tx-nonces), which can be abused with `sign_transactions`.

![Sign and Send Diagram](https://docs.solanamobile.com/diagrams/sign_and_send.svg)

- [Mobile Wallet Adapter Protocol](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#mobile-wallet-adapter-protocol)
  - [High Level](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#high-level)
  - [Session Establishment](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#session-establishment)
  - [Example: Authorize and Sign Transaction](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#example-authorize-and-sign-transaction)
- [Submitting to the Solana network](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#submitting-to-the-solana-network)
  - [Sign and Send Transaction](https://docs.solanamobile.com/mobile-wallet-adapter/diagrams#sign-and-send-transaction)

## Migration to Wallet Standard
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#__docusaurus_skipToContent_fallback)

On this page

On the web, Mobile Wallet Adapter (MWA) is available as a _standard wallet_ with the package:

- [`@solana-mobile/wallet-standard-mobile`](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/js/packages/wallet-standard-mobile)

This is the recommended library for MWA on web and this guide explains why and how to migrate your web app.

## How to upgrade [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#how-to-upgrade "Direct link to How to upgrade")

### 1\. Install Mobile Wallet Standard [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#1-install-mobile-wallet-standard "Direct link to 1. Install Mobile Wallet Standard")

Installing the standard wallet takes two steps:

#### Step 1 [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#step-1 "Direct link to Step 1")

Add the library `@solana-mobile/wallet-standard-mobile`.

```bash
npm install @solana-mobile/wallet-standard-mobile
```

#### Step 2 [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#step-2 "Direct link to Step 2")

Call the `registerMwa` function.

caution

Ensure `registerMwa` is invoked in a non-SSR context. if you're using a framework with Server Side Rendering (e.g Next.js),

```ts
// 'use client' - If using Next.js, ensure it is registered in a non-SSR context.

import {
    createDefaultAuthorizationCache,
    createDefaultChainSelector,
    createDefaultWalletNotFoundHandler,
    registerMwa,
} from '@solana-mobile/wallet-standard-mobile';

registerMwa({
    appIdentity: {
      name: 'My app',
      uri: 'https://myapp.io',
      icon: 'relative/path/to/icon.png', // resolves to https://myapp.io/relative/path/to/icon.png
    },
    authorizationCache: createDefaultAuthorizationCache(),
    chains: ['solana:devnet', 'solana:mainnet'],
    chainSelector: createDefaultChainSelector(),
    onWalletNotFound: createDefaultWalletNotFoundHandler(),
    // remoteHostAuthority: '<REPLACE_WITH_URL_>',  Include to enable remote connection option.
})
```

Now, `Mobile Wallet Adapter` will appear as a wallet option.

For more context, view the **full [installation guide](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation).**

### 2\. Update to wallet-adapter >= 0.15.36 [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#2-update-to-wallet-adapter--01536 "Direct link to 2. Update to wallet-adapter >= 0.15.36")

If your web app is using `@solana/wallet-adapter-react` update to a version `>= 0.15.36`.
Updating fixes common MWA Web issues like:

- the [_No connect after selecting MWA_](https://github.com/solana-mobile/mobile-wallet-adapter/issues/1086) bug.

## Why switch? [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#why-switch "Direct link to Why switch?")

There are several reasons to upgrade to using MWA via Wallet Standard.

### Wallet Adapter no longer includes MWA as a default [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#wallet-adapter-no-longer-includes-mwa-as-a-default "Direct link to Wallet Adapter no longer includes MWA as a default")

The `@solana/wallet-adapter-react` library will [not include MWA as a default option](https://github.com/anza-xyz/wallet-adapter/pull/1097) starting from versions `>= 1.0.0`.

This means any web app using `@solana/wallet-adapter-react` will no longer display `Mobile Wallet Adapter` as an option for users
browsing on Android Chrome, unless explicitly added.

### Enable remote connection [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#enable-remote-connection "Direct link to Enable remote connection")

The `@solana-mobile/wallet-standard-mobile` library includes a remote connection option that allows users to connect their mobile wallet app to a desktop web page.

View the [MWA Remote documentation](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation#enable-remote-connection) for more information.

### Bug fixes and stability [​](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard\#bug-fixes-and-stability "Direct link to Bug fixes and stability")

The `@solana-mobile/wallet-standard-mobile` is the recommended web library for MWA going forward. This means it will receive all the latest feature additions and updates.

The legacy `@solana-mobile/wallet-adapter-mobile` library will be deprecated and enter maintenance mode, and only receive updates for bug fixes.

- [How to upgrade](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#how-to-upgrade)
  - [1\. Install Mobile Wallet Standard](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#1-install-mobile-wallet-standard)
  - [2\. Update to wallet-adapter >= 0.15.36](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#2-update-to-wallet-adapter--01536)
- [Why switch?](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#why-switch)
  - [Wallet Adapter no longer includes MWA as a default](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#wallet-adapter-no-longer-includes-mwa-as-a-default)
  - [Enable remote connection](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#enable-remote-connection)
  - [Bug fixes and stability](https://docs.solanamobile.com/mobile-wallet-adapter/migrating-to-wallet-standard#bug-fixes-and-stability)

## Mobile Wallet Adapter Overview
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/overview#__docusaurus_skipToContent_fallback)

On this page

**Mobile Wallet Adapter (MWA)** is a generic protocol specification that enables dApps to connect with mobile wallet apps for Solana transaction and message signing.

![Mobile Wallet Adapter](https://docs.solanamobile.com/diagrams/mwa_hero_diagram.svg)

## Features [​](https://docs.solanamobile.com/mobile-wallet-adapter/overview\#features "Direct link to Features")

### Unified Wallet Integration

Integrate the SDK once and your dApp is compatible with all MWA-compliant wallets.

### Simple User Onboarding

Users connect and choose a familiar wallet with no additional sign-up steps required.

### User Wallet Choice

Give users the freedom to connect with their preferred mobile wallet app.

## Client SDKs [​](https://docs.solanamobile.com/mobile-wallet-adapter/overview\#client-sdks "Direct link to Client SDKs")

### Mobile

[Overview](https://docs.solanamobile.com/mobile-wallet-adapter/mobile-apps) [![](https://docs.solanamobile.com/img/react-native-96.svg)\\
\\
React Native](https://docs.solanamobile.com/react-native/using_mobile_wallet_adapter) [![](https://docs.solanamobile.com/img/kotlin-icon-32.svg)\\
\\
Kotlin](https://docs.solanamobile.com/android-native/using_mobile_wallet_adapter) [![](https://docs.solanamobile.com/img/flutter-icon.svg)\\
\\
Flutter](https://docs.solanamobile.com/flutter/overview)

### Web

[Overview](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps) [Installation](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation) [Demo](https://solana-mobile.github.io/mobile-wallet-adapter/example-web-app/)

- [Features](https://docs.solanamobile.com/mobile-wallet-adapter/overview#features)
- [Client SDKs](https://docs.solanamobile.com/mobile-wallet-adapter/overview#client-sdks)

## Mobile Wallet Adapter Guide
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#__docusaurus_skipToContent_fallback)

On this page

This guide will cover the best practices for using Mobile Wallet Adapter (MWA) in your web app.

This guide assumes:

- You are using `@solana/wallet-adapter-react`
- The user is browsing on an **Android Web environment**, where MWA is usually the only available wallet.

## Call `connect()` directly [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#call-connect-directly "Direct link to call-connect-directly")

You should explicitly handle two scenarios:

1. If MWA is already selected, you should always directly call `connect`.

2. If it is not selected, but available, `select` it as early as possible in your UI flow.


This will also fix connection related issues with Mobile Wallet Adapter.

### Example: Connect Button [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#example-connect-button "Direct link to Example: Connect Button")

```typescript
import { useWallet } from '@solana/wallet-adapter-react'
import { useWalletModal } from '@solana/wallet-adapter-react-ui';
import { SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-standard-mobile'

export default function ConnectButton() {
    const { connected, connect, wallet, wallets } = useWallet();
    const { setVisible: showWalletSelectionModal } = useWalletModal();

    const handleConnectClick = () => {
        // MWA is only available if user is on Android Web environments (e.g Android Chrome).
        if (wallet?.adapter?.name === SolanaMobileWalletAdapterWalletName) {
            // If already selected, immediately connect.
            await connect();
        } else if (mobileWalletAdapter) {
            // If MWA is not selected, but available, select it instead of showing modal.
            select(SolanaMobileWalletAdapterWalletName)
        } else {
            // Else, show modal as usual.
            showWalletSelectionModal(true)
        }
    }
    return <Button disabled={connected} onClick={handleConnectClick} />;
}
```

## Connect and Sign in a single user action [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#connect-and-sign-in-a-single-user-action "Direct link to Connect and Sign in a single user action")

If your app uses MWA and requires a user to _Sign-in-with-Solana_ (e.g`connect` \+ `signMessage`), it needs to invoke both methods from a single user action.

### Why? [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#why "Direct link to Why?")

If `signMessage` is invoked programmatically (e.g in a `useEffect`), Android Chrome browser will block the navigation attempt in accordance with it's [trusted event policy](https://developer.chrome.com/docs/android/intents).

### Solution [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#solution "Direct link to Solution")

To `connect` \+ `signMessage` in a single user action, you should directly call the `signIn()` method

Mobile Wallet Adapter always supports the `signIn` method which invokes a `connect` and `signMessage` all within a single method.

### Example: Sign In Button [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#example-sign-in-button "Direct link to Example: Sign In Button")

```typescript
import { useWallet } from '@solana/wallet-adapter-react'
import { useWalletModal } from '@solana/wallet-adapter-react-ui';
import { SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-standard-mobile'

export default function SignInButton() {
    const { connected, signIn, wallet, wallets } = useWallet();
    const { setVisible: showWalletSelectionModal } = useWalletModal();

    const handleSignInButtonClick = () => {
        // MWA is only available if user is on Android Web environments (e.g Android Chrome).
        if (wallet?.adapter?.name === SolanaMobileWalletAdapterWalletName) {
            // If MWA is present, immediately sign in.
            const input: SolanaSignInInput = {
                domain: window.location.host,
                statement: "Sign in to My Web App",
                uri: window.location.origin,
            }
            const output = await signIn(input);
        } else {
            // Else, show modal as usual.
            showWalletSelectionModal(true)
        }
    }
    return <Button disabled={connected} onClick={handleSignInButtonClick} />;
}
```

## Change the displayed name [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#change-the-displayed-name "Direct link to Change the displayed name")

Throughout your UI, use the text `Use Installed Wallet` as the displayed name for the MWA option.

This descriptive text helps your users understand that this option will allow them to connect to an installed mobile wallet app (via MWA).

### Example: Wallet List Item Component [​](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines\#example-wallet-list-item-component "Direct link to Example: Wallet List Item Component")

```typescript
import { SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-standard-mobile'

export default function WalletListItem({ wallet, onPress }){
    // If we are showing MWA, use a descriptive display name.
    const displayName = (wallet.adapter.name === SolanaMobileWalletAdapterWalletName)
                        ? `Use Installed Wallet` : wallet.adapter.name
    return (
    <Button onClick={onPress}>
        {displayName}
    </Button>
    );
};
```

- [Call `connect()` directly](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#call-connect-directly)
  - [Example: Connect Button](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#example-connect-button)
- [Connect and Sign in a single user action](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#connect-and-sign-in-a-single-user-action)
  - [Why?](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#why)
  - [Solution](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#solution)
  - [Example: Sign In Button](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#example-sign-in-button)
- [Change the displayed name](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#change-the-displayed-name)
  - [Example: Wallet List Item Component](https://docs.solanamobile.com/mobile-wallet-adapter/ux-guidelines#example-wallet-list-item-component)

## Mobile Wallet Adapter Guide
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps#__docusaurus_skipToContent_fallback)

On this page

Mobile WebDesktop Web

![Desktop Web](https://docs.solanamobile.com/img/RemoteModal.png)

## Overview [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps\#overview "Direct link to Overview")

Mobile Wallet Adapter works on both Desktop Web and Mobile Web applications through two different connection methods:

- **Desktop Web Apps** connect remotely to wallet apps via QR code scanning.
- **Mobile Web Apps**, including PWAs, connect locally to wallet apps on the same device.

## SDK [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps\#sdk "Direct link to SDK")

Use the **Mobile Wallet Standard** library to register MWA as a wallet option in your web app for both desktop and mobile users.

The library handles both connection types automatically and presents the correct user experience based on the user's platform. It is compatible with any web app using the `@anza/wallet-adapter` libraries.

### Reference

[Installation](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation) [Demo](https://solana-mobile.github.io/mobile-wallet-adapter/example-web-app/) [Github](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/js/packages/wallet-standard-mobile)

## Wallet Compatibility [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps\#wallet-compatibility "Direct link to Wallet Compatibility")

| Wallet (Android only) | QR Code (Remote) | Mobile Web (Local) |
| --- | --- | --- |
| Seed Vault Wallet | ✅ | ✅ |
| Solflare | ✅ (Planned) | ✅ |
| Phantom | ❌ | ✅ |

## Browser Compatibility [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps\#browser-compatibility "Direct link to Browser Compatibility")

| Platform | QR Code (Remote) | Mobile Web (Local) | Notes |
| --- | --- | --- | --- |
| Desktop - All Browsers | ✅ | N/A | QR Code display works on all desktop browsers. |
| Android - Chrome | N/A | ✅ | Primary Android browser; also works with Chrome PWAs. |
| Android - Other Browsers | N/A | ❌ | Firefox, Opera, Brave, etc. do not support MWA. |
| iOS - All Browsers | N/A | ❌ | MWA is not available on any iOS browser. |

- [Overview](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps#overview)
- [SDK](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps#sdk)
- [Wallet Compatibility](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps#wallet-compatibility)
- [Browser Compatibility](https://docs.solanamobile.com/mobile-wallet-adapter/web-apps#browser-compatibility)

## Mobile Wallet Installation
[Skip to main content](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation#__docusaurus_skipToContent_fallback)

On this page

Use the **Mobile Wallet Standard** library to register Mobile Wallet Adapter as a wallet option into your web application.

## Installation [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation\#installation "Direct link to Installation")

### 1\. Install the package [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation\#1-install-the-package "Direct link to 1. Install the package")

You can add Mobile Wallet Adapter to your web application by installing:

```shell
npm install @solana-mobile/wallet-standard-mobile
```

### 2\. Register the wallet [​](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation\#2-register-the-wallet "Direct link to 2. Register the wallet")

In the root of your web application, invoke the `registerMwa` function.

caution

Ensure `registerMwa` is invoked in a non-SSR context. if you're using a framework with Server Side Rendering (e.g Next.js),

```typescript
// 'use client' - If using Next.js, ensure it is registered in a non-SSR context.

import {
    createDefaultAuthorizationCache,
    createDefaultChainSelector,
    createDefaultWalletNotFoundHandler,
    registerMwa,
} from '@solana-mobile/wallet-standard-mobile';

registerMwa({
    appIdentity: {
      name: 'My app',
      uri: 'https://myapp.io',
      icon: 'relative/path/to/icon.png', // resolves to https://myapp.io/relative/path/to/icon.png
    },
    authorizationCache: createDefaultAuthorizationCache(),
    chains: ['solana:devnet', 'solana:mainnet'],
    chainSelector: createDefaultChainSelector(),
    onWalletNotFound: createDefaultWalletNotFoundHandler(),
})
```

Once registered, the wallet behavior automatically adapts to the user's device:

- **Mobile**: Local connection via Android Intents (same as native Android apps).
- **Desktop** (Not available yet): If `remoteHostAuthority` is provided, remote connection via QR Code.

- [Installation](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation#installation)
  - [1\. Install the package](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation#1-install-the-package)
  - [2\. Register the wallet](https://docs.solanamobile.com/mobile-wallet-adapter/web-installation#2-register-the-wallet)

## Clientlib Migration Guide
[Skip to main content](https://docs.solanamobile.com/mwa/migration/dapps/clientlib#__docusaurus_skipToContent_fallback)

On this page

## Update [​](https://docs.solanamobile.com/mwa/migration/dapps/clientlib\#update "Direct link to Update")

To update to clientlib 2.0, simply add the latest dependency in your gradle file:

```text
dependencies {
    implementation 'com.solanamobile:mobile-wallet-adapter-clientlib:2.0.0-alpha5'
}
```

Becasue there are no breaking changines in 2.0.0, This all that is required to update to MWA 2.0.

## Migrating from deprecated methods [​](https://docs.solanamobile.com/mwa/migration/dapps/clientlib\#migrating-from-deprecated-methods "Direct link to Migrating from deprecated methods")

Several methods and fields within the SDK have been updated to conform to the new 2.0 protocol. These methods will continue to work, but we recommend that dapps take advantage of the new capabilities.

### `MobileWalletAdapterClient.authorize` [​](https://docs.solanamobile.com/mwa/migration/dapps/clientlib\#mobilewalletadapterclientauthorize "Direct link to mobilewalletadapterclientauthorize")

The `MobileWalletAdapterClient.authorize` method accepts some new parameters.

```text
authorize(
    @Nullable Uri identityUri,
    @Nullable Uri iconUri,
    @Nullable String identityName,
    @Nullable String cluster
)
```

```text
authorize(
    @Nullable Uri identityUri,
    @Nullable Uri iconUri,
    @Nullable String identityName,
    @Nullable String chain,
    @Nullable String authToken,
    @Nullable String[] features,
    @Nullable byte[][] addresses
)
```

#### AuthorizationResult [​](https://docs.solanamobile.com/mwa/migration/dapps/clientlib\#authorizationresult "Direct link to AuthorizationResult")

The result object that is returned by `authorize` now supports multiple accounts. Rather than return the public key and label for a single account, the `AuthorizationResult` now returns a list of `AuthorizedAccount` objects with the following structure:

```text
AuthorizedAccount {
    @NonNull byte[] publicKey
    @Nullable String accountLabel
    @Nullable String[] chains
    @Nullable String[] features
}
```

### `MobileWalletAdapterClient.getCapabilities` [​](https://docs.solanamobile.com/mwa/migration/dapps/clientlib\#mobilewalletadapterclientgetcapabilities "Direct link to mobilewalletadapterclientgetcapabilities")

The feature flags `supportsSignAndSendTransactons` and `supportsCloneAuthorization` haave been removed from the `get_capabilities` request in MWA 2.0. These have been replaced by the feature IDs exposed by the feature extension API. The result object returned by `MobileWalletAdapterClient.getCapabilities` has been updated to conform to the new request specification. A new `suportedOptionalFeatures` attribute has been added to `MobileWalletAdapterClient.GetCapabilitiesResult` that will contian a list of feature identifieer strings indicating which optional feaures the wallet supports.

- [Update](https://docs.solanamobile.com/mwa/migration/dapps/clientlib#update)
- [Migrating from deprecated methods](https://docs.solanamobile.com/mwa/migration/dapps/clientlib#migrating-from-deprecated-methods)
  - [`MobileWalletAdapterClient.authorize`](https://docs.solanamobile.com/mwa/migration/dapps/clientlib#mobilewalletadapterclientauthorize)
  - [`MobileWalletAdapterClient.getCapabilities`](https://docs.solanamobile.com/mwa/migration/dapps/clientlib#mobilewalletadapterclientgetcapabilities)

## Client Library KTX Migration
[Skip to main content](https://docs.solanamobile.com/mwa/migration/dapps/clientlib-ktx#__docusaurus_skipToContent_fallback)

TODO

## MWA 2.0 Migration Overview
[Skip to main content](https://docs.solanamobile.com/mwa/migration/overview#__docusaurus_skipToContent_fallback)

On this page

## The MWA 2.0 Specification [​](https://docs.solanamobile.com/mwa/migration/overview\#the-mwa-20-specification "Direct link to The MWA 2.0 Specification")

The mobile wallet adapter protocol sepcification has been updated to support new features and capabilities and refine the protocol based on feedback from dApps and wallets using the protocol. This new specification aims to be backwards compatible with [Mobile Wallet Adapter 1.0](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec1.0.html), with a few caveats.

## Migrating from 1.x.x SDKs [​](https://docs.solanamobile.com/mwa/migration/overview\#migrating-from-1xx-sdks "Direct link to Migrating from 1.x.x SDKs")

### Dapp Developers [​](https://docs.solanamobile.com/mwa/migration/overview\#dapp-developers "Direct link to Dapp Developers")

#### Android Kotlin SDK [​](https://docs.solanamobile.com/mwa/migration/overview\#android-kotlin-sdk "Direct link to Android Kotlin SDK")

If you are consuming our Android Koltin SDK for dApp endpoints, `clientlib-ktx`, follow the migration guide [here](https://docs.solanamobile.com/mwa/migration/dapps/clientlib).

#### Android Java SDK [​](https://docs.solanamobile.com/mwa/migration/overview\#android-java-sdk "Direct link to Android Java SDK")

If you are consuming our Android Java SDK for dApp endpoints, `clientlib`, follow the migration guide [here](https://docs.solanamobile.com/mwa/migration/dapps/clientlib-ktx).

### Wallet Developers [​](https://docs.solanamobile.com/mwa/migration/overview\#wallet-developers "Direct link to Wallet Developers")

#### Android Java SDK [​](https://docs.solanamobile.com/mwa/migration/overview\#android-java-sdk-1 "Direct link to Android Java SDK")

If you are consuming our Android Java SDK for wallet endpoints, `walletlib`, follow the migration guide [here](https://docs.solanamobile.com/mwa/migration/wallets/walletlib).

- [The MWA 2.0 Specification](https://docs.solanamobile.com/mwa/migration/overview#the-mwa-20-specification)
- [Migrating from 1.x.x SDKs](https://docs.solanamobile.com/mwa/migration/overview#migrating-from-1xx-sdks)
  - [Dapp Developers](https://docs.solanamobile.com/mwa/migration/overview#dapp-developers)
  - [Wallet Developers](https://docs.solanamobile.com/mwa/migration/overview#wallet-developers)

## Wallet Adapter Migration Guide
[Skip to main content](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#__docusaurus_skipToContent_fallback)

On this page

The [Mobile Wallet Adapter 2.0 spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html) is published and the `walletlib` Android SDK
has been upgraded to support MWA 2.0.

Wallets can update their application following this migration guide.

## Summary of key changes [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#summary-of-key-changes "Direct link to Summary of key changes")

- Introduction of [feature identifiers](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#feature-identifiers).
- Introduction of [chain identifiers](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#chain-identifiers).
- API changes to the `authorize` RPC request specfication adding new parameters:
  - Sign In With Solana payload
  - Chain and feature identifiers
  - `authToken` and `addresses`
- API changes to the `MobileWalletAdapterConfig` object returned by `getCapabilities` RPC request.
- Mandatory support of the `signAndSendTransactions` RPC request.
  - Additional optional parameters added to `signAndSendTransactions`.
- Deprecation of `reauthorize` and `signTransactions` methods.

## Migration guide [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#migration-guide "Direct link to Migration guide")

### Update walletlib [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#update-walletlib "Direct link to Update walletlib")

To update to `walletlib` 2.0, simply add the latest dependency in your gradle file:

```groovy
dependencies {
    implementation 'com.solanamobile:mobile-wallet-adapter-walletlib:2.0.0-beta1'
}
```

There will be no breaking changes and the 2.0 implementation will be immediately backwards compatible with legacy clients.

### Authorize ( [2.0 spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html\#authorize)) [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#authorize-20-spec "Direct link to authorize-20-spec")

#### AuthorizeRequest [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#authorizerequest "Direct link to AuthorizeRequest")

To conform to the updated `authorize` RPC request specification, the `AuthorizationRequest` object that is passed from `walletlib` through the `onAuthorizeReqest` callback now includes some new parameters:

- MWA 2.0
- Legacy

```kotlin
AuthorizeRequest {
    @Nullable Uri identityUri;
    @Nullable Uri iconUri;
    @Nullable String identityName;
    @Nullable String authToken;                      // New
    @Nullable String chain;                          // New
    @Nullable String[] features;                     // New
    @Nullable String[] addresses;                    // New
    @Nullable SignInWithSolana.Payload signInPayload // New
}
```

```kotlin
AuthorizeRequest {
    @Nullable Uri identityUri;
    @Nullable Uri iconUri;
    @Nullable String identityName;
    @NonNull String cluster // Deprecated. Replaced by `chain` parameter.
}
```

New parameters:

- `authToken`: An optional `authToken` where if provided, the wallet should attempt to reauthorize the session with it.
- `addresses`: An optional list of base64 encoded account addresses that the dapp wishes to be included in the authorization scope.
- `signInPayload`: An object containing the payload portion of a [Sign In With Solana message](https://siws.web3auth.io/spec).
- `chain`: A [chain identifier](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#chain-identifiers) to distinguish the requested blockchain network. Replaces the deprecated `cluster` parameter.
  - Supported Solana network chains: `solana:mainnet`, `solana:testnet`, and `solana:devnet`.
- `features`: An array of [feature identifiers](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#feature-identifiers), representing features requested by the client.

#### Parameter: `authToken` [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#parameter-authtoken "Direct link to parameter-authtoken")

An optional `authToken` where if present, the wallet should attempt to reauthorize the session using it. The wallet implementation will likely be able to re-use their `reauthorize` logic
to handle this case. This aims to replace the `reauthorize` RPC request and reduce the confusion between `authorize`/`reauthorize` for dApps developers.

#### Parameter: Sign In With Solana [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#parameter-sign-in-with-solana "Direct link to Parameter: Sign In With Solana")

An optional object containing the payload portion of a [Sign In With Solana message](https://siws.web3auth.io/spec).

If present, the wallet should present the SIWS message to the user and, if approved, include a `SignInResult` object in the `AuthorizationResult` response to the dapp endpoint.

```kotlin
public class SignInResult {
    @NonNull public final byte[] publicKey;
    @NonNull public final byte[] signedMessage;
    @NonNull public final byte[] signature;
    @Nullable public final String signatureType;
}
```

#### AuthorizationResult [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#authorizationresult "Direct link to AuthorizationResult")

The `AuthorizationResult` object that is returned to the dapp endpoint is now constructed by passing in a list of `AuthorizedAccount` objects, rather than a single public key and label.

An optional `walletIcon` parameter has also been added to allow the wallets to send back an icon (data URI) for dapps to display on thier UI when the wallet is connected.

Constructor for `AuthorizationResult`:

- MWA 2.0
- Legacy
- AuthorizedAccount

```kotlin
public AuthorizationResult(@NonNull String authToken,
                           @NonNull @Size(min = 1) AuthorizedAccount[] accounts,
                           @Nullable Uri walletUriBase,
                           @Nullable Uri walletIcon,
                           @Nullable SignInResult signInResult);
```

```kotlin
@Deprecated
public AuthorizationResult(@NonNull String authToken,
                           @NonNull byte[] publicKey,
                           @Nullable String accountLabel,
                           @Nullable Uri walletUriBase);
```

```kotlin
AuthorizedAccount {
    @NonNull byte[] publicKey
    @Nullable String accountLabel
    @Nullable String[] chains
    @Nullable String[] features
}
```

### Sign And Send Transactions ( [2.0 spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html\#sign_and_send_transactions)) [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#sign-and-send-transactions-20-spec "Direct link to sign-and-send-transactions-20-spec")

Suport for the `sign_and_send_transactions` request has been made mandatory in the Mobile Wallet Adapter 2.0 specification. Wallets must now implement this method according to [the spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#sign_and_send_transactions).

The optional transaction parameters have also been expanded to allows dapps to further specify how transactions should be sent to the RPC by the wallet endpoint.

Additional optional parameters in `SignAndSendTransactionRequest`:

- MWA 2.0

```java
public class SignAndSendTransactionRequest
    extends BaseVerifiableIdentityRequest<MobileWalletAdapterServer.SignAndSendTransactionsRequest> {

    /* ... */

    @Nullable
    public Integer getMinContextSlot();
    @Nullable
    public String getCommitment();      // New
    @Nullable
    public Boolean getSkipPreflight();  // New
    @Nullable
    public Integer getMaxRetries();     // New
    @Nullable
    public Boolean getWaitForCommitmentToSendNextTransaction(); // New

    /* ... */

}
```

For an explanation on each parameter, see the [spec](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec.html#method-3).

### `MobileWalletAdapterConfig` [​](https://docs.solanamobile.com/mwa/migration/wallets/walletlib\#mobilewalletadapterconfig "Direct link to mobilewalletadapterconfig")

The configuration object that is used when setting up an MWA session has been updated. This object is returned to the dapp endpoint from a [`get_capabilities`](https://solana-mobile.github.io/mobile-wallet-adapter/spec/spec1.0.html#get_capabilities) RPC request.

The boolean feature flags `supportsSignAndSendTransactions` and `supportsCloneAuthorization` have been replaced with the `supportedFeatures` array, using the new
feature extension and identifer API.

The wallet can flag these features by adding `solana:signAndSendTransaction` and `solana:cloneAuthorization` and exposed through the new feature extension API.

- MWA 2.0
- Legacy

```java
MobileWalletAdapterConfig(
    int maxTransactionsPerSigningRequest,
    int maxMessagesPerSigningRequest,
    Object[] supportedTransactionVersions,
    long noConnectionWarningTimeoutMs,
    String[] supportedFeatures // Supported feature identifiers go here
)
```

```java
MobileWalletAdapterConfig(
    boolean supportsSignAndSendTransactions, // Deprecated. Migrate to feature IDs
    boolean supportsCloneAuthorization,      // Deprecated. Migrate to feature IDs
    int maxTransactionsPerSigningRequest,
    int maxMessagesPerSigningRequest,
    Object[] supportedTransactionVersions,
    long noConnectionWarningTimeoutMs
)
```

- [Summary of key changes](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#summary-of-key-changes)
- [Migration guide](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#migration-guide)
  - [Update walletlib](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#update-walletlib)
  - [Authorize (2.0 spec)](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#authorize-20-spec)
  - [Sign And Send Transactions (2.0 spec)](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#sign-and-send-transactions-20-spec)
  - [`MobileWalletAdapterConfig`](https://docs.solanamobile.com/mwa/migration/wallets/walletlib#mobilewalletadapterconfig)

## Anchor Integration Guide
[Skip to main content](https://docs.solanamobile.com/react-native/anchor_integration#__docusaurus_skipToContent_fallback)

On this page

This guide will show you how to integrate an Anchor Program into your React Native dApp, using the [Anchor Counter dApp](https://github.com/solana-mobile/tutorial-apps/tree/main/AnchorCounterDapp) as reference.

[Example App Repo](https://github.com/solana-mobile/tutorial-apps/tree/main/AnchorCounterDapp)

## What you will learn [​](https://docs.solanamobile.com/react-native/anchor_integration\#what-you-will-learn "Direct link to What you will learn")

- How to import an Anchor Program into a React Native project
- How to create an Anchor Wallet and Provider with Mobile Wallet Adapter
- How to sign and submit transactions with an Anchor Program IDL
- How to generate instructions with an Anchor Program IDL

## Prerequisites [​](https://docs.solanamobile.com/react-native/anchor_integration\#prerequisites "Direct link to Prerequisites")

- [React Native setup](https://docs.solanamobile.com/react-native/setup) and [Anchor setup](https://book.anchor-lang.com/getting_started/installation.html)
- Basic understanding of [Anchor Programs](https://book.anchor-lang.com/) and IDL.
- An existing [deployed](https://book.anchor-lang.com/anchor_in_depth/milestone_project_tic-tac-toe.html#deployment) Anchor Program.

## Installation [​](https://docs.solanamobile.com/react-native/anchor_integration\#installation "Direct link to Installation")

Add the Anchor library to your React Native Project:

caution

React Native apps should use Anchor v0.28.0 because later versions of the library have a polyfill issue on React Native.

- yarn
- npm

```shell
yarn add @coral-xyz/anchor@0.28.0
```

```shell
npm install @coral-xyz/anchor@0.28.0
```

## Create an Anchor Wallet with Mobile Wallet Adapter [​](https://docs.solanamobile.com/react-native/anchor_integration\#create-an-anchor-wallet-with-mobile-wallet-adapter "Direct link to Create an Anchor Wallet with Mobile Wallet Adapter")

tip

The Anchor Counter Program example app shows how to create an Anchor wallet that is integrated
with a more complex state management framework.

[View sample](https://github.com/solana-mobile/tutorial-apps/blob/main/AnchorCounterDapp/src/utils/useAnchorWallet.tsx#L23)

To create an `AnchorWallet`, use Mobile Wallet Adapter `transact` to implement the required signing functions.

A simple implementation:

```tsx
import * as anchor from "@coral-xyz/anchor";
import {
  transact,
  Web3MobileWallet,
} from "@solana-mobile/mobile-wallet-adapter-protocol-web3js";

const anchorWallet = useMemo(() => {
  return {
    signTransaction: async (transaction: Transaction) => {
      return transact(async (wallet: Web3MobileWallet) => {
        const authorizationResult = await wallet.authorize({
              cluster: RPC_ENDPOINT,
              identity: APP_IDENTITY,
        }));

        const signedTransactions = await wallet.signTransactions({
          transactions: [transaction],
        });
        return signedTransactions[0];
      });
    },
    signAllTransactions: async (transactions: Transaction[]) => {
      return transact(async (wallet: Web3MobileWallet) => {
        const authorizationResult = await wallet.authorize({
              cluster: RPC_ENDPOINT,
              identity: APP_IDENTITY,
        }));

        const signedTransactions = await wallet.signTransactions({
          transactions: transactions,
        });
        return signedTransactions;
      });
    },
    get publicKey() {
      return userPubKey;
    },
  } as anchor.Wallet;
}, []);
```

## Importing an Anchor Program in Typescript [​](https://docs.solanamobile.com/react-native/anchor_integration\#importing-an-anchor-program-in-typescript "Direct link to Importing an Anchor Program in Typescript")

### Generating an Anchor Program IDL [​](https://docs.solanamobile.com/react-native/anchor_integration\#generating-an-anchor-program-idl "Direct link to Generating an Anchor Program IDL")

If you have an Anchor project in your local workspace, build the program and generate the Typescript IDL with:

```shell
anchor build
```

If the Anchor program is already deployed and you know its address, you can use the [Anchor CLI](https://book.anchor-lang.com/anchor_references/cli.html?highlight=idl#idl) to fetch it:

```shell
anchor idl fetch GrAkKfEpTKQuVHG2Y97Y2FF4i7y7Q5AHLK94JBy7Y5yv
```

### Instantiate your Anchor Program [​](https://docs.solanamobile.com/react-native/anchor_integration\#instantiate-your-anchor-program "Direct link to Instantiate your Anchor Program")

Once your IDL has been generated, you can import it and create an instance of your `Program` in Typescript.

- Import your generated IDL file, in this case from `/target/types/basic_counter.ts`
- Use the `anchorWallet` from the previous step to create an `AnchorProvider`.

[See example](https://github.com/solana-mobile/tutorial-apps/blob/main/AnchorCounterDapp/src/components/counter/counter-data-access.tsx#L15)

```tsx
import { BasicCounter as BasicCounterProgram } from "../../basic-counter/target/types/basic_counter";
import { AnchorProvider, Program } from "@coral-xyz/anchor";

const COUNTER_PROGRAM_ID = "ADraQ2ENAbVoVZhvH5SPxWPsF2hH5YmFcgx61TafHuwu";

// Address of the devnet-deployed Counter Program
const counterProgramId = useMemo(() => {
  return new PublicKey(COUNTER_PROGRAM_ID);
}, []);

// Create an AnchorProvider with the anchorWallet.
const provider = useMemo(() => {
  if (!anchorWallet) {
    return null;
  }
  return new AnchorProvider(connection, anchorWallet, {
    preflightCommitment: "confirmed",
    commitment: "processed",
  });
}, [anchorWallet, connection]);

// Create an instance of your Program.
const counterProgram = useMemo(() => {
  if (!provider) {
    return null;
  }

  return new Program<BasicCounterProgram>(
    idl as BasicCounterProgram,
    counterProgramId,
    provider
  );
}, [counterProgramId, provider]);
```

## Sign transactions manually with Mobile Wallet Adapter [​](https://docs.solanamobile.com/react-native/anchor_integration\#sign-transactions-manually-with-mobile-wallet-adapter "Direct link to Sign transactions manually with Mobile Wallet Adapter")

With an instantiated `Program`, you can:

- Generate serialized program instructions.
- Construct a `Transaction` with the generated instructions.
- Manually sign the `Transaction` with Mobile Wallet Adapter.

In the following example, we generate an `incrementInstruction` from the program then sign it within a Mobile Wallet Adapter
session.

```tsx
const {counterProgram, counterPDA} = useCounterProgram();

const signIncrementTransaction = async () => {
  return await transact(async (wallet: Web3MobileWallet) => {
    const authorizationResult = wallet.authorize({
      cluster: RPC_ENDPOINT,
      identity: APP_IDENTITY,
    }));

    const latestBlockhash = await connection.getLatestBlockhash();

    // Generate the increment ix from the Anchor program
    const incrementInstruction = await counterProgram.methods
        .increment(new anchor.BN(amount))
        .accounts({
          counter: counterPDA,
        })
        .instruction();

    // Build a transaction containing the instruction
    const incrementTransaction = new Transaction({
      ...latestBlockhash,
      feePayer: authorizationResult.publicKey,
    }).add(incrementInstruction);

    // Sign a transaction and receive
    const signedTransactions = await wallet.signTransactions({
      transactions: [incrementTransaction],
    });

    return signedTransactions[0];
  });
}
```

This approach is flexible and allows you to fully utilize the Mobile Wallet Adapter session.

## Sign transactions using a Mobile Wallet Adapter signer [​](https://docs.solanamobile.com/react-native/anchor_integration\#sign-transactions-using-a-mobile-wallet-adapter-signer "Direct link to Sign transactions using a Mobile Wallet Adapter signer")

With an instantiated `Program`, you can also use the Anchor provided `rpc()` function to sign and submit an Anchor transaction to an RPC.

[See example](https://github.com/solana-mobile/tutorial-apps/blob/main/AnchorCounterDapp/src/components/counter/counter-data-access.tsx#L89)

```tsx
const { counterProgram, counterPDA } = useCounterProgram();

const incrementCounter = async () => {
  // Submit an increment transaction to the RPC endpoint
  const signature = await counterProgram.methods
    .increment(new anchor.BN(amount))
    .accounts({
      counter: counterPDA,
    })
    .rpc();

  return signature;
};
```

Calling the `rpc()` will generate and sign the transaction using the interface methods (`signTransaction`, `signAllTransactions`) of the Anchor Wallet that the program was instantiated with.

- [What you will learn](https://docs.solanamobile.com/react-native/anchor_integration#what-you-will-learn)
- [Prerequisites](https://docs.solanamobile.com/react-native/anchor_integration#prerequisites)
- [Installation](https://docs.solanamobile.com/react-native/anchor_integration#installation)
- [Create an Anchor Wallet with Mobile Wallet Adapter](https://docs.solanamobile.com/react-native/anchor_integration#create-an-anchor-wallet-with-mobile-wallet-adapter)
- [Importing an Anchor Program in Typescript](https://docs.solanamobile.com/react-native/anchor_integration#importing-an-anchor-program-in-typescript)
  - [Generating an Anchor Program IDL](https://docs.solanamobile.com/react-native/anchor_integration#generating-an-anchor-program-idl)
  - [Instantiate your Anchor Program](https://docs.solanamobile.com/react-native/anchor_integration#instantiate-your-anchor-program)
- [Sign transactions manually with Mobile Wallet Adapter](https://docs.solanamobile.com/react-native/anchor_integration#sign-transactions-manually-with-mobile-wallet-adapter)
- [Sign transactions using a Mobile Wallet Adapter signer](https://docs.solanamobile.com/react-native/anchor_integration#sign-transactions-using-a-mobile-wallet-adapter-signer)

## Building Solana Transactions
[Skip to main content](https://docs.solanamobile.com/react-native/building_transactions#__docusaurus_skipToContent_fallback)

On this page

A client interacts with the Solana network by submitting a _transaction_ to the cluster. Transactions
allow a client to invoke instructions of on-chain [_Programs_](https://docs.solana.com/developing/intro/programs).

For a full explanation, see the core docs overview of a [_transaction_](https://docs.solana.com/developing/programming-model/transactions).

## Add dependencies [​](https://docs.solanamobile.com/react-native/building_transactions\#add-dependencies "Direct link to Add dependencies")

The [@solana/web3.js](https://github.com/solana-labs/solana-web3.js) library provides convenient classes and Solana primitive types to build transactions.

- yarn
- npm

```bash
yarn install @solana/web3.js
```

```bash
npm install @solana/web3.js
```

### Add polyfills [​](https://docs.solanamobile.com/react-native/building_transactions\#add-polyfills "Direct link to Add polyfills")

After installing, ensure you have also added these [polyfills](https://docs.solanamobile.com/react-native/polyfill-guides/web3-js) to your React native app.
These are needed by some parts of `@solana/web3.js` because it is originally written as a web/node library and, as a result, certain expected APIs are missing in a React Native environment.

## Example: SOL Transfer Transaction [​](https://docs.solanamobile.com/react-native/building_transactions\#example-sol-transfer-transaction "Direct link to Example: SOL Transfer Transaction")

In the following example, we create a _transaction_ that invokes the [System Program](https://docs.solana.com/developing/runtime-facilities/programs#system-program)'s _transfer_ instruction to send SOL to an address.

A _[transaction instruction](https://docs.solana.com/developing/programming-model/transactions#instructions)_ is comprised of a program id, a list of accounts, and instruction data specific to the program.

- Versioned Transactions
- Legacy Transactions

A [versioned transaction](https://docs.solana.com/developing/versioned-transactions) is a new format for transactions recommended for use by clients.

As an example, we'll be invoking the _transfer_ instruction from the _System Program_. Use the `SystemProgram` factory class
to conveniently generate the _transfer_ instruction.

```tsx
import {
  Connection,
  PublicKey,
  VersionedTransaction,
  SystemProgram,
} from "@solana/web3.js";

// Create a list of Program instructions to execute.
const instructions = [\
  SystemProgram.transfer({\
    fromPubkey: fromPublicKey,\
    toPubkey: toPublicKey,\
    lamports: 1_000_000,\
  }),\
];

// Connect to an RPC endpoint and get the latest blockhash, to include in
// the transaction.
const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
const latestBlockhash = await connection.getLatestBlockhash();

// Create the "message" of a transaction and compile to `V0Message` format.
const txMessage = new TransactionMessage({
  payerKey: fromPublicKey,
  recentBlockhash: latestBlockhash.blockhash,
  instructions,
}).compileToV0Message();

// Construct the Versioned Transaction passing in the message.
const versionedTransaction = new VersionedTransaction(txMessage);
```

For backwards compatiblity, you can still construct legacy transactions with `@solana/web3.js`.

```tsx
import {
  Connection,
  PublicKey,
  Transaction,
  SystemProgram,
} from "@solana/web3.js";

const latestBlockhash = await connection.getLatestBlockhash();
const randomTransferTransaction = new Transaction({
  ...latestBlockhash,
  feePayer: fromPublicKey,
}).add(
  SystemProgram.transfer({
    fromPubkey: fromPublicKey,
    toPubkey: toPublicKey,
    lamports: 1_000,
  })
);
```

## Send a Transaction [​](https://docs.solanamobile.com/react-native/building_transactions\#send-a-transaction "Direct link to Send a Transaction")

After a transaction is signed by the appropriate accounts, it can be submitted to the Solana network via RPC. See the
next guide, _Using Mobile Walelt Adapter_ to learn how to sign transactions.

- Versioned Transactions
- Legacy Transactions

```tsx
import { transact } from "@solana-mobile/mobile-wallet-adapter-protocol-web3js";
import {
  sendTransaction,
  clusterApiUrl,
  Connection,
  VersionedTransaction,
  confirmTransaction,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
const unsignedTx = new VersionedTransaction(/* ... */);
const signedTx: VersionedTransaction = await transact((wallet) => {
  /* ...sign `unsignedTx` with Mobile Wallet Adapter... */
});

// After sending, a transaction signature is returned.
const txSignature = await connection.sendTransaction(signedTx);

// Confirm the transaction was successful.
const confirmationResult = await connection.confirmTransaction(
  txSignature,
  "confirmed"
);

if (confirmationResult.value.err) {
  throw new Error(JSON.stringify(confirmationResult.value.err));
} else {
  console.log("Transaction successfully submitted!");
}
```

```tsx
import { transact } from "@solana-mobile/mobile-wallet-adapter-protocol-web3js";
import {
  sendTransaction,
  clusterApiUrl,
  Connection,
  Transaction,
  confirmTransaction,
} from "@solana/web3.js";

const connection = new Connection(clusterApiUrl("devnet"), "confirmed");
const signedTx: Transaction = await transact((wallet) => {
  /* ...signing code from above... */
});

// After sending, a transaction signature is returned.
const txSignature = await sendTransaction(signedTx, connection);

// Confirm the transaction was successful.
const confirmationResult = await connection.confirmTransaction(
  txSignature,
  "confirmed"
);

if (confirmationResult.value.err) {
  throw new Error(JSON.stringify(confirmationResult.value.err));
} else {
  console.log("Transaction successfully submitted!");
}
```

## Next steps [​](https://docs.solanamobile.com/react-native/building_transactions\#next-steps "Direct link to Next steps")

- Read the following _Using Mobile Wallet Adapter_ guide to learn how to sign these transactions and submit them to the Solana network.
- See the [Anchor Integration guide](https://docs.solanamobile.com/react-native/anchor_integration) to learn how to create and create transactions and invoke instructions from Anchor programs.

- [Add dependencies](https://docs.solanamobile.com/react-native/building_transactions#add-dependencies)
  - [Add polyfills](https://docs.solanamobile.com/react-native/building_transactions#add-polyfills)
- [Example: SOL Transfer Transaction](https://docs.solanamobile.com/react-native/building_transactions#example-sol-transfer-transaction)
- [Send a Transaction](https://docs.solanamobile.com/react-native/building_transactions#send-a-transaction)
- [Next steps](https://docs.solanamobile.com/react-native/building_transactions#next-steps)

## Expo dApp Template
[Skip to main content](https://docs.solanamobile.com/react-native/expo-dapp-template#__docusaurus_skipToContent_fallback)

On this page

This template is a ready-to-go Expo dApp that offers:

- Pre-installed standard SDKs like Mobile Wallet Adapter and `@solana/web3.js`
- Required polyfills like `react-native-get-random-values` and `Buffer` installed.
- Simple React UI Components like `ConnectWalletButton`, `RequestAirdropButton`, `SignMessageButton`.

[View on GitHub](https://github.com/solana-mobile/solana-mobile-expo-template)

## Prerequisites [​](https://docs.solanamobile.com/react-native/expo-dapp-template\#prerequisites "Direct link to Prerequisites")

- An [Expo](https://expo.dev/) account.
- React Native and Android Envrionment [setup](https://docs.solanamobile.com/developers/development-setup)
  - An Android device/emulator.
  - Install an MWA compliant wallet app on your device/emulator.

## Usage [​](https://docs.solanamobile.com/react-native/expo-dapp-template\#usage "Direct link to Usage")

### Initialization [​](https://docs.solanamobile.com/react-native/expo-dapp-template\#initialization "Direct link to Initialization")

Initialize the template using Expo's CLI tool:

```text
yarn create expo-app --template @solana-mobile/solana-mobile-expo-template
```

info

The Expo CLI has issues when using other package managers like `npm`, `npx` or `pnpm`. Until fixed, use `yarn` to initialize
the template app.

Choose your project name then navigate into the directory.

### Build and run the app [​](https://docs.solanamobile.com/react-native/expo-dapp-template\#build-and-run-the-app "Direct link to Build and run the app")

Follow the **["Running the app"](https://docs.solanamobile.com/react-native/expo#running-the-app)** section in the Expo Setup guide to launch the template as a custom development build.

## Troubleshooting [​](https://docs.solanamobile.com/react-native/expo-dapp-template\#troubleshooting "Direct link to Troubleshooting")

`The package 'solana-mobile-wallet-adapter-protocol' doesn't seem to be linked.`

- Make sure you are building and installing an Expo development build _NOT_ Expo Go. Follow the instructions here to
build a [custom development build](https://docs.solanamobile.com/react-native/expo#custom-development-build).

`TS2307: Cannot find module @solana-mobile/mobile-wallet-adapter-protocol or its corresponding type declarations.`

- This is a bug/issue when using `npm`. Until it is fixed, to mitigate, please install the project using `yarn install`, not `npm install`.

- [Prerequisites](https://docs.solanamobile.com/react-native/expo-dapp-template#prerequisites)
- [Usage](https://docs.solanamobile.com/react-native/expo-dapp-template#usage)
  - [Initialization](https://docs.solanamobile.com/react-native/expo-dapp-template#initialization)
  - [Build and run the app](https://docs.solanamobile.com/react-native/expo-dapp-template#build-and-run-the-app)
- [Troubleshooting](https://docs.solanamobile.com/react-native/expo-dapp-template#troubleshooting)

## Solana dApp Tutorial
[Skip to main content](https://docs.solanamobile.com/react-native/first_app_tutorial#__docusaurus_skipToContent_fallback)

On this page

In this tutorial, you'll learn how to build a React Native dApp that sends a message to the Solana network.

## What you will learn [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#what-you-will-learn "Direct link to What you will learn")

- How to use [**Mobile Wallet Adapter**](https://docs.solanamobile.com/developers/overview#mobile-wallet-adapter) to connect to an installed wallet app.
- How to connect to devnet, check your wallet balance, and request an airdrop of SOL.
- How to use the memo program to write your message to the network
- View your message on the [Solana Explorer](https://explorer.solana.com/)!

## Prerequisites [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#prerequisites "Direct link to Prerequisites")

Read the [prerequisite setup](https://docs.solanamobile.com/developers/development-setup) guide before starting the tutorial.
You'll need:

- a running Android emulator or device to build and launch your app.
- an MWA-compatible wallet installed on the same device.
- an IDE/Editor of your choice.

This tutorial will be using the [fakewallet](https://docs.solanamobile.com/developers/development-setup#3-install-a-wallet-app) app to test your app's integration with Mobile Wallet Adapter.

## Clone the React Native dApp Scaffold [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#clone-the-react-native-dapp-scaffold "Direct link to Clone the React Native dApp Scaffold")

This dApp will build off the **[React Native Scaffold dApp](https://docs.solanamobile.com/react-native/setup#solana-mobile-dapp-scaffold)** which already has a simple user interface that allows you to connect to a mobile wallet, request an airdrop, and sign transactions.

#### Step 1. Initialize a template app [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#step-1-initialize-a-template-app "Direct link to Step 1. Initialize a template app")

```shell
npx react-native init FirstDappTutorial --template https://github.com/solana-mobile/solana-mobile-dapp-scaffold.git
```

#### Step 2. Enter the directory and install the project dependencies. [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#step-2-enter-the-directory-and-install-the-project-dependencies "Direct link to Step 2. Enter the directory and install the project dependencies.")

- yarn
- npm

```shell
cd FirstDappTutorial && yarn install
```

```shell
cd FirstDappTutorial && npm install
```

#### Step 3. Make sure your emulator/device is running, then build and launch the app. [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#step-3-make-sure-your-emulatordevice-is-running-then-build-and-launch-the-app "Direct link to Step 3. Make sure your emulator/device is running, then build and launch the app.")

```shell
npx react-native run-android
```

### First run [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#first-run "Direct link to First run")

At this point, your app should build, install into your device, and launch automatically.
You should also see the Metro Bundler console window pop up. This is where you can read the logs and access the debug menu.

With React Native's _fast refresh_ feature, you can edit the React components, save your changes, and immediately see your app UI update!

## Scaffold dApp Components [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#scaffold-dapp-components "Direct link to Scaffold dApp Components")

Now lets quickly go over the features of the dApp Scaffold. If you want to skip to building the memo transaction, then jump to this [section](https://docs.solanamobile.com/react-native/first_app_tutorial#send-a-memo-transaction).

### Connect Button [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#connect-button "Direct link to Connect Button")

Clicking on the _Connect Wallet_ button will 'connect' you to a locally installed MWA-compatible wallet. It uses the Mobile Wallet Adapter
SDK to request [`authorization`](https://docs.solanamobile.com/react-native/quickstart#authorizing-a-wallet) from the wallet and receives your wallet account's info, like the public key.

On click, it starts a wallet session with `transact` and calls `authorizeSession` from the [`AuthorizationProvider`](https://github.com/solana-mobile/tutorial-apps/blob/main/first-mobile-dapp/components/AuthorizationProvider.tsx) class.

```tsx
await transact(async wallet => {
    await authorizeSession(wallet);
});
```

[`AuthorizationProvider`](https://github.com/solana-mobile/tutorial-apps/blob/main/first-mobile-dapp/components/AuthorizationProvider.tsx) is a helper class that manages wallet authorization. It calls `wallet.authorize()` on first connect, and for subsequent connects it re-uses
the `authToken` in `wallet.reauthorize()`.

```tsx
const authorizeSession = useCallback(
    async (wallet: AuthorizeAPI & ReauthorizeAPI) => {
        const authorizationResult = await (authorization
        ? wallet.reauthorize({
            auth_token: authorization.authToken,
            identity: APP_IDENTITY,
            })
        : wallet.authorize({
            cluster: APP_CLUSTER,
            identity: APP_IDENTITY,
            }));
        console.log(authorizationResult);
        return (await handleAuthorizationResult(authorizationResult))
        .selectedAccount;
    },
    [authorization, handleAuthorizationResult],
);
```

### Account Info [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#account-info "Direct link to Account Info")

This is a simple component takes a balance in [_lamports_](https://docs.solana.com/terminology#lamport) and converts it to units of [_SOL_](https://docs.solana.com/terminology#sol) for display.

#### Balance fetching [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#balance-fetching "Direct link to Balance fetching")

In the `MainScreen.tsx` component, we fetch the user's wallet balance when its available, and pass it into the `AccountInfo` component.
To do so, we use the `connection` class and just call the `getBalance` function, which is part of the [API spec](https://docs.solana.com/api/http#getbalance).

```tsx
const {connection} = useConnection();
const fetchAndUpdateBalance = useCallback(
    async (account: Account) => {
        const fetchedBalance = await connection.getBalance(account.publicKey);
        setBalance(fetchedBalance);
    },
    [connection],
);
```

### Airdrop Button [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#airdrop-button "Direct link to Airdrop Button")

This component takes in a user's wallet `publicKey` and requests an airdrop of lamports to that address on click. Again, we use the `connection` class
and call the `requestAirdrop` RPC method, as part of the [API spec](https://docs.solana.com/api/http#requestairdrop).

```tsx
const requestAirdrop = useCallback(async () => {
    const signature = await connection.requestAirdrop(
        selectedAccount.publicKey,
        LAMPORTS_PER_AIRDROP,
    );
    return await connection.confirmTransaction(signature);
}, [connection, selectedAccount]);
```

### Sign Transaction/Message Button [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#sign-transactionmessage-button "Direct link to Sign Transaction/Message Button")

The `SignMessageButton` component takes in a `messageBuffer` byte array and calls `wallet.signMessages()`. This requests the
connected wallet to sign the message with the user's private key.

The `SignTransactionButton` component does several things on click. Within the wallet session, it constructs a `Transaction` with a
`SystemProgram.transfer` instruction, then requests the wallet to provide a signature in the transaction.

- Sign Message
- Sign Transaction

```tsx
const signMessage = useCallback(
    async (messageBuffer: Uint8Array) => {
        return await transact(async (wallet: Web3MobileWallet) => {
        // First, request for authorization from the wallet.
        const authorizationResult = await authorizeSession(wallet);

        // Sign the payload with the provided address from authorization.
        const signedMessages = await wallet.signMessages({
            addresses: [authorizationResult.address],
            payloads: [messageBuffer],
        });

        return signedMessages[0];
        });
    },
    [authorizeSession],
);
```

```tsx
const signTransaction = useCallback(async () => {
    return await transact(async (wallet: Web3MobileWallet) => {
        const connection = new Connection(clusterApiUrl('devnet'), 'confirmed');

        // First, request for authorization from the wallet and fetch the latest
        // blockhash for building the transaction.
        const [authorizationResult, latestBlockhash] = await Promise.all([\
            authorizeSession(wallet),\
            connection.getLatestBlockhash(),\
        ]);

        // Construct a transaction. This transaction uses web3.js `SystemProgram`
        // to create a transfer that sends lamports to randomly generated address.
        const keypair = Keypair.generate();
        const randomTransferTransaction = new Transaction({
            ...latestBlockhash,
            feePayer: authorizationResult.publicKey,
        }).add(
        SystemProgram.transfer({
            fromPubkey: authorizationResult.publicKey,
            toPubkey: keypair.publicKey,
            lamports: 1_000,
        }),
        );

        // Sign a transaction and receive
        const signedTransactions = await wallet.signTransactions({
            transactions: [randomTransferTransaction],
        });

        return signedTransactions[0];
    }, [authorizeSession]);
});
```

## Send a memo transaction [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#send-a-memo-transaction "Direct link to Send a memo transaction")

Now that we've gone over the existing scaffold, lets add some new functionality to it.

Instead of a random transfer transaction, lets create a new transaction that records an immutable message on the Solana blockchain,
using the [Memo program](https://spl.solana.com/memo). After that, we can view our message on the [Solana Explorer](https://explorer.solana.com/).

### Copy over the SignTransactionButton [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#copy-over-the-signtransactionbutton "Direct link to Copy over the SignTransactionButton")

Lets build off our existing `SignTransactionButton`, and copy it over into a new component renamed to `SendMemoButton`. Then, rename the `signTransaction` helper function into `sendMemo`.

### Construct a memo program transaction [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#construct-a-memo-program-transaction "Direct link to Construct a memo program transaction")

First, let's replace the existing `randomTransferTransaction` with a new transaction that calls the Solana `Memo` program address. Within the `transact` block,
add this code and remove `randomTransferTransaction`.

```tsx
import {TextEncoder} from 'text-encoding'; // TextEncoder library to convert stirng to buffer.

// Construct a message buffer from a string.
const message = "Hello Solana!";
const messageBuffer = new TextEncoder().encode(message) as Buffer

// Construct a 'Hello World' transaction and replace `randomTransferTransaction
const memoProgramTransaction = new Transaction({
    ...latestBlockhash,
    feePayer: authorizationResult.publicKey,
}).add(
    new TransactionInstruction({
    data: messageBuffer,
    keys: [],
    programId: new PublicKey(
        'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr', // Memo Program address
    ),
    }),
);
```

### Request the wallet to sign and send a transaction [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#request-the-wallet-to-sign-and-send-a-transaction "Direct link to Request the wallet to sign and send a transaction")

Next, instead of `wallet.signTransactions()`, now lets request our wallet to send the transaction for us, with `wallet.signAndSendTransactions()`.

This is an optional feature that MWA wallets can choose to support, and `fakewallet` does support this. You can also directly use `connection`
to [send and confirm a transaction](https://solanacookbook.com/references/basic-transactions.html#how-to-send-sol).

```tsx
// Changed to `signAndSendTransactions.` and pass in `memoProgramTransaction`.
const transactionSignatures = await wallet.signAndSendTransactions({
    transactions: [memoProgramTransaction],
});
```

### Confirm the transaction [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#confirm-the-transaction "Direct link to Confirm the transaction")

Now, the last step is to confirm that the transaction was processed by the network. Add this to the send
of the `transact` session and return the both `[signature, confirmationRepsonse]`. Read the docs learn more about [transaction confirmation](https://docs.solana.com/developing/transaction_confirmation).

```tsx
// Add this step to confirm that the transaction was proccessed by the network.
const confirmationResponse = await connection.confirmTransaction({
    signature: signature,
    ...latestBlockhash,
});

return [signature, confirmationResponse];
```

### Add Solana Explorer link navigation [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#add-solana-explorer-link-navigation "Direct link to Add Solana Explorer link navigation")

After transaction confirmation, we can now view the message on the Solana blockchain itself! To do so,
we'll use the public tool [Solana Explorer](https://explorer.solana.com/), construct an explorer URL, and prompt the user to
navigate to the link through an alert.

```tsx
// Show an alert with an explorer link when we have a confirmed memo transaction.
function showExplorerAlert(memoTransactionSignature: string, cluster: string) {
  const explorerUrl =
    'https://explorer.solana.com/tx/' +
    memoTransactionSignature +
    '?cluster=' +
    cluster;
  Alert.alert(
    'Success!',
    'Your message was successfully recorded. View your message on Solana Explorer:',
    [\
      {text: 'View', onPress: () => Linking.openURL(explorerUrl)},\
      {text: 'Cancel', style: 'cancel'},\
    ],
  );
}
```

### Update the button onPress [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#update-the-button-onpress "Direct link to Update the button onPress")

Almost done! Now just update the `onPress` handler in the button component to call `sendMemo`, handle errors, and show the explorer URL.
Here is what the final code should look like at this step for `sendMemo` and the button component.

- SendMemoButton
- sendMemo

```tsx
return (
    <Button
        title="Send Memo!"
        disabled={signingInProgress}
        onPress={async () => {
            if (signingInProgress) {
                return;
            }
            setSigningInProgress(true);
            try {
                const [memoTransactionSignature, confirmationResponse] = await sendMemo();
                const err = confirmationResponse.value.err;
                if (err) {
                console.log(
                    'Failed to record message:' +
                    (err instanceof Error ? err.message : err),
                );
                } else {
                    // APP_CLUSTER is either 'devnet', 'testnet', 'mainnet-beta'.
                    showExplorerAlert(memoTransactionSignature, APP_CLUSTER);
                }
            } finally {
                setSigningInProgress(false);
            }
        }}
    />
);
```

```tsx
const sendMemo = useCallback(
    async (
        messageBuffer: Buffer,
    ): Promise<[string, RpcResponseAndContext<SignatureResult>]> => {
        const latestBlockhash = await connection.getLatestBlockhash();
        const signature = await transact(async (wallet: Web3MobileWallet) => {
        const authorizationResult = await authorizeSession(wallet);

        const memoProgramTransaction = new Transaction({
            ...latestBlockhash,
            feePayer: authorizationResult.publicKey,
        }).add(
            new TransactionInstruction({
            data: messageBuffer,
            keys: [],
            programId: new PublicKey(
                'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr', // Memo Program address
            ),
            }),
        );

        const transactionSignatures = await wallet.signAndSendTransactions({
            transactions: [memoProgramTransaction],
        });
            return transactionSignatures[0];
        });

        // Add this step to confirm that the transaction was proccessed by the network.
        const confirmationResponse = await connection.confirmTransaction({
            signature: signature,
            ...latestBlockhash,
        });

        return [signature, confirmationResponse];
    },
    [authorizeSession, connection],
);
```

### Finishing touches [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#finishing-touches "Direct link to Finishing touches")

Last step. All that's left is to render the new `SendMemoButton` in the app's `MainScreen`. Just change the existing `SignTransactionButton`
component into the `SendMemoButton` component and you're done!

Make sure you request an airdrop of SOL before pressing the `SendMemoButton`, as
you need to pay a small fee to send transactions on the network.

**Congratulations!**

You've finished the tutorial and built your first mobile dApp! Play around with the new `SendMemoButton` and view your message on the explorer. Make sure, you request
an airdrop of SOL before trying to send the transaction.

## Next steps [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#next-steps "Direct link to Next steps")

Explore guides and SDK references to learn more and create more advanced applications. Here are some links to explore:

### Sample App Collection [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#sample-app-collection "Direct link to Sample App Collection")

- If you want to see more examples of dApps, then check out this [curated list](https://docs.solanamobile.com/sample-apps/sample_app_overview) of Solana mobile sample apps. It also includes a more [robust version of the app](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/examples/example-react-native-app) built in this tutorial.

### Guides/References [​](https://docs.solanamobile.com/react-native/first_app_tutorial\#guidesreferences "Direct link to Guides/References")

- [web3.js Javascript SDK reference](https://solana-labs.github.io/solana-web3.js/)
- [Writing your own Solana programs](https://docs.solana.com/developing/on-chain-programs/overview)
- [Hello World Tutorial](https://docs.solanamobile.com/react-native/hello_world_tutorial): A lengthier tutorial that teaches how to write MWA UI components.

- [What you will learn](https://docs.solanamobile.com/react-native/first_app_tutorial#what-you-will-learn)
- [Prerequisites](https://docs.solanamobile.com/react-native/first_app_tutorial#prerequisites)
- [Clone the React Native dApp Scaffold](https://docs.solanamobile.com/react-native/first_app_tutorial#clone-the-react-native-dapp-scaffold)
  - [First run](https://docs.solanamobile.com/react-native/first_app_tutorial#first-run)
- [Scaffold dApp Components](https://docs.solanamobile.com/react-native/first_app_tutorial#scaffold-dapp-components)
  - [Connect Button](https://docs.solanamobile.com/react-native/first_app_tutorial#connect-button)
  - [Account Info](https://docs.solanamobile.com/react-native/first_app_tutorial#account-info)
  - [Airdrop Button](https://docs.solanamobile.com/react-native/first_app_tutorial#airdrop-button)
  - [Sign Transaction/Message Button](https://docs.solanamobile.com/react-native/first_app_tutorial#sign-transactionmessage-button)
- [Send a memo transaction](https://docs.solanamobile.com/react-native/first_app_tutorial#send-a-memo-transaction)
  - [Copy over the SignTransactionButton](https://docs.solanamobile.com/react-native/first_app_tutorial#copy-over-the-signtransactionbutton)
  - [Construct a memo program transaction](https://docs.solanamobile.com/react-native/first_app_tutorial#construct-a-memo-program-transaction)
  - [Request the wallet to sign and send a transaction](https://docs.solanamobile.com/react-native/first_app_tutorial#request-the-wallet-to-sign-and-send-a-transaction)
  - [Confirm the transaction](https://docs.solanamobile.com/react-native/first_app_tutorial#confirm-the-transaction)
  - [Add Solana Explorer link navigation](https://docs.solanamobile.com/react-native/first_app_tutorial#add-solana-explorer-link-navigation)
  - [Update the button onPress](https://docs.solanamobile.com/react-native/first_app_tutorial#update-the-button-onpress)
  - [Finishing touches](https://docs.solanamobile.com/react-native/first_app_tutorial#finishing-touches)
- [Next steps](https://docs.solanamobile.com/react-native/first_app_tutorial#next-steps)
  - [Sample App Collection](https://docs.solanamobile.com/react-native/first_app_tutorial#sample-app-collection)
  - [Guides/References](https://docs.solanamobile.com/react-native/first_app_tutorial#guidesreferences)

## Solana Mobile SDK Tutorial
[Skip to main content](https://docs.solanamobile.com/react-native/hello_world_tutorial#__docusaurus_skipToContent_fallback)

On this page

In this tutorial, we'll walk you through the process of setting up an Android React Native project and use the [Mobile Wallet Adapter Javascript library](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/js/packages) to build a simple user interface that allows you to connect to a mobile wallet, request an airdrop, and send a message to the Solana network.

By the end of this tutorial, you'll have an understanding of how to use the Solana Mobile SDK to build dApps that can interact with the Solana Blockchain.

## What you will learn [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#what-you-will-learn "Direct link to What you will learn")

- How to set up a React Native Android project and integrate the Mobile Wallet Adapter library.
- How to use Mobile Wallet Adapter to connect to an installed wallet app.
- How to connect to devnet, check your wallet balance, and request an airdrop of SOL.
- How to use the memo program to write your message to the network and see your message on the blockchain!

## Prerequisites [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#prerequisites "Direct link to Prerequisites")

Read the [**prerequisite setup**](https://docs.solanamobile.com/developers/development-setup) guide before starting the tutorial. This tutorial will be using the [fakewallet](https://docs.solanamobile.com/developers/development-setup#3-install-a-wallet-app) app to test your app's integration with Mobile Wallet Adapter.

### Clone the tutorial repo [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#clone-the-tutorial-repo "Direct link to Clone the tutorial repo")

Clone the [tutorial repo](https://github.com/solana-mobile/tutorial-apps/tree/main/SolanaReactNativeTutorial) from github.

```shell
git clone https://github.com/solana-mobile/tutorial-apps.git
cd SolanaReactNativeTutorial
```

There should be two folders:

- `SolanaReactNativeTutorialStarter`: A boilerplate app with the MWA packages/dependencies ready and starter code that we'll be building up throughout the tutorial.
- `SolanaReactNativeTutorialComplete`: The complete version of the app and the end product of the tutorial.

### First run [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#first-run "Direct link to First run")

Move into the starter project directory, install dependencies, and try running the app.

```shell
cd SolanaReactNativeTutorialStarter && yarn install && npx react-native start
```

In the Metro bundler menu, select the android option to build and launch the app in your device. Make changes to `MainScreen.tsx` and you can see your app update immediately, due to React Native's [_Fast Refresh_](https://reactnative.dev/docs/fast-refresh) feature.

## Connect to a wallet [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#connect-to-a-wallet "Direct link to Connect to a wallet")

Wallet apps manage your wallet's private key and can do actions like signing and sending transactions/messages. You will learn how use the [Mobile Wallet Adapter JS library](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/js/packages/mobile-wallet-adapter-protocol) to connect your dApp to the `fakewallet` app.

### Build a connect button [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#build-a-connect-button "Direct link to Build a connect button")

In `ConnectButton.tsx`:

- Use the `transact` function to start a session with a wallet app.
- Then within the session, request wallet authorization for the dApp.
- Save the results of authorization in the parent component's state.

After successful authorization, the dApp receives an `AuthorizationResult` object from `authorize`. It contains a list of `accounts` and an `authToken`.
Each account object contains useful information like the account's address (or `publicKey`) and account label. The `authToken` will be used for `reauthorization` in future `transact`'s with the wallet.

In `MainScreen.tsx`:

- Render the `ConnectButton` component below the `ScrollView`.
- Create `authorization` state and `setAuthorization` within `onConnect`.

- ConnectButton
- MainScreen

```tsx
export default function ConnectButton({onConnect}: ConnectButtonProps) {
  const onPress = async () => {
    await transact(async wallet => {
      // Transact starts a session with the wallet app during which our app
      // can send actions (like `authorize`) to the wallet.
      const authResult: AuthorizationResult = await wallet.authorize({
        cluster: 'devnet',
        identity: APP_IDENTITY,
      });
      const {accounts, auth_token} = authResult;

      // After authorizing, store the authResult with the onConnect callback we pass into the button
      onConnect({
        address: accounts[0].address,
        label: accounts[0].label,
        authToken: auth_token,
        publicKey: getPublicKeyFromAddress(accounts[0].address),
      });
    });
  };
  return (
    <TouchableOpacity style={styles.button} onPress={onPress}>
      <Text style={styles.buttonText}>Connect Wallet</Text>
    </TouchableOpacity>
  );
}
```

```tsx
export default function MainScreen() {
  const {connection} = useConnection();
  const [message, setMessage] = useState<string>('');
  const [authorization, setAuthorization] = useState<Authorization | null>(
    null,
  );
  return (
    <>
      <View style={styles.mainContainer}>
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <View style={styles.header}>
            <Text style={styles.headerText}>Hello Solana!</Text>
          </View>

          {/* Text Input */}
          <View>
            <Text style={styles.inputHeader}>What's on your mind?</Text>
            <TextInput
              style={styles.input}
              numberOfLines={1}
              onChangeText={text => setMessage(text)}
              placeholder="Write your message here"
            />
          </View>
        </ScrollView>
        <ConnectButton
          onConnect={async (authorization: Authorization) => {
            setAuthorization(authorization);
          }}
        />
      </View>
    </>
  );
}
```

### Build a disconnect button [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#build-a-disconnect-button "Direct link to Build a disconnect button")

We also want to give the users the option to disconnect their wallet from the app. We'll use a `deauthorize` request to invalidate the provided `authToken`.

In `DisconnectButton.tsx`:

- Pass in the stored `authorization` and, within a `transact` session, send a `deauthorize` request to the wallet for the stored `authToken`.

In `MainScreen.tsx`:

- Conditionally render the `ConnectButton` or `DisconnectButton`.
- Pass in `onDisconnect` as props, setting the stored `authorization` state to null.

- DisconnectButton
- MainScreen

```tsx
export default function DisconnectButton({
  onDisconnect,
  authorization,
}: DisconnectButtonProps) {
  const onPress = async () => {
    await transact(async wallet => {
      // The deauthorize request will invalidate the authToken.
      await wallet.deauthorize({
        auth_token: authorization.authToken,
      });
      // Set stored authorization state to null through onDisconnect callback
      onDisconnect();
    });
  };
  return (
    <TouchableOpacity style={styles.button} onPress={onPress}>
      <Text style={styles.buttonText}>Disconnect Wallet</Text>
    </TouchableOpacity>
  );
}
```

```tsx
export default function MainScreen() {
  const {connection} = useConnection();
  const [message, setMessage] = useState<string>('');
  const [authorization, setAuthorization] = useState<Authorization | null>(
    null,
  );
  return (
    <>
      <View style={styles.mainContainer}>
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <View style={styles.header}>
            <Text style={styles.headerText}>Hello Solana!</Text>
          </View>

          {/* Text Input */}
          <View>
            <Text style={styles.inputHeader}>What's on your mind?</Text>
            <TextInput
              style={styles.input}
              numberOfLines={1}
              onChangeText={text => setMessage(text)}
              placeholder="Write your message here"
            />
          </View>
        </ScrollView>

        {/* Conditionally render connect or disconnect,
            depending on if a wallet is connected */}
        {authorization === null ? (
          <ConnectButton
            onConnect={async (authorization: Authorization) => {
              setAuthorization(authorization);
            }}
          />
        ) : (
          <DisconnectButton
            authorization={authorization}
            onDisconnect={() => {
              setAuthorization(null);
            }}
          />
        )}
      </View>
    </>
  );
}
```

## View wallet account balance [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#view-wallet-account-balance "Direct link to View wallet account balance")

After connecting to a wallet, we'll use the `connection` class from `useConnection` to view your wallet account's SOL balance on devnet.

In `MainScreen.tsx`:

- Create a `balance` state and call `connection.getBalance(authorization.publicKey)` to fetch the wallet balance from devnet.
- Create a `useEffect` hook, that calls the fetches and updates the balance once connected to a wallet.
- Conditionally render the `AccountInfo` component if connected to a wallet.

In `AccountInfoSection.tsx`:

- The starter code includes function `convertLamportToSOL` because the number returned from `getBalance` is in units of [lamport](https://docs.solana.com/terminology#lamport).

note

The starter code handles wrapping the app with a `ConnectionProvider` in `App.tsx`, enabling the `useConnection` hook.

- AccountInfoSection
- MainScreen

```tsx
export default function AccountInfoSection({
  authorization,
  balance,
}: AccountInfoProps) {
  return (
    <View style={styles.container}>
      <View style={styles.textContainer}>
        <Text style={styles.walletBalance}>
          {balance !== null
            ? `Balance: ${convertLamportsToSOL(balance)} SOL`
            : 'Loading balance...'}
        </Text>
        <Text style={styles.walletName}>
          {authorization.label ?? 'Wallet name not found'}
        </Text>
        <Text style={styles.walletNameSubtitle}>{authorization.address}</Text>
      </View>
    </View>
  );
}
```

```tsx
export default function MainScreen() {
  const {connection} = useConnection();
  const [message, setMessage] = useState<string>('');
  const [authorization, setAuthorization] = useState<Authorization | null>(
    null,
  );
  const [balance, setBalance] = useState<number | null>(null);

  const fetchAndUpdateBalance = async (authorization: Authorization) => {
    // The ConnectionProvider (in App.tsx) is set to the devnet endpoint.
    const balance = await connection.getBalance(authorization.publicKey);
    console.log('Balance fetched: ' + balance);
    setBalance(balance);
  };

  useEffect(() => {
    // Fetch and update balance, if connected to a wallet.
    if (!authorization) {
      return;
    }
    fetchAndUpdateBalance(authorization);
  }, [authorization]);

  return (
    <>
      <View style={styles.mainContainer}>
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <View style={styles.header}>
            <Text style={styles.headerText}>Hello Solana!</Text>
          </View>

          {/* Text Input */}
          <View>
            <Text style={styles.inputHeader}>What's on your mind?</Text>
            <TextInput
              style={styles.input}
              numberOfLines={1}
              onChangeText={text => setMessage(text)}
              placeholder="Write your message here"
            />
          </View>

          {/* Conditionally render if connected to a wallet. */}
          {authorization !== null ? (
            <AccountInfo authorization={authorization} balance={balance} />
          ) : null}
        </ScrollView>
        {authorization === null ? (
          <ConnectButton
            onConnect={async (authorization: Authorization) => {
              setAuthorization(authorization);
            }}
          />
        ) : (
          <DisconnectButton
            authorization={authorization}
            onDisconnect={() => {
              setAuthorization(null);
            }}
          />
        )}
      </View>
    </>
  );
}
```

## Request a SOL airdrop [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#request-a-sol-airdrop "Direct link to Request a SOL airdrop")

If you try connecting to the wallet at this point, you'll notice that you have 0 SOL tokens in your balance.
In order to send transactions to devnet, we'll need to fund the account by requesting an airdrop.

With `RequestAirdropButton`, use `connection.requestAirdrop(...)` to request an airdrop to your wallet's address (public key).

Then in `MainScreen`, render the new button and pass in `fetchAndUpdateBalance(authorization)` to the `onAirdropComplete` prop.

note

Unfortunately, airdropping on devnet is prone to flakiness and a request can often fail. If you are seeing a transaction confirmation error
at this step, it's most likely because due to this instability.

- RequestAirdropButton
- MainScreen

```tsx
export default function RequestAirdropButton({
  authorization,
  onAirdropComplete,
}: AccountInfoProps) {
  const {connection} = useConnection();

  const requestAirdrop = async () => {
    // SOL/Lamports will be airdropped to the wallet's address (public key).
    // Use Promise.all to also fetch the latest block hash in parallel.
    const [signature, latestBlockhash] = await Promise.all([\
      connection.requestAirdrop(authorization.publicKey, LAMPORTS_PER_AIRDROP),\
      connection.getLatestBlockhash(),\
    ]);

    // Confirm that the airdrop was successful.
    return await connection.confirmTransaction({
      signature: signature,
      ...latestBlockhash,
    });
  };

  return (
    <TouchableOpacity
      style={styles.button}
      onPress={async () => {
        const result = await requestAirdrop();
        const error = result?.value?.err;
        if (error) {
          console.log(
            'Failed to fund account: ' +
              (error instanceof Error ? error.message : error),
          );
        } else {
          // Fetch and update balance if airdrop is successful
          onAirdropComplete(authorization);
        }
      }}>
      <Text style={styles.buttonText}>Request airdrop</Text>
    </TouchableOpacity>
  );
}
```

```tsx
export default function MainScreen() {
  const {connection} = useConnection();
  const [message, setMessage] = useState<string>('');
  const [authorization, setAuthorization] = useState<Authorization | null>(
    null,
  );
  const [balance, setBalance] = useState<number | null>(null);

  const fetchAndUpdateBalance = async (authorization: Authorization) => {
    // The ConnectionProvider (in App.tsx) is set to the devnet endpoint.
    const balance = await connection.getBalance(authorization.publicKey);
    console.log('Balance fetched: ' + balance);
    setBalance(balance);
  };

  useEffect(() => {
    // Fetch and update balance, after connecting to a wallet.
    if (!authorization) {
      return;
    }
    fetchAndUpdateBalance(authorization);
  }, [authorization]);

  return (
    <>
      <View style={styles.mainContainer}>
        <ScrollView contentContainerStyle={styles.scrollContainer}>
          <View style={styles.header}>
            <Text style={styles.headerText}>Hello Solana!</Text>
          </View>

          {/* Text Input */}
          <View>
            <Text style={styles.inputHeader}>What's on your mind?</Text>
            <TextInput
              style={styles.input}
              numberOfLines={1}
              onChangeText={text => setMessage(text)}
              placeholder="Write your message here"
            />
          </View>

          {/* Conditionally render if connected to a wallet. */}
          {authorization !== null ? (
            <AccountInfo authorization={authorization} balance={balance} />
          ) : null}
          <View style={styles.buttonGroup}>
            {authorization !== null ? (
              <RequestAirdropButton
                authorization={authorization}
                onAirdropComplete={(authorization: Authorization) => {
                  fetchAndUpdateBalance(authorization);
                }}
              />
            ) : null}
          </View>
        </ScrollView>
        {authorization === null ? (
          <ConnectButton
            onConnect={async (authorization: Authorization) => {
              setAuthorization(authorization);
            }}
          />
        ) : (
          <DisconnectButton
            authorization={authorization}
            onDisconnect={() => {
              setAuthorization(null);
            }}
          />
        )}
      </View>
    </>
  );
}
```

## Record a message to the blockchain [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#record-a-message-to-the-blockchain "Direct link to Record a message to the blockchain")

### Construct and send a transaction [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#construct-and-send-a-transaction "Direct link to Construct and send a transaction")

After receiving an airdrop successfully, you should see your SOL balance update to `0.1`. You can now pay the fee to send a transaction to record the message on the network. To do so, we'll be invoking an [on-chain program](https://docs.solana.com/developing/intro/programs#on-chain-programs) called the [`MemoProgram`](https://spl.solana.com/memo).

In `RecordMessageButton.tsx`, create a function `recordMessage` that:

- Constructs the `MemoProgram` Transaction.
- Sends a `signAndSendTransaction` request to the wallet.
- The wallet then signs the transaction with the private key and sends it to devnet.

- recordMessage
- RecordMessageButton

```tsx
// Takes in a `Buffer` type that represents the message string.
async function recordMessage(
  connection: Connection,
  authorization: Authorization,
  messageBuffer: Buffer,
): Promise<[string, RpcResponseAndContext<SignatureResult>]> {
  const [signature] = await transact(async wallet => {
    // Start a wallet session with `transact` and `reauthorize` our dApp by passing in the `authToken`.
    // Use Promise.all to also fetch the latest block hash in parallel.
    const [authResult, latestBlockhash] = await Promise.all([\
      wallet.reauthorize({\
        auth_token: authorization.authToken,\
        identity: APP_IDENTITY,\
      }),\
      connection.getLatestBlockhash(),\
    ]);

    // Construct a `Transaction` with an instruction to invoke the `MemoProgram`.
    const memoProgramTransaction = new Transaction({
      ...latestBlockhash,
      feePayer: authorization.publicKey,
    }).add(
      new TransactionInstruction({
        data: messageBuffer,
        keys: [],
        programId: new PublicKey(
          'MemoSq4gqABAXKb96qnH8TysNcWxMyWCqXgDLGmfcHr', // Memo Program address
        ),
      }),
    );

    // Send a `signAndSendTransactions` request to the wallet. The wallet will sign the transaction with the private key and send it to devnet.
    return await wallet.signAndSendTransactions({
      transactions: [memoProgramTransaction],
    });
  });

  const latestBlockhash = await connection.getLatestBlockhash();
  return [\
    signature,\
    await connection.confirmTransaction({\
      signature: signature,\
      ...latestBlockhash,\
    }),\
  ];
}
```

```tsx
export default function RecordMessageButton({
  authorization,
  message,
}: RecordMessageButtonProps) {
  const {connection} = useConnection();
  const buttonDisabled = message === null || message.length === 0;
  const buttonStyle = buttonDisabled ? styles.disabled : styles.enabled;
  return (
    <TouchableOpacity
      disabled={buttonDisabled}
      style={[styles.button, buttonStyle]}
      onPress={async () => {
        const result = await recordMessage(
          connection,
          authorization,
          new TextEncoder().encode(message) as Buffer,
        );
        if (result) {
          const [signature, response] = result;
          const err = response.value.err;
          if (err) {
            console.log(
              'Failed to record message:' +
                (err instanceof Error ? err.message : err),
            );
          } else {
            const explorerUrl =
              'https://explorer.solana.com/tx/' +
              signature +
              '?cluster=' +
              WalletAdapterNetwork.Devnet;
            console.log(
              'Successfully recorded a message. View your message at: ' +
                explorerUrl,
            );
            // TODO: Add an alert to give the user an option to click the link.
          }
        }
      }}>
      <Text style={styles.buttonText}>Record message</Text>
    </TouchableOpacity>
  );
}
```

### View your message on explorer [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#view-your-message-on-explorer "Direct link to View your message on explorer")

If this transaction is successful, you can use the [Solana Explorer](https://explorer.solana.com/) to see your message on the blockchain itself.

On the success case, add an `Alert` to give the user the option to click a link and navigate to the `explorerUrl`.

```tsx
Alert.alert(
       'Success!',
       'Your message was successfully recorded. View your message on Solana Explorer:',
    [\
       { text: 'View', onPress: () => Linking.openURL(explorerUrl) },\
       { text: 'Cancel', style: 'cancel' },\
    ]
);
```

You should now be seeing the alert after clicking the `RecordMessageButton`.

_**Congratulations!**_

You've successfully recorded your message onto the Solana blockchain and created a functioning Solana Mobile dApp! 🎉

## Next steps [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#next-steps "Direct link to Next steps")

Explore guides and SDK references to learn more and create more advanced applications. Here are some links to explore:

### Sample App Collection [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#sample-app-collection "Direct link to Sample App Collection")

- If you want to see more examples of dApps, then check out this [curated list](https://docs.solanamobile.com/sample-apps/sample_app_overview) of Solana mobile sample apps. It also includes a more [robust version of the app](https://github.com/solana-mobile/mobile-wallet-adapter/tree/main/examples/example-react-native-app) built in this tutorial.

### Guides/References [​](https://docs.solanamobile.com/react-native/hello_world_tutorial\#guidesreferences "Direct link to Guides/References")

- [web3.js Javascript SDK reference](https://solana-labs.github.io/solana-web3.js/)
- [Writing your own Solana programs](https://docs.solana.com/developing/on-chain-programs/overview)

- [What you will learn](https://docs.solanamobile.com/react-native/hello_world_tutorial#what-you-will-learn)
- [Prerequisites](https://docs.solanamobile.com/react-native/hello_world_tutorial#prerequisites)
  - [Clone the tutorial repo](https://docs.solanamobile.com/react-native/hello_world_tutorial#clone-the-tutorial-repo)
  - [First run](https://docs.solanamobile.com/react-native/hello_world_tutorial#first-run)
- [Connect to a wallet](https://docs.solanamobile.com/react-native/hello_world_tutorial#connect-to-a-wallet)
  - [Build a connect button](https://docs.solanamobile.com/react-native/hello_world_tutorial#build-a-connect-button)
  - [Build a disconnect button](https://docs.solanamobile.com/react-native/hello_world_tutorial#build-a-disconnect-button)
- [View wallet account balance](https://docs.solanamobile.com/react-native/hello_world_tutorial#view-wallet-account-balance)
- [Request a SOL airdrop](https://docs.solanamobile.com/react-native/hello_world_tutorial#request-a-sol-airdrop)
- [Record a message to the blockchain](https://docs.solanamobile.com/react-native/hello_world_tutorial#record-a-message-to-the-blockchain)
  - [Construct and send a transaction](https://docs.solanamobile.com/react-native/hello_world_tutorial#construct-and-send-a-transaction)
  - [View your message on explorer](https://docs.solanamobile.com/react-native/hello_world_tutorial#view-your-message-on-explorer)
- [Next steps](https://docs.solanamobile.com/react-native/hello_world_tutorial#next-steps)
  - [Sample App Collection](https://docs.solanamobile.com/react-native/hello_world_tutorial#sample-app-collection)
  - [Guides/References](https://docs.solanamobile.com/react-native/hello_world_tutorial#guidesreferences)

